"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/visjs-network/dist/vis.js
  var require_vis = __commonJS({
    "node_modules/visjs-network/dist/vis.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports === "object")
          exports["vis"] = factory();
        else
          root["vis"] = factory();
      })(typeof self !== "undefined" ? self : exports, function() {
        return function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              i: moduleId,
              l: false,
              exports: {}
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                configurable: false,
                enumerable: true,
                get: getter
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? function getDefault() {
              return module2["default"];
            } : function getModuleExports() {
              return module2;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 85);
        }([
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2.default = function(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _defineProperty = __webpack_require__(130);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  (0, _defineProperty2.default)(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _getIterator2 = __webpack_require__(58);
            var _getIterator3 = _interopRequireDefault(_getIterator2);
            var _create = __webpack_require__(31);
            var _create2 = _interopRequireDefault(_create);
            var _keys = __webpack_require__(9);
            var _keys2 = _interopRequireDefault(_keys);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var moment = __webpack_require__(71);
            var uuid = __webpack_require__(119);
            exports2.isNumber = function(object) {
              return object instanceof Number || typeof object == "number";
            };
            exports2.recursiveDOMDelete = function(DOMobject) {
              if (DOMobject) {
                while (DOMobject.hasChildNodes() === true) {
                  exports2.recursiveDOMDelete(DOMobject.firstChild);
                  DOMobject.removeChild(DOMobject.firstChild);
                }
              }
            };
            exports2.isString = function(object) {
              return object instanceof String || typeof object == "string";
            };
            exports2.isDate = function(object) {
              if (object instanceof Date) {
                return true;
              } else if (exports2.isString(object)) {
                var match = ASPDateRegex.exec(object);
                if (match) {
                  return true;
                } else if (!isNaN(Date.parse(object))) {
                  return true;
                }
              }
              return false;
            };
            exports2.randomUUID = function() {
              return uuid.v4();
            };
            function copyOrDelete(a, b, prop, allowDeletion) {
              var doDeletion = false;
              if (allowDeletion === true) {
                doDeletion = b[prop] === null && a[prop] !== void 0;
              }
              if (doDeletion) {
                delete a[prop];
              } else {
                a[prop] = b[prop];
              }
            }
            exports2.fillIfDefined = function(a, b) {
              var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              for (var prop in a) {
                if (b[prop] !== void 0) {
                  if (b[prop] === null || (0, _typeof3["default"])(b[prop]) !== "object") {
                    copyOrDelete(a, b, prop, allowDeletion);
                  } else {
                    if ((0, _typeof3["default"])(a[prop]) === "object") {
                      exports2.fillIfDefined(a[prop], b[prop], allowDeletion);
                    }
                  }
                }
              }
            };
            exports2.extend = function(a) {
              for (var i = 1; i < arguments.length; i++) {
                var other = arguments[i];
                for (var prop in other) {
                  if (other.hasOwnProperty(prop)) {
                    a[prop] = other[prop];
                  }
                }
              }
              return a;
            };
            exports2.selectiveExtend = function(props, a) {
              if (!Array.isArray(props)) {
                throw new Error("Array with property names expected as first argument");
              }
              for (var i = 2; i < arguments.length; i++) {
                var other = arguments[i];
                for (var p = 0; p < props.length; p++) {
                  var prop = props[p];
                  if (other && other.hasOwnProperty(prop)) {
                    a[prop] = other[prop];
                  }
                }
              }
              return a;
            };
            exports2.selectiveDeepExtend = function(props, a, b) {
              var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
              if (Array.isArray(b)) {
                throw new TypeError("Arrays are not supported by deepExtend");
              }
              for (var p = 0; p < props.length; p++) {
                var prop = props[p];
                if (b.hasOwnProperty(prop)) {
                  if (b[prop] && b[prop].constructor === Object) {
                    if (a[prop] === void 0) {
                      a[prop] = {};
                    }
                    if (a[prop].constructor === Object) {
                      exports2.deepExtend(a[prop], b[prop], false, allowDeletion);
                    } else {
                      copyOrDelete(a, b, prop, allowDeletion);
                    }
                  } else if (Array.isArray(b[prop])) {
                    throw new TypeError("Arrays are not supported by deepExtend");
                  } else {
                    copyOrDelete(a, b, prop, allowDeletion);
                  }
                }
              }
              return a;
            };
            exports2.selectiveNotDeepExtend = function(propsToExclude, a, b) {
              var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
              if (Array.isArray(b)) {
                throw new TypeError("Arrays are not supported by deepExtend");
              }
              for (var prop in b) {
                if (!b.hasOwnProperty(prop))
                  continue;
                if (propsToExclude.indexOf(prop) !== -1)
                  continue;
                if (b[prop] && b[prop].constructor === Object) {
                  if (a[prop] === void 0) {
                    a[prop] = {};
                  }
                  if (a[prop].constructor === Object) {
                    exports2.deepExtend(a[prop], b[prop]);
                  } else {
                    copyOrDelete(a, b, prop, allowDeletion);
                  }
                } else if (Array.isArray(b[prop])) {
                  a[prop] = [];
                  for (var i = 0; i < b[prop].length; i++) {
                    a[prop].push(b[prop][i]);
                  }
                } else {
                  copyOrDelete(a, b, prop, allowDeletion);
                }
              }
              return a;
            };
            exports2.deepExtend = function(a, b) {
              var protoExtend = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
              for (var prop in b) {
                if (b.hasOwnProperty(prop) || protoExtend === true) {
                  if (b[prop] && b[prop].constructor === Object) {
                    if (a[prop] === void 0) {
                      a[prop] = {};
                    }
                    if (a[prop].constructor === Object) {
                      exports2.deepExtend(a[prop], b[prop], protoExtend);
                    } else {
                      copyOrDelete(a, b, prop, allowDeletion);
                    }
                  } else if (Array.isArray(b[prop])) {
                    a[prop] = [];
                    for (var i = 0; i < b[prop].length; i++) {
                      a[prop].push(b[prop][i]);
                    }
                  } else {
                    copyOrDelete(a, b, prop, allowDeletion);
                  }
                }
              }
              return a;
            };
            exports2.equalArray = function(a, b) {
              if (a.length != b.length)
                return false;
              for (var i = 0, len = a.length; i < len; i++) {
                if (a[i] != b[i])
                  return false;
              }
              return true;
            };
            exports2.convert = function(object, type) {
              var match;
              if (object === void 0) {
                return void 0;
              }
              if (object === null) {
                return null;
              }
              if (!type) {
                return object;
              }
              if (!(typeof type === "string") && !(type instanceof String)) {
                throw new Error("Type must be a string");
              }
              switch (type) {
                case "boolean":
                case "Boolean":
                  return Boolean(object);
                case "number":
                case "Number":
                  if (exports2.isString(object) && !isNaN(Date.parse(object))) {
                    return moment(object).valueOf();
                  } else {
                    return Number(object.valueOf());
                  }
                case "string":
                case "String":
                  return String(object);
                case "Date":
                  if (exports2.isNumber(object)) {
                    return new Date(object);
                  }
                  if (object instanceof Date) {
                    return new Date(object.valueOf());
                  } else if (moment.isMoment(object)) {
                    return new Date(object.valueOf());
                  }
                  if (exports2.isString(object)) {
                    match = ASPDateRegex.exec(object);
                    if (match) {
                      return new Date(Number(match[1]));
                    } else {
                      return moment(new Date(object)).toDate();
                    }
                  } else {
                    throw new Error("Cannot convert object of type " + exports2.getType(object) + " to type Date");
                  }
                case "Moment":
                  if (exports2.isNumber(object)) {
                    return moment(object);
                  }
                  if (object instanceof Date) {
                    return moment(object.valueOf());
                  } else if (moment.isMoment(object)) {
                    return moment(object);
                  }
                  if (exports2.isString(object)) {
                    match = ASPDateRegex.exec(object);
                    if (match) {
                      return moment(Number(match[1]));
                    } else {
                      return moment(object);
                    }
                  } else {
                    throw new Error("Cannot convert object of type " + exports2.getType(object) + " to type Date");
                  }
                case "ISODate":
                  if (exports2.isNumber(object)) {
                    return new Date(object);
                  } else if (object instanceof Date) {
                    return object.toISOString();
                  } else if (moment.isMoment(object)) {
                    return object.toDate().toISOString();
                  } else if (exports2.isString(object)) {
                    match = ASPDateRegex.exec(object);
                    if (match) {
                      return new Date(Number(match[1])).toISOString();
                    } else {
                      return moment(object).format();
                    }
                  } else {
                    throw new Error("Cannot convert object of type " + exports2.getType(object) + " to type ISODate");
                  }
                case "ASPDate":
                  if (exports2.isNumber(object)) {
                    return "/Date(" + object + ")/";
                  } else if (object instanceof Date) {
                    return "/Date(" + object.valueOf() + ")/";
                  } else if (exports2.isString(object)) {
                    match = ASPDateRegex.exec(object);
                    var value;
                    if (match) {
                      value = new Date(Number(match[1])).valueOf();
                    } else {
                      value = new Date(object).valueOf();
                    }
                    return "/Date(" + value + ")/";
                  } else {
                    throw new Error("Cannot convert object of type " + exports2.getType(object) + " to type ASPDate");
                  }
                default:
                  throw new Error('Unknown type "' + type + '"');
              }
            };
            var ASPDateRegex = /^\/?Date\((\-?\d+)/i;
            exports2.getType = function(object) {
              var type = typeof object === "undefined" ? "undefined" : (0, _typeof3["default"])(object);
              if (type == "object") {
                if (object === null) {
                  return "null";
                }
                if (object instanceof Boolean) {
                  return "Boolean";
                }
                if (object instanceof Number) {
                  return "Number";
                }
                if (object instanceof String) {
                  return "String";
                }
                if (Array.isArray(object)) {
                  return "Array";
                }
                if (object instanceof Date) {
                  return "Date";
                }
                return "Object";
              } else if (type == "number") {
                return "Number";
              } else if (type == "boolean") {
                return "Boolean";
              } else if (type == "string") {
                return "String";
              } else if (type === void 0) {
                return "undefined";
              }
              return type;
            };
            exports2.copyAndExtendArray = function(arr, newValue) {
              var newArr = [];
              for (var i = 0; i < arr.length; i++) {
                newArr.push(arr[i]);
              }
              newArr.push(newValue);
              return newArr;
            };
            exports2.copyArray = function(arr) {
              var newArr = [];
              for (var i = 0; i < arr.length; i++) {
                newArr.push(arr[i]);
              }
              return newArr;
            };
            exports2.getAbsoluteLeft = function(elem) {
              return elem.getBoundingClientRect().left;
            };
            exports2.getAbsoluteRight = function(elem) {
              return elem.getBoundingClientRect().right;
            };
            exports2.getAbsoluteTop = function(elem) {
              return elem.getBoundingClientRect().top;
            };
            exports2.addClassName = function(elem, classNames) {
              var classes = elem.className.split(" ");
              var newClasses = classNames.split(" ");
              classes = classes.concat(newClasses.filter(function(className) {
                return classes.indexOf(className) < 0;
              }));
              elem.className = classes.join(" ");
            };
            exports2.removeClassName = function(elem, classNames) {
              var classes = elem.className.split(" ");
              var oldClasses = classNames.split(" ");
              classes = classes.filter(function(className) {
                return oldClasses.indexOf(className) < 0;
              });
              elem.className = classes.join(" ");
            };
            exports2.forEach = function(object, callback) {
              var i, len;
              if (Array.isArray(object)) {
                for (i = 0, len = object.length; i < len; i++) {
                  callback(object[i], i, object);
                }
              } else {
                for (i in object) {
                  if (object.hasOwnProperty(i)) {
                    callback(object[i], i, object);
                  }
                }
              }
            };
            exports2.toArray = function(object) {
              var array = [];
              for (var prop in object) {
                if (object.hasOwnProperty(prop))
                  array.push(object[prop]);
              }
              return array;
            };
            exports2.updateProperty = function(object, key, value) {
              if (object[key] !== value) {
                object[key] = value;
                return true;
              } else {
                return false;
              }
            };
            exports2.throttle = function(fn) {
              var scheduled = false;
              return function throttled() {
                if (!scheduled) {
                  scheduled = true;
                  requestAnimationFrame(function() {
                    scheduled = false;
                    fn();
                  });
                }
              };
            };
            exports2.addEventListener = function(element, action, listener, useCapture) {
              if (element.addEventListener) {
                if (useCapture === void 0)
                  useCapture = false;
                if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
                  action = "DOMMouseScroll";
                }
                element.addEventListener(action, listener, useCapture);
              } else {
                element.attachEvent("on" + action, listener);
              }
            };
            exports2.removeEventListener = function(element, action, listener, useCapture) {
              if (element.removeEventListener) {
                if (useCapture === void 0)
                  useCapture = false;
                if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
                  action = "DOMMouseScroll";
                }
                element.removeEventListener(action, listener, useCapture);
              } else {
                element.detachEvent("on" + action, listener);
              }
            };
            exports2.preventDefault = function(event) {
              if (!event)
                event = window.event;
              if (event.preventDefault) {
                event.preventDefault();
              } else {
                event.returnValue = false;
              }
            };
            exports2.getTarget = function(event) {
              if (!event) {
                event = window.event;
              }
              var target;
              if (event.target) {
                target = event.target;
              } else if (event.srcElement) {
                target = event.srcElement;
              }
              if (target.nodeType != void 0 && target.nodeType == 3) {
                target = target.parentNode;
              }
              return target;
            };
            exports2.hasParent = function(element, parent) {
              var e = element;
              while (e) {
                if (e === parent) {
                  return true;
                }
                e = e.parentNode;
              }
              return false;
            };
            exports2.option = {};
            exports2.option.asBoolean = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              if (value != null) {
                return value != false;
              }
              return defaultValue || null;
            };
            exports2.option.asNumber = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              if (value != null) {
                return Number(value) || defaultValue || null;
              }
              return defaultValue || null;
            };
            exports2.option.asString = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              if (value != null) {
                return String(value);
              }
              return defaultValue || null;
            };
            exports2.option.asSize = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              if (exports2.isString(value)) {
                return value;
              } else if (exports2.isNumber(value)) {
                return value + "px";
              } else {
                return defaultValue || null;
              }
            };
            exports2.option.asElement = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              return value || defaultValue || null;
            };
            exports2.hexToRGB = function(hex) {
              var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
              hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                return r + r + g + g + b + b;
              });
              var result2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
              return result2 ? {
                r: parseInt(result2[1], 16),
                g: parseInt(result2[2], 16),
                b: parseInt(result2[3], 16)
              } : null;
            };
            exports2.overrideOpacity = function(color, opacity) {
              var rgb;
              if (color.indexOf("rgba") != -1) {
                return color;
              } else if (color.indexOf("rgb") != -1) {
                rgb = color.substr(color.indexOf("(") + 1).replace(")", "").split(",");
                return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
              } else {
                rgb = exports2.hexToRGB(color);
                if (rgb == null) {
                  return color;
                } else {
                  return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
                }
              }
            };
            exports2.RGBToHex = function(red, green, blue) {
              return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
            };
            exports2.parseColor = function(color) {
              var c;
              if (exports2.isString(color) === true) {
                if (exports2.isValidRGB(color) === true) {
                  var rgb = color.substr(4).substr(0, color.length - 5).split(",").map(function(value) {
                    return parseInt(value);
                  });
                  color = exports2.RGBToHex(rgb[0], rgb[1], rgb[2]);
                }
                if (exports2.isValidHex(color) === true) {
                  var hsv = exports2.hexToHSV(color);
                  var lighterColorHSV = {
                    h: hsv.h,
                    s: hsv.s * 0.8,
                    v: Math.min(1, hsv.v * 1.02)
                  };
                  var darkerColorHSV = {
                    h: hsv.h,
                    s: Math.min(1, hsv.s * 1.25),
                    v: hsv.v * 0.8
                  };
                  var darkerColorHex = exports2.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
                  var lighterColorHex = exports2.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
                  c = {
                    background: color,
                    border: darkerColorHex,
                    highlight: {
                      background: lighterColorHex,
                      border: darkerColorHex
                    },
                    hover: {
                      background: lighterColorHex,
                      border: darkerColorHex
                    }
                  };
                } else {
                  c = {
                    background: color,
                    border: color,
                    highlight: {
                      background: color,
                      border: color
                    },
                    hover: {
                      background: color,
                      border: color
                    }
                  };
                }
              } else {
                c = {};
                c.background = color.background || void 0;
                c.border = color.border || void 0;
                if (exports2.isString(color.highlight)) {
                  c.highlight = {
                    border: color.highlight,
                    background: color.highlight
                  };
                } else {
                  c.highlight = {};
                  c.highlight.background = color.highlight && color.highlight.background || void 0;
                  c.highlight.border = color.highlight && color.highlight.border || void 0;
                }
                if (exports2.isString(color.hover)) {
                  c.hover = {
                    border: color.hover,
                    background: color.hover
                  };
                } else {
                  c.hover = {};
                  c.hover.background = color.hover && color.hover.background || void 0;
                  c.hover.border = color.hover && color.hover.border || void 0;
                }
              }
              return c;
            };
            exports2.RGBToHSV = function(red, green, blue) {
              red = red / 255;
              green = green / 255;
              blue = blue / 255;
              var minRGB = Math.min(red, Math.min(green, blue));
              var maxRGB = Math.max(red, Math.max(green, blue));
              if (minRGB == maxRGB) {
                return { h: 0, s: 0, v: minRGB };
              }
              var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
              var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
              var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
              var saturation = (maxRGB - minRGB) / maxRGB;
              var value = maxRGB;
              return { h: hue, s: saturation, v: value };
            };
            var cssUtil = {
              split: function split(cssText) {
                var styles = {};
                cssText.split(";").forEach(function(style) {
                  if (style.trim() != "") {
                    var parts = style.split(":");
                    var key = parts[0].trim();
                    var value = parts[1].trim();
                    styles[key] = value;
                  }
                });
                return styles;
              },
              join: function join(styles) {
                return (0, _keys2["default"])(styles).map(function(key) {
                  return key + ": " + styles[key];
                }).join("; ");
              }
            };
            exports2.addCssText = function(element, cssText) {
              var currentStyles = cssUtil.split(element.style.cssText);
              var newStyles = cssUtil.split(cssText);
              var styles = exports2.extend(currentStyles, newStyles);
              element.style.cssText = cssUtil.join(styles);
            };
            exports2.removeCssText = function(element, cssText) {
              var styles = cssUtil.split(element.style.cssText);
              var removeStyles = cssUtil.split(cssText);
              for (var key in removeStyles) {
                if (removeStyles.hasOwnProperty(key)) {
                  delete styles[key];
                }
              }
              element.style.cssText = cssUtil.join(styles);
            };
            exports2.HSVToRGB = function(h, s, v) {
              var r, g, b;
              var i = Math.floor(h * 6);
              var f = h * 6 - i;
              var p = v * (1 - s);
              var q = v * (1 - f * s);
              var t = v * (1 - (1 - f) * s);
              switch (i % 6) {
                case 0:
                  ;
                  r = v, g = t, b = p;
                  break;
                case 1:
                  ;
                  r = q, g = v, b = p;
                  break;
                case 2:
                  ;
                  r = p, g = v, b = t;
                  break;
                case 3:
                  ;
                  r = p, g = q, b = v;
                  break;
                case 4:
                  ;
                  r = t, g = p, b = v;
                  break;
                case 5:
                  ;
                  r = v, g = p, b = q;
                  break;
              }
              return {
                r: Math.floor(r * 255),
                g: Math.floor(g * 255),
                b: Math.floor(b * 255)
              };
            };
            exports2.HSVToHex = function(h, s, v) {
              var rgb = exports2.HSVToRGB(h, s, v);
              return exports2.RGBToHex(rgb.r, rgb.g, rgb.b);
            };
            exports2.hexToHSV = function(hex) {
              var rgb = exports2.hexToRGB(hex);
              return exports2.RGBToHSV(rgb.r, rgb.g, rgb.b);
            };
            exports2.isValidHex = function(hex) {
              var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
              return isOk;
            };
            exports2.isValidRGB = function(rgb) {
              rgb = rgb.replace(" ", "");
              var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
              return isOk;
            };
            exports2.isValidRGBA = function(rgba) {
              rgba = rgba.replace(" ", "");
              var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
              return isOk;
            };
            exports2.selectiveBridgeObject = function(fields, referenceObject) {
              if (referenceObject !== null && (typeof referenceObject === "undefined" ? "undefined" : (0, _typeof3["default"])(referenceObject)) === "object") {
                var objectTo = (0, _create2["default"])(referenceObject);
                for (var i = 0; i < fields.length; i++) {
                  if (referenceObject.hasOwnProperty(fields[i])) {
                    if ((0, _typeof3["default"])(referenceObject[fields[i]]) == "object") {
                      objectTo[fields[i]] = exports2.bridgeObject(referenceObject[fields[i]]);
                    }
                  }
                }
                return objectTo;
              } else {
                return null;
              }
            };
            exports2.bridgeObject = function(referenceObject) {
              if (referenceObject !== null && (typeof referenceObject === "undefined" ? "undefined" : (0, _typeof3["default"])(referenceObject)) === "object") {
                var objectTo = (0, _create2["default"])(referenceObject);
                if (referenceObject instanceof Element) {
                  objectTo = referenceObject;
                } else {
                  objectTo = (0, _create2["default"])(referenceObject);
                  for (var i in referenceObject) {
                    if (referenceObject.hasOwnProperty(i)) {
                      if ((0, _typeof3["default"])(referenceObject[i]) == "object") {
                        objectTo[i] = exports2.bridgeObject(referenceObject[i]);
                      }
                    }
                  }
                }
                return objectTo;
              } else {
                return null;
              }
            };
            exports2.insertSort = function(a, compare) {
              for (var i = 0; i < a.length; i++) {
                var k = a[i];
                for (var j = i; j > 0 && compare(k, a[j - 1]) < 0; j--) {
                  a[j] = a[j - 1];
                }
                a[j] = k;
              }
              return a;
            };
            exports2.mergeOptions = function(mergeTarget, options, option) {
              var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
              var isPresent = function isPresent2(obj) {
                return obj !== null && obj !== void 0;
              };
              var isObject2 = function isObject3(obj) {
                return obj !== null && (typeof obj === "undefined" ? "undefined" : (0, _typeof3["default"])(obj)) === "object";
              };
              var isEmpty = function isEmpty2(obj) {
                for (var x in obj) {
                  if (obj.hasOwnProperty(x))
                    return false;
                }
                return true;
              };
              if (!isObject2(mergeTarget)) {
                throw new Error("Parameter mergeTarget must be an object");
              }
              if (!isObject2(options)) {
                throw new Error("Parameter options must be an object");
              }
              if (!isPresent(option)) {
                throw new Error("Parameter option must have a value");
              }
              if (!isObject2(globalOptions)) {
                throw new Error("Parameter globalOptions must be an object");
              }
              var doMerge = function doMerge2(target, options2, option2) {
                if (!isObject2(target[option2])) {
                  target[option2] = {};
                }
                var src = options2[option2];
                var dst = target[option2];
                for (var prop in src) {
                  if (src.hasOwnProperty(prop)) {
                    dst[prop] = src[prop];
                  }
                }
              };
              var srcOption = options[option];
              var globalPassed = isObject2(globalOptions) && !isEmpty(globalOptions);
              var globalOption = globalPassed ? globalOptions[option] : void 0;
              var globalEnabled = globalOption ? globalOption.enabled : void 0;
              if (srcOption === void 0) {
                return;
              }
              if (typeof srcOption === "boolean") {
                if (!isObject2(mergeTarget[option])) {
                  mergeTarget[option] = {};
                }
                mergeTarget[option].enabled = srcOption;
                return;
              }
              if (srcOption === null && !isObject2(mergeTarget[option])) {
                if (isPresent(globalOption)) {
                  mergeTarget[option] = (0, _create2["default"])(globalOption);
                } else {
                  return;
                }
              }
              if (!isObject2(srcOption)) {
                return;
              }
              var enabled = true;
              if (srcOption.enabled !== void 0) {
                enabled = srcOption.enabled;
              } else {
                if (globalEnabled !== void 0) {
                  enabled = globalOption.enabled;
                }
              }
              doMerge(mergeTarget, options, option);
              mergeTarget[option].enabled = enabled;
            };
            exports2.binarySearchCustom = function(orderedItems, comparator, field, field2) {
              var maxIterations = 1e4;
              var iteration = 0;
              var low = 0;
              var high = orderedItems.length - 1;
              while (low <= high && iteration < maxIterations) {
                var middle = Math.floor((low + high) / 2);
                var item = orderedItems[middle];
                var value = field2 === void 0 ? item[field] : item[field][field2];
                var searchResult = comparator(value);
                if (searchResult == 0) {
                  return middle;
                } else if (searchResult == -1) {
                  low = middle + 1;
                } else {
                  high = middle - 1;
                }
                iteration++;
              }
              return -1;
            };
            exports2.binarySearchValue = function(orderedItems, target, field, sidePreference, comparator) {
              var maxIterations = 1e4;
              var iteration = 0;
              var low = 0;
              var high = orderedItems.length - 1;
              var prevValue, value, nextValue, middle;
              comparator = comparator != void 0 ? comparator : function(a, b) {
                return a == b ? 0 : a < b ? -1 : 1;
              };
              while (low <= high && iteration < maxIterations) {
                middle = Math.floor(0.5 * (high + low));
                prevValue = orderedItems[Math.max(0, middle - 1)][field];
                value = orderedItems[middle][field];
                nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];
                if (comparator(value, target) == 0) {
                  return middle;
                } else if (comparator(prevValue, target) < 0 && comparator(value, target) > 0) {
                  return sidePreference == "before" ? Math.max(0, middle - 1) : middle;
                } else if (comparator(value, target) < 0 && comparator(nextValue, target) > 0) {
                  return sidePreference == "before" ? middle : Math.min(orderedItems.length - 1, middle + 1);
                } else {
                  if (comparator(value, target) < 0) {
                    low = middle + 1;
                  } else {
                    high = middle - 1;
                  }
                }
                iteration++;
              }
              return -1;
            };
            exports2.easingFunctions = {
              linear: function linear(t) {
                return t;
              },
              easeInQuad: function easeInQuad(t) {
                return t * t;
              },
              easeOutQuad: function easeOutQuad(t) {
                return t * (2 - t);
              },
              easeInOutQuad: function easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
              },
              easeInCubic: function easeInCubic(t) {
                return t * t * t;
              },
              easeOutCubic: function easeOutCubic(t) {
                return --t * t * t + 1;
              },
              easeInOutCubic: function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
              },
              easeInQuart: function easeInQuart(t) {
                return t * t * t * t;
              },
              easeOutQuart: function easeOutQuart(t) {
                return 1 - --t * t * t * t;
              },
              easeInOutQuart: function easeInOutQuart(t) {
                return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
              },
              easeInQuint: function easeInQuint(t) {
                return t * t * t * t * t;
              },
              easeOutQuint: function easeOutQuint(t) {
                return 1 + --t * t * t * t * t;
              },
              easeInOutQuint: function easeInOutQuint(t) {
                return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
              }
            };
            exports2.getScrollBarWidth = function() {
              var inner = document.createElement("p");
              inner.style.width = "100%";
              inner.style.height = "200px";
              var outer = document.createElement("div");
              outer.style.position = "absolute";
              outer.style.top = "0px";
              outer.style.left = "0px";
              outer.style.visibility = "hidden";
              outer.style.width = "200px";
              outer.style.height = "150px";
              outer.style.overflow = "hidden";
              outer.appendChild(inner);
              document.body.appendChild(outer);
              var w1 = inner.offsetWidth;
              outer.style.overflow = "scroll";
              var w2 = inner.offsetWidth;
              if (w1 == w2)
                w2 = outer.clientWidth;
              document.body.removeChild(outer);
              return w1 - w2;
            };
            exports2.topMost = function(pile, accessors) {
              var candidate = void 0;
              if (!Array.isArray(accessors)) {
                accessors = [accessors];
              }
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = void 0;
              try {
                for (var _iterator = (0, _getIterator3["default"])(pile), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var member = _step.value;
                  if (member) {
                    candidate = member[accessors[0]];
                    for (var i = 1; i < accessors.length; i++) {
                      if (candidate) {
                        candidate = candidate[accessors[i]];
                      }
                    }
                    if (typeof candidate != "undefined") {
                      break;
                    }
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
              return candidate;
            };
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(145), __esModule: true };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = function(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self2;
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _setPrototypeOf = __webpack_require__(147);
            var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
            var _create = __webpack_require__(31);
            var _create2 = _interopRequireDefault(_create);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = function(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
              }
              subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass)
                _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
            };
          },
          function(module2, exports2) {
            var core = module2.exports = { version: "2.6.2" };
            if (typeof __e == "number")
              __e = core;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _iterator = __webpack_require__(104);
            var _iterator2 = _interopRequireDefault(_iterator);
            var _symbol = __webpack_require__(106);
            var _symbol2 = _interopRequireDefault(_symbol);
            var _typeof2 = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
            };
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = typeof _symbol2.default === "function" && _typeof2(_iterator2.default) === "symbol" ? function(obj) {
              return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
            } : function(obj) {
              return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
            };
          },
          function(module2, exports2, __webpack_require__) {
            var store = __webpack_require__(44)("wks");
            var uid = __webpack_require__(29);
            var Symbol2 = __webpack_require__(10).Symbol;
            var USE_SYMBOL = typeof Symbol2 == "function";
            var $exports = module2.exports = function(name) {
              return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
            };
            $exports.store = store;
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(102), __esModule: true };
          },
          function(module2, exports2) {
            var global = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
            if (typeof __g == "number")
              __g = global;
          },
          function(module2, exports2, __webpack_require__) {
            var global = __webpack_require__(10);
            var core = __webpack_require__(6);
            var ctx = __webpack_require__(61);
            var hide3 = __webpack_require__(19);
            var has = __webpack_require__(14);
            var PROTOTYPE = "prototype";
            var $export = function(type, name, source) {
              var IS_FORCED = type & $export.F;
              var IS_GLOBAL = type & $export.G;
              var IS_STATIC = type & $export.S;
              var IS_PROTO = type & $export.P;
              var IS_BIND = type & $export.B;
              var IS_WRAP = type & $export.W;
              var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
              var expProto = exports3[PROTOTYPE];
              var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
              var key, own, out;
              if (IS_GLOBAL)
                source = name;
              for (key in source) {
                own = !IS_FORCED && target && target[key] !== void 0;
                if (own && has(exports3, key))
                  continue;
                out = own ? target[key] : source[key];
                exports3[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(C) {
                  var F = function(a, b, c) {
                    if (this instanceof C) {
                      switch (arguments.length) {
                        case 0:
                          return new C();
                        case 1:
                          return new C(a);
                        case 2:
                          return new C(a, b);
                      }
                      return new C(a, b, c);
                    }
                    return C.apply(this, arguments);
                  };
                  F[PROTOTYPE] = C[PROTOTYPE];
                  return F;
                }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                if (IS_PROTO) {
                  (exports3.virtual || (exports3.virtual = {}))[key] = out;
                  if (type & $export.R && expProto && !expProto[key])
                    hide3(expProto, key, out);
                }
              }
            };
            $export.F = 1;
            $export.G = 2;
            $export.S = 4;
            $export.P = 8;
            $export.B = 16;
            $export.W = 32;
            $export.U = 64;
            $export.R = 128;
            module2.exports = $export;
          },
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__(20);
            var IE8_DOM_DEFINE = __webpack_require__(62);
            var toPrimitive = __webpack_require__(40);
            var dP = Object.defineProperty;
            exports2.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return dP(O, P, Attributes);
                } catch (e) {
                }
              if ("get" in Attributes || "set" in Attributes)
                throw TypeError("Accessors not supported!");
              if ("value" in Attributes)
                O[P] = Attributes.value;
              return O;
            };
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = !__webpack_require__(22)(function() {
              return Object.defineProperty({}, "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          },
          function(module2, exports2) {
            var hasOwnProperty = {}.hasOwnProperty;
            module2.exports = function(it, key) {
              return hasOwnProperty.call(it, key);
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isIterable2 = __webpack_require__(136);
            var _isIterable3 = _interopRequireDefault(_isIterable2);
            var _getIterator2 = __webpack_require__(58);
            var _getIterator3 = _interopRequireDefault(_getIterator2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if ((0, _isIterable3.default)(Object(arr))) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var NodeBase = function() {
              function NodeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, NodeBase2);
                this.body = body;
                this.labelModule = labelModule;
                this.setOptions(options);
                this.top = void 0;
                this.left = void 0;
                this.height = void 0;
                this.width = void 0;
                this.radius = void 0;
                this.margin = void 0;
                this.refreshNeeded = true;
                this.boundingBox = { top: 0, left: 0, right: 0, bottom: 0 };
              }
              (0, _createClass3["default"])(NodeBase2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
              }, {
                key: "_setMargins",
                value: function _setMargins(labelModule) {
                  this.margin = {};
                  if (this.options.margin) {
                    if ((0, _typeof3["default"])(this.options.margin) == "object") {
                      this.margin.top = this.options.margin.top;
                      this.margin.right = this.options.margin.right;
                      this.margin.bottom = this.options.margin.bottom;
                      this.margin.left = this.options.margin.left;
                    } else {
                      this.margin.top = this.options.margin;
                      this.margin.right = this.options.margin;
                      this.margin.bottom = this.options.margin;
                      this.margin.left = this.options.margin;
                    }
                  }
                  labelModule.adjustSizes(this.margin);
                }
              }, {
                key: "_distanceToBorder",
                value: function _distanceToBorder(ctx, angle) {
                  var borderWidth = this.options.borderWidth;
                  this.resize(ctx);
                  return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
                }
              }, {
                key: "enableShadow",
                value: function enableShadow(ctx, values) {
                  if (values.shadow) {
                    ctx.shadowColor = values.shadowColor;
                    ctx.shadowBlur = values.shadowSize;
                    ctx.shadowOffsetX = values.shadowX;
                    ctx.shadowOffsetY = values.shadowY;
                  }
                }
              }, {
                key: "disableShadow",
                value: function disableShadow(ctx, values) {
                  if (values.shadow) {
                    ctx.shadowColor = "rgba(0,0,0,0)";
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                  }
                }
              }, {
                key: "enableBorderDashes",
                value: function enableBorderDashes(ctx, values) {
                  if (values.borderDashes !== false) {
                    if (ctx.setLineDash !== void 0) {
                      var dashes = values.borderDashes;
                      if (dashes === true) {
                        dashes = [5, 15];
                      }
                      ctx.setLineDash(dashes);
                    } else {
                      console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
                      this.options.shapeProperties.borderDashes = false;
                      values.borderDashes = false;
                    }
                  }
                }
              }, {
                key: "disableBorderDashes",
                value: function disableBorderDashes(ctx, values) {
                  if (values.borderDashes !== false) {
                    if (ctx.setLineDash !== void 0) {
                      ctx.setLineDash([0]);
                    } else {
                      console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
                      this.options.shapeProperties.borderDashes = false;
                      values.borderDashes = false;
                    }
                  }
                }
              }, {
                key: "needsRefresh",
                value: function needsRefresh(selected, hover) {
                  if (this.refreshNeeded === true) {
                    this.refreshNeeded = false;
                    return true;
                  }
                  return this.width === void 0 || this.labelModule.differentState(selected, hover);
                }
              }, {
                key: "initContextForDraw",
                value: function initContextForDraw(ctx, values) {
                  var borderWidth = values.borderWidth / this.body.view.scale;
                  ctx.lineWidth = Math.min(this.width, borderWidth);
                  ctx.strokeStyle = values.borderColor;
                  ctx.fillStyle = values.color;
                }
              }, {
                key: "performStroke",
                value: function performStroke(ctx, values) {
                  var borderWidth = values.borderWidth / this.body.view.scale;
                  ctx.save();
                  if (borderWidth > 0) {
                    this.enableBorderDashes(ctx, values);
                    ctx.stroke();
                    this.disableBorderDashes(ctx, values);
                  }
                  ctx.restore();
                }
              }, {
                key: "performFill",
                value: function performFill(ctx, values) {
                  this.enableShadow(ctx, values);
                  ctx.fill();
                  this.disableShadow(ctx, values);
                  this.performStroke(ctx, values);
                }
              }, {
                key: "_addBoundingBoxMargin",
                value: function _addBoundingBoxMargin(margin) {
                  this.boundingBox.left -= margin;
                  this.boundingBox.top -= margin;
                  this.boundingBox.bottom += margin;
                  this.boundingBox.right += margin;
                }
              }, {
                key: "_updateBoundingBox",
                value: function _updateBoundingBox(x, y, ctx, selected, hover) {
                  if (ctx !== void 0) {
                    this.resize(ctx, selected, hover);
                  }
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.boundingBox.left = this.left;
                  this.boundingBox.top = this.top;
                  this.boundingBox.bottom = this.top + this.height;
                  this.boundingBox.right = this.left + this.width;
                }
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y, ctx, selected, hover) {
                  this._updateBoundingBox(x, y, ctx, selected, hover);
                }
              }, {
                key: "getDimensionsFromLabel",
                value: function getDimensionsFromLabel(ctx, selected, hover) {
                  this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
                  var width = this.textSize.width;
                  var height = this.textSize.height;
                  var DEFAULT_SIZE = 14;
                  if (width === 0) {
                    width = DEFAULT_SIZE;
                    height = DEFAULT_SIZE;
                  }
                  return { width, height };
                }
              }]);
              return NodeBase2;
            }();
            exports2["default"] = NodeBase;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(16);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var ShapeBase = function(_NodeBase) {
              (0, _inherits3["default"])(ShapeBase2, _NodeBase);
              function ShapeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, ShapeBase2);
                return (0, _possibleConstructorReturn3["default"])(this, (ShapeBase2.__proto__ || (0, _getPrototypeOf2["default"])(ShapeBase2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(ShapeBase2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  var values = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : { size: this.options.size };
                  if (this.needsRefresh(selected, hover)) {
                    this.labelModule.getTextSize(ctx, selected, hover);
                    var size = 2 * values.size;
                    this.width = size;
                    this.height = size;
                    this.radius = 0.5 * this.width;
                  }
                }
              }, {
                key: "_drawShape",
                value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover, values);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.initContextForDraw(ctx, values);
                  ctx[shape](x, y, values.size);
                  this.performFill(ctx, values);
                  if (this.options.icon !== void 0) {
                    if (this.options.icon.code !== void 0) {
                      ctx.font = (selected ? "bold " : "") + this.height / 2 + "px " + (this.options.icon.face || "FontAwesome");
                      ctx.fillStyle = this.options.icon.color || "black";
                      ctx.textAlign = "center";
                      ctx.textBaseline = "middle";
                      ctx.fillText(this.options.icon.code, x, y);
                    }
                  }
                  if (this.options.label !== void 0) {
                    this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, "hanging");
                    var yLabel = y + 0.5 * this.height + 0.5 * this.labelModule.size.height;
                    this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
                  }
                  this.updateBoundingBox(x, y);
                }
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.boundingBox.top = y - this.options.size;
                  this.boundingBox.left = x - this.options.size;
                  this.boundingBox.right = x + this.options.size;
                  this.boundingBox.bottom = y + this.options.size;
                  if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
                    this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
                    this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
                    this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);
                  }
                }
              }]);
              return ShapeBase2;
            }(_NodeBase3["default"]);
            exports2["default"] = ShapeBase;
          },
          function(module2, exports2, __webpack_require__) {
            var IObject = __webpack_require__(59);
            var defined = __webpack_require__(39);
            module2.exports = function(it) {
              return IObject(defined(it));
            };
          },
          function(module2, exports2, __webpack_require__) {
            var dP = __webpack_require__(12);
            var createDesc = __webpack_require__(28);
            module2.exports = __webpack_require__(13) ? function(object, key, value) {
              return dP.f(object, key, createDesc(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__(21);
            module2.exports = function(it) {
              if (!isObject2(it))
                throw TypeError(it + " is not an object!");
              return it;
            };
          },
          function(module2, exports2) {
            module2.exports = function(it) {
              return typeof it === "object" ? it !== null : typeof it === "function";
            };
          },
          function(module2, exports2) {
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (e) {
                return true;
              }
            };
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(123), __esModule: true };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function hammerMock() {
              var noop = function noop2() {
              };
              return {
                on: noop,
                off: noop,
                destroy: noop,
                emit: noop,
                get: function get3(m) {
                  return {
                    set: noop
                  };
                }
              };
            }
            if (typeof window !== "undefined") {
              var propagating = __webpack_require__(127);
              var Hammer = window["Hammer"] || __webpack_require__(128);
              module2.exports = propagating(Hammer, {
                preventDefault: "mouse"
              });
            } else {
              module2.exports = function() {
                return hammerMock();
              };
            }
          },
          function(module2, exports2) {
            module2.exports = {};
          },
          function(module2, exports2, __webpack_require__) {
            var $keys = __webpack_require__(65);
            var enumBugKeys = __webpack_require__(45);
            module2.exports = Object.keys || function keys(O) {
              return $keys(O, enumBugKeys);
            };
          },
          function(module2, exports2) {
            module2.exports = true;
          },
          function(module2, exports2) {
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          function(module2, exports2) {
            var id2 = 0;
            var px = Math.random();
            module2.exports = function(key) {
              return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id2 + px).toString(36));
            };
          },
          function(module2, exports2, __webpack_require__) {
            var defined = __webpack_require__(39);
            module2.exports = function(it) {
              return Object(defined(it));
            };
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(100), __esModule: true };
          },
          function(module2, exports2) {
            exports2.f = {}.propertyIsEnumerable;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _stringify = __webpack_require__(23);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _keys = __webpack_require__(9);
            var _keys2 = _interopRequireDefault(_keys);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Queue = __webpack_require__(72);
            function DataSet2(data, options) {
              if (data && !Array.isArray(data)) {
                options = data;
                data = null;
              }
              this._options = options || {};
              this._data = {};
              this.length = 0;
              this._fieldId = this._options.fieldId || "id";
              this._type = {};
              if (this._options.type) {
                var fields = (0, _keys2["default"])(this._options.type);
                for (var i = 0, len = fields.length; i < len; i++) {
                  var field = fields[i];
                  var value = this._options.type[field];
                  if (value == "Date" || value == "ISODate" || value == "ASPDate") {
                    this._type[field] = "Date";
                  } else {
                    this._type[field] = value;
                  }
                }
              }
              this._subscribers = {};
              if (data) {
                this.add(data);
              }
              this.setOptions(options);
            }
            DataSet2.prototype.setOptions = function(options) {
              if (options && options.queue !== void 0) {
                if (options.queue === false) {
                  if (this._queue) {
                    this._queue.destroy();
                    delete this._queue;
                  }
                } else {
                  if (!this._queue) {
                    this._queue = Queue.extend(this, {
                      replace: ["add", "update", "remove"]
                    });
                  }
                  if ((0, _typeof3["default"])(options.queue) === "object") {
                    this._queue.setOptions(options.queue);
                  }
                }
              }
            };
            DataSet2.prototype.on = function(event, callback) {
              var subscribers = this._subscribers[event];
              if (!subscribers) {
                subscribers = [];
                this._subscribers[event] = subscribers;
              }
              subscribers.push({
                callback
              });
            };
            DataSet2.prototype.off = function(event, callback) {
              var subscribers = this._subscribers[event];
              if (subscribers) {
                this._subscribers[event] = subscribers.filter(function(listener) {
                  return listener.callback != callback;
                });
              }
            };
            DataSet2.prototype._trigger = function(event, params, senderId) {
              if (event == "*") {
                throw new Error("Cannot trigger event *");
              }
              var subscribers = [];
              if (event in this._subscribers) {
                subscribers = subscribers.concat(this._subscribers[event]);
              }
              if ("*" in this._subscribers) {
                subscribers = subscribers.concat(this._subscribers["*"]);
              }
              for (var i = 0, len = subscribers.length; i < len; i++) {
                var subscriber = subscribers[i];
                if (subscriber.callback) {
                  subscriber.callback(event, params, senderId || null);
                }
              }
            };
            DataSet2.prototype.add = function(data, senderId) {
              var addedIds = [], id2, me = this;
              if (Array.isArray(data)) {
                for (var i = 0, len = data.length; i < len; i++) {
                  id2 = me._addItem(data[i]);
                  addedIds.push(id2);
                }
              } else if (data && (typeof data === "undefined" ? "undefined" : (0, _typeof3["default"])(data)) === "object") {
                id2 = me._addItem(data);
                addedIds.push(id2);
              } else {
                throw new Error("Unknown dataType");
              }
              if (addedIds.length) {
                this._trigger("add", { items: addedIds }, senderId);
              }
              return addedIds;
            };
            DataSet2.prototype.update = function(data, senderId) {
              var addedIds = [];
              var updatedIds = [];
              var oldData = [];
              var updatedData = [];
              var me = this;
              var fieldId = me._fieldId;
              var addOrUpdate = function addOrUpdate2(item) {
                var id2 = item[fieldId];
                if (me._data[id2]) {
                  var oldItem = util.extend({}, me._data[id2]);
                  id2 = me._updateItem(item);
                  updatedIds.push(id2);
                  updatedData.push(item);
                  oldData.push(oldItem);
                } else {
                  id2 = me._addItem(item);
                  addedIds.push(id2);
                }
              };
              if (Array.isArray(data)) {
                for (var i = 0, len = data.length; i < len; i++) {
                  if (data[i] && (0, _typeof3["default"])(data[i]) === "object") {
                    addOrUpdate(data[i]);
                  } else {
                    console.warn("Ignoring input item, which is not an object at index " + i);
                  }
                }
              } else if (data && (typeof data === "undefined" ? "undefined" : (0, _typeof3["default"])(data)) === "object") {
                addOrUpdate(data);
              } else {
                throw new Error("Unknown dataType");
              }
              if (addedIds.length) {
                this._trigger("add", { items: addedIds }, senderId);
              }
              if (updatedIds.length) {
                var props = {
                  items: updatedIds,
                  oldData,
                  data: updatedData
                };
                this._trigger("update", props, senderId);
              }
              return addedIds.concat(updatedIds);
            };
            DataSet2.prototype.get = function(args) {
              var me = this;
              var id2, ids, options;
              var firstType = util.getType(arguments[0]);
              if (firstType == "String" || firstType == "Number") {
                id2 = arguments[0];
                options = arguments[1];
              } else if (firstType == "Array") {
                ids = arguments[0];
                options = arguments[1];
              } else {
                options = arguments[0];
              }
              var returnType;
              if (options && options.returnType) {
                var allowedValues = ["Array", "Object"];
                returnType = allowedValues.indexOf(options.returnType) == -1 ? "Array" : options.returnType;
              } else {
                returnType = "Array";
              }
              var type = options && options.type || this._options.type;
              var filter = options && options.filter;
              var items = [], item, itemIds, itemId, i, len;
              if (id2 != void 0) {
                item = me._getItem(id2, type);
                if (item && filter && !filter(item)) {
                  item = null;
                }
              } else if (ids != void 0) {
                for (i = 0, len = ids.length; i < len; i++) {
                  item = me._getItem(ids[i], type);
                  if (!filter || filter(item)) {
                    items.push(item);
                  }
                }
              } else {
                itemIds = (0, _keys2["default"])(this._data);
                for (i = 0, len = itemIds.length; i < len; i++) {
                  itemId = itemIds[i];
                  item = me._getItem(itemId, type);
                  if (!filter || filter(item)) {
                    items.push(item);
                  }
                }
              }
              if (options && options.order && id2 == void 0) {
                this._sort(items, options.order);
              }
              if (options && options.fields) {
                var fields = options.fields;
                if (id2 != void 0) {
                  item = this._filterFields(item, fields);
                } else {
                  for (i = 0, len = items.length; i < len; i++) {
                    items[i] = this._filterFields(items[i], fields);
                  }
                }
              }
              if (returnType == "Object") {
                var result2 = {}, resultant;
                for (i = 0, len = items.length; i < len; i++) {
                  resultant = items[i];
                  result2[resultant.id] = resultant;
                }
                return result2;
              } else {
                if (id2 != void 0) {
                  return item;
                } else {
                  return items;
                }
              }
            };
            DataSet2.prototype.getIds = function(options) {
              var data = this._data, filter = options && options.filter, order = options && options.order, type = options && options.type || this._options.type, itemIds = (0, _keys2["default"])(data), i, len, id2, item, items, ids = [];
              if (filter) {
                if (order) {
                  items = [];
                  for (i = 0, len = itemIds.length; i < len; i++) {
                    id2 = itemIds[i];
                    item = this._getItem(id2, type);
                    if (filter(item)) {
                      items.push(item);
                    }
                  }
                  this._sort(items, order);
                  for (i = 0, len = items.length; i < len; i++) {
                    ids.push(items[i][this._fieldId]);
                  }
                } else {
                  for (i = 0, len = itemIds.length; i < len; i++) {
                    id2 = itemIds[i];
                    item = this._getItem(id2, type);
                    if (filter(item)) {
                      ids.push(item[this._fieldId]);
                    }
                  }
                }
              } else {
                if (order) {
                  items = [];
                  for (i = 0, len = itemIds.length; i < len; i++) {
                    id2 = itemIds[i];
                    items.push(data[id2]);
                  }
                  this._sort(items, order);
                  for (i = 0, len = items.length; i < len; i++) {
                    ids.push(items[i][this._fieldId]);
                  }
                } else {
                  for (i = 0, len = itemIds.length; i < len; i++) {
                    id2 = itemIds[i];
                    item = data[id2];
                    ids.push(item[this._fieldId]);
                  }
                }
              }
              return ids;
            };
            DataSet2.prototype.getDataSet = function() {
              return this;
            };
            DataSet2.prototype.forEach = function(callback, options) {
              var filter = options && options.filter, type = options && options.type || this._options.type, data = this._data, itemIds = (0, _keys2["default"])(data), i, len, item, id2;
              if (options && options.order) {
                var items = this.get(options);
                for (i = 0, len = items.length; i < len; i++) {
                  item = items[i];
                  id2 = item[this._fieldId];
                  callback(item, id2);
                }
              } else {
                for (i = 0, len = itemIds.length; i < len; i++) {
                  id2 = itemIds[i];
                  item = this._getItem(id2, type);
                  if (!filter || filter(item)) {
                    callback(item, id2);
                  }
                }
              }
            };
            DataSet2.prototype.map = function(callback, options) {
              var filter = options && options.filter, type = options && options.type || this._options.type, mappedItems = [], data = this._data, itemIds = (0, _keys2["default"])(data), i, len, id2, item;
              for (i = 0, len = itemIds.length; i < len; i++) {
                id2 = itemIds[i];
                item = this._getItem(id2, type);
                if (!filter || filter(item)) {
                  mappedItems.push(callback(item, id2));
                }
              }
              if (options && options.order) {
                this._sort(mappedItems, options.order);
              }
              return mappedItems;
            };
            DataSet2.prototype._filterFields = function(item, fields) {
              if (!item) {
                return item;
              }
              var filteredItem = {}, itemFields = (0, _keys2["default"])(item), len = itemFields.length, i, field;
              if (Array.isArray(fields)) {
                for (i = 0; i < len; i++) {
                  field = itemFields[i];
                  if (fields.indexOf(field) != -1) {
                    filteredItem[field] = item[field];
                  }
                }
              } else {
                for (i = 0; i < len; i++) {
                  field = itemFields[i];
                  if (fields.hasOwnProperty(field)) {
                    filteredItem[fields[field]] = item[field];
                  }
                }
              }
              return filteredItem;
            };
            DataSet2.prototype._sort = function(items, order) {
              if (util.isString(order)) {
                var name = order;
                items.sort(function(a, b) {
                  var av = a[name];
                  var bv = b[name];
                  return av > bv ? 1 : av < bv ? -1 : 0;
                });
              } else if (typeof order === "function") {
                items.sort(order);
              } else {
                throw new TypeError("Order must be a function or a string");
              }
            };
            DataSet2.prototype.remove = function(id2, senderId) {
              var removedIds = [], removedItems = [], ids = [], i, len, itemId, item;
              ids = Array.isArray(id2) ? id2 : [id2];
              for (i = 0, len = ids.length; i < len; i++) {
                item = this._remove(ids[i]);
                if (item) {
                  itemId = item[this._fieldId];
                  if (itemId != void 0) {
                    removedIds.push(itemId);
                    removedItems.push(item);
                  }
                }
              }
              if (removedIds.length) {
                this._trigger("remove", { items: removedIds, oldData: removedItems }, senderId);
              }
              return removedIds;
            };
            DataSet2.prototype._remove = function(id2) {
              var item, ident;
              if (util.isNumber(id2) || util.isString(id2)) {
                ident = id2;
              } else if (id2 && (typeof id2 === "undefined" ? "undefined" : (0, _typeof3["default"])(id2)) === "object") {
                ident = id2[this._fieldId];
              }
              if (ident !== void 0 && this._data[ident]) {
                item = this._data[ident];
                delete this._data[ident];
                this.length--;
                return item;
              }
              return null;
            };
            DataSet2.prototype.clear = function(senderId) {
              var i, len;
              var ids = (0, _keys2["default"])(this._data);
              var items = [];
              for (i = 0, len = ids.length; i < len; i++) {
                items.push(this._data[ids[i]]);
              }
              this._data = {};
              this.length = 0;
              this._trigger("remove", { items: ids, oldData: items }, senderId);
              return ids;
            };
            DataSet2.prototype.max = function(field) {
              var data = this._data, itemIds = (0, _keys2["default"])(data), max = null, maxField = null, i, len;
              for (i = 0, len = itemIds.length; i < len; i++) {
                var id2 = itemIds[i];
                var item = data[id2];
                var itemField = item[field];
                if (itemField != null && (!max || itemField > maxField)) {
                  max = item;
                  maxField = itemField;
                }
              }
              return max;
            };
            DataSet2.prototype.min = function(field) {
              var data = this._data, itemIds = (0, _keys2["default"])(data), min = null, minField = null, i, len;
              for (i = 0, len = itemIds.length; i < len; i++) {
                var id2 = itemIds[i];
                var item = data[id2];
                var itemField = item[field];
                if (itemField != null && (!min || itemField < minField)) {
                  min = item;
                  minField = itemField;
                }
              }
              return min;
            };
            DataSet2.prototype.distinct = function(field) {
              var data = this._data;
              var itemIds = (0, _keys2["default"])(data);
              var values = [];
              var fieldType = this._options.type && this._options.type[field] || null;
              var count = 0;
              var i, j, len;
              for (i = 0, len = itemIds.length; i < len; i++) {
                var id2 = itemIds[i];
                var item = data[id2];
                var value = item[field];
                var exists = false;
                for (j = 0; j < count; j++) {
                  if (values[j] == value) {
                    exists = true;
                    break;
                  }
                }
                if (!exists && value !== void 0) {
                  values[count] = value;
                  count++;
                }
              }
              if (fieldType) {
                for (i = 0, len = values.length; i < len; i++) {
                  values[i] = util.convert(values[i], fieldType);
                }
              }
              return values;
            };
            DataSet2.prototype._addItem = function(item) {
              var id2 = item[this._fieldId];
              if (id2 != void 0) {
                if (this._data[id2]) {
                  throw new Error("Cannot add item: item with id " + id2 + " already exists");
                }
              } else {
                id2 = util.randomUUID();
                item[this._fieldId] = id2;
              }
              var d = {}, fields = (0, _keys2["default"])(item), i, len;
              for (i = 0, len = fields.length; i < len; i++) {
                var field = fields[i];
                var fieldType = this._type[field];
                d[field] = util.convert(item[field], fieldType);
              }
              this._data[id2] = d;
              this.length++;
              return id2;
            };
            DataSet2.prototype._getItem = function(id2, types) {
              var field, value, i, len;
              var raw = this._data[id2];
              if (!raw) {
                return null;
              }
              var converted = {}, fields = (0, _keys2["default"])(raw);
              if (types) {
                for (i = 0, len = fields.length; i < len; i++) {
                  field = fields[i];
                  value = raw[field];
                  converted[field] = util.convert(value, types[field]);
                }
              } else {
                for (i = 0, len = fields.length; i < len; i++) {
                  field = fields[i];
                  value = raw[field];
                  converted[field] = value;
                }
              }
              if (!converted[this._fieldId]) {
                converted[this._fieldId] = raw.id;
              }
              return converted;
            };
            DataSet2.prototype._updateItem = function(item) {
              var id2 = item[this._fieldId];
              if (id2 == void 0) {
                throw new Error("Cannot update item: item has no id (item: " + (0, _stringify2["default"])(item) + ")");
              }
              var d = this._data[id2];
              if (!d) {
                throw new Error("Cannot update item: no item with id " + id2 + " found");
              }
              var fields = (0, _keys2["default"])(item);
              for (var i = 0, len = fields.length; i < len; i++) {
                var field = fields[i];
                var fieldType = this._type[field];
                d[field] = util.convert(item[field], fieldType);
              }
              return id2;
            };
            module2.exports = DataSet2;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Label = __webpack_require__(77)["default"];
            var ComponentUtil = __webpack_require__(35)["default"];
            var Box = __webpack_require__(144)["default"];
            var Circle = __webpack_require__(151)["default"];
            var CircularImage = __webpack_require__(152)["default"];
            var Database = __webpack_require__(153)["default"];
            var Diamond = __webpack_require__(154)["default"];
            var Dot = __webpack_require__(155)["default"];
            var Ellipse = __webpack_require__(156)["default"];
            var Icon = __webpack_require__(157)["default"];
            var Image2 = __webpack_require__(158)["default"];
            var Square = __webpack_require__(159)["default"];
            var Hexagon = __webpack_require__(160)["default"];
            var Star = __webpack_require__(161)["default"];
            var Text = __webpack_require__(162)["default"];
            var Triangle = __webpack_require__(163)["default"];
            var TriangleDown = __webpack_require__(164)["default"];
            var _require = __webpack_require__(54), printStyle = _require.printStyle;
            var Node = function() {
              function Node2(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
                (0, _classCallCheck3["default"])(this, Node2);
                this.options = util.bridgeObject(globalOptions);
                this.globalOptions = globalOptions;
                this.defaultOptions = defaultOptions;
                this.body = body;
                this.edges = [];
                this.id = void 0;
                this.imagelist = imagelist;
                this.grouplist = grouplist;
                this.x = void 0;
                this.y = void 0;
                this.baseSize = this.options.size;
                this.baseFontSize = this.options.font.size;
                this.predefinedPosition = false;
                this.selected = false;
                this.hover = false;
                this.labelModule = new Label(
                  this.body,
                  this.options,
                  false
                );
                this.setOptions(options);
              }
              (0, _createClass3["default"])(Node2, [{
                key: "attachEdge",
                value: function attachEdge(edge) {
                  if (this.edges.indexOf(edge) === -1) {
                    this.edges.push(edge);
                  }
                }
              }, {
                key: "detachEdge",
                value: function detachEdge(edge) {
                  var index = this.edges.indexOf(edge);
                  if (index != -1) {
                    this.edges.splice(index, 1);
                  }
                }
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  var currentShape = this.options.shape;
                  if (!options) {
                    return;
                  }
                  if (options.id !== void 0) {
                    this.id = options.id;
                  }
                  if (this.id === void 0) {
                    throw new Error("Node must have an id");
                  }
                  Node2.checkMass(options, this.id);
                  if (options.x !== void 0) {
                    if (options.x === null) {
                      this.x = void 0;
                      this.predefinedPosition = false;
                    } else {
                      this.x = parseInt(options.x);
                      this.predefinedPosition = true;
                    }
                  }
                  if (options.y !== void 0) {
                    if (options.y === null) {
                      this.y = void 0;
                      this.predefinedPosition = false;
                    } else {
                      this.y = parseInt(options.y);
                      this.predefinedPosition = true;
                    }
                  }
                  if (options.size !== void 0) {
                    this.baseSize = options.size;
                  }
                  if (options.value !== void 0) {
                    options.value = parseFloat(options.value);
                  }
                  Node2.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);
                  var pile = [options, this.options, this.defaultOptions];
                  this.chooser = ComponentUtil.choosify("node", pile);
                  this._load_images();
                  this.updateLabelModule(options);
                  this.updateShape(currentShape);
                  return options.hidden !== void 0 || options.physics !== void 0;
                }
              }, {
                key: "_load_images",
                value: function _load_images() {
                  if (this.options.shape === "circularImage" || this.options.shape === "image") {
                    if (this.options.image === void 0) {
                      throw new Error("Option image must be defined for node type '" + this.options.shape + "'");
                    }
                  }
                  if (this.options.image === void 0) {
                    return;
                  }
                  if (this.imagelist === void 0) {
                    throw new Error("Internal Error: No images provided");
                  }
                  if (typeof this.options.image === "string") {
                    this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
                  } else {
                    if (this.options.image.unselected === void 0) {
                      throw new Error("No unselected image provided");
                    }
                    this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);
                    if (this.options.image.selected !== void 0) {
                      this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);
                    } else {
                      this.imageObjAlt = void 0;
                    }
                  }
                }
              }, {
                key: "getFormattingValues",
                value: function getFormattingValues() {
                  var values = {
                    color: this.options.color.background,
                    borderWidth: this.options.borderWidth,
                    borderColor: this.options.color.border,
                    size: this.options.size,
                    borderDashes: this.options.shapeProperties.borderDashes,
                    borderRadius: this.options.shapeProperties.borderRadius,
                    shadow: this.options.shadow.enabled,
                    shadowColor: this.options.shadow.color,
                    shadowSize: this.options.shadow.size,
                    shadowX: this.options.shadow.x,
                    shadowY: this.options.shadow.y
                  };
                  if (this.selected || this.hover) {
                    if (this.chooser === true) {
                      if (this.selected) {
                        values.borderWidth *= 2;
                        values.color = this.options.color.highlight.background;
                        values.borderColor = this.options.color.highlight.border;
                        values.shadow = this.options.shadow.enabled;
                      } else if (this.hover) {
                        values.color = this.options.color.hover.background;
                        values.borderColor = this.options.color.hover.border;
                        values.shadow = this.options.shadow.enabled;
                      }
                    } else if (typeof this.chooser === "function") {
                      this.chooser(values, this.options.id, this.selected, this.hover);
                      if (values.shadow === false) {
                        if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
                          values.shadow = true;
                        }
                      }
                    }
                  } else {
                    values.shadow = this.options.shadow.enabled;
                  }
                  return values;
                }
              }, {
                key: "updateLabelModule",
                value: function updateLabelModule(options) {
                  if (this.options.label === void 0 || this.options.label === null) {
                    this.options.label = "";
                  }
                  Node2.updateGroupOptions(this.options, options, this.grouplist);
                  var currentGroup = this.grouplist.get(this.options.group, false);
                  var pile = [
                    options,
                    this.options,
                    currentGroup,
                    this.globalOptions,
                    this.defaultOptions
                  ];
                  this.labelModule.update(this.options, pile);
                  if (this.labelModule.baseSize !== void 0) {
                    this.baseFontSize = this.labelModule.baseSize;
                  }
                }
              }, {
                key: "updateShape",
                value: function updateShape(currentShape) {
                  if (currentShape === this.options.shape && this.shape) {
                    this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);
                  } else {
                    switch (this.options.shape) {
                      case "box":
                        this.shape = new Box(this.options, this.body, this.labelModule);
                        break;
                      case "circle":
                        this.shape = new Circle(this.options, this.body, this.labelModule);
                        break;
                      case "circularImage":
                        this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
                        break;
                      case "database":
                        this.shape = new Database(this.options, this.body, this.labelModule);
                        break;
                      case "diamond":
                        this.shape = new Diamond(this.options, this.body, this.labelModule);
                        break;
                      case "dot":
                        this.shape = new Dot(this.options, this.body, this.labelModule);
                        break;
                      case "ellipse":
                        this.shape = new Ellipse(this.options, this.body, this.labelModule);
                        break;
                      case "icon":
                        this.shape = new Icon(this.options, this.body, this.labelModule);
                        break;
                      case "image":
                        this.shape = new Image2(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
                        break;
                      case "square":
                        this.shape = new Square(this.options, this.body, this.labelModule);
                        break;
                      case "hexagon":
                        this.shape = new Hexagon(this.options, this.body, this.labelModule);
                        break;
                      case "star":
                        this.shape = new Star(this.options, this.body, this.labelModule);
                        break;
                      case "text":
                        this.shape = new Text(this.options, this.body, this.labelModule);
                        break;
                      case "triangle":
                        this.shape = new Triangle(this.options, this.body, this.labelModule);
                        break;
                      case "triangleDown":
                        this.shape = new TriangleDown(this.options, this.body, this.labelModule);
                        break;
                      default:
                        this.shape = new Ellipse(this.options, this.body, this.labelModule);
                        break;
                    }
                  }
                  this.needsRefresh();
                }
              }, {
                key: "select",
                value: function select() {
                  this.selected = true;
                  this.needsRefresh();
                }
              }, {
                key: "unselect",
                value: function unselect() {
                  this.selected = false;
                  this.needsRefresh();
                }
              }, {
                key: "needsRefresh",
                value: function needsRefresh() {
                  this.shape.refreshNeeded = true;
                }
              }, {
                key: "getTitle",
                value: function getTitle() {
                  return this.options.title;
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this.shape.distanceToBorder(ctx, angle);
                }
              }, {
                key: "isFixed",
                value: function isFixed() {
                  return this.options.fixed.x && this.options.fixed.y;
                }
              }, {
                key: "isSelected",
                value: function isSelected() {
                  return this.selected;
                }
              }, {
                key: "getValue",
                value: function getValue() {
                  return this.options.value;
                }
              }, {
                key: "getLabelSize",
                value: function getLabelSize() {
                  return this.labelModule.size();
                }
              }, {
                key: "setValueRange",
                value: function setValueRange(min, max, total) {
                  if (this.options.value !== void 0) {
                    var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
                    var sizeDiff = this.options.scaling.max - this.options.scaling.min;
                    if (this.options.scaling.label.enabled === true) {
                      var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
                      this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
                    }
                    this.options.size = this.options.scaling.min + scale * sizeDiff;
                  } else {
                    this.options.size = this.baseSize;
                    this.options.font.size = this.baseFontSize;
                  }
                  this.updateLabelModule();
                }
              }, {
                key: "draw",
                value: function draw(ctx) {
                  var values = this.getFormattingValues();
                  this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values);
                }
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(ctx) {
                  this.shape.updateBoundingBox(this.x, this.y, ctx);
                }
              }, {
                key: "resize",
                value: function resize(ctx) {
                  var values = this.getFormattingValues();
                  this.shape.resize(ctx, this.selected, this.hover, values);
                }
              }, {
                key: "getItemsOnPoint",
                value: function getItemsOnPoint(point) {
                  var ret = [];
                  if (this.labelModule.visible()) {
                    if (ComponentUtil.pointInRect(this.labelModule.getSize(), point)) {
                      ret.push({ nodeId: this.id, labelId: 0 });
                    }
                  }
                  if (ComponentUtil.pointInRect(this.shape.boundingBox, point)) {
                    ret.push({ nodeId: this.id });
                  }
                  return ret;
                }
              }, {
                key: "isOverlappingWith",
                value: function isOverlappingWith(obj) {
                  return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
                }
              }, {
                key: "isBoundingBoxOverlappingWith",
                value: function isBoundingBoxOverlappingWith(obj) {
                  return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
                }
              }], [{
                key: "updateGroupOptions",
                value: function updateGroupOptions(parentOptions, newOptions, groupList) {
                  if (groupList === void 0)
                    return;
                  var group = parentOptions.group;
                  if (newOptions !== void 0 && newOptions.group !== void 0 && group !== newOptions.group) {
                    throw new Error("updateGroupOptions: group values in options don't match.");
                  }
                  var hasGroup = typeof group === "number" || typeof group === "string" && group != "";
                  if (!hasGroup)
                    return;
                  var groupObj = groupList.get(group);
                  var skipProperties = ["font"];
                  if (newOptions !== void 0 && newOptions.color !== void 0 && newOptions.color != null)
                    skipProperties.push("color");
                  util.selectiveNotDeepExtend(skipProperties, parentOptions, groupObj);
                  parentOptions.color = util.parseColor(parentOptions.color);
                }
              }, {
                key: "parseOptions",
                value: function parseOptions(parentOptions, newOptions) {
                  var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                  var groupList = arguments[4];
                  var fields = ["color", "fixed", "shadow"];
                  util.selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);
                  Node2.checkMass(newOptions);
                  util.mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
                  if (newOptions.color !== void 0 && newOptions.color !== null) {
                    var parsedColor = util.parseColor(newOptions.color);
                    util.fillIfDefined(parentOptions.color, parsedColor);
                  } else if (allowDeletion === true && newOptions.color === null) {
                    parentOptions.color = util.bridgeObject(globalOptions.color);
                  }
                  if (newOptions.fixed !== void 0 && newOptions.fixed !== null) {
                    if (typeof newOptions.fixed === "boolean") {
                      parentOptions.fixed.x = newOptions.fixed;
                      parentOptions.fixed.y = newOptions.fixed;
                    } else {
                      if (newOptions.fixed.x !== void 0 && typeof newOptions.fixed.x === "boolean") {
                        parentOptions.fixed.x = newOptions.fixed.x;
                      }
                      if (newOptions.fixed.y !== void 0 && typeof newOptions.fixed.y === "boolean") {
                        parentOptions.fixed.y = newOptions.fixed.y;
                      }
                    }
                  }
                  if (allowDeletion === true && newOptions.font === null) {
                    parentOptions.font = util.bridgeObject(globalOptions.font);
                  }
                  Node2.updateGroupOptions(parentOptions, newOptions, groupList);
                  if (newOptions.scaling !== void 0) {
                    util.mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
                  }
                }
              }, {
                key: "checkMass",
                value: function checkMass(options, id2) {
                  if (options.mass !== void 0 && options.mass <= 0) {
                    var strId = "";
                    if (id2 !== void 0) {
                      strId = " in node id: " + id2;
                    }
                    console.log("%cNegative or zero mass disallowed" + strId + ", setting mass to 1.", printStyle);
                    options.mass = 1;
                  }
                }
              }]);
              return Node2;
            }();
            exports2["default"] = Node;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var ComponentUtil = function() {
              function ComponentUtil2() {
                (0, _classCallCheck3["default"])(this, ComponentUtil2);
              }
              (0, _createClass3["default"])(ComponentUtil2, null, [{
                key: "choosify",
                value: function choosify(subOption, pile) {
                  var allowed = ["node", "edge", "label"];
                  var value = true;
                  var chosen = util.topMost(pile, "chosen");
                  if (typeof chosen === "boolean") {
                    value = chosen;
                  } else if ((typeof chosen === "undefined" ? "undefined" : (0, _typeof3["default"])(chosen)) === "object") {
                    if (allowed.indexOf(subOption) === -1) {
                      throw new Error("choosify: subOption '" + subOption + "' should be one of '" + allowed.join("', '") + "'");
                    }
                    var chosenEdge = util.topMost(pile, ["chosen", subOption]);
                    if (typeof chosenEdge === "boolean" || typeof chosenEdge === "function") {
                      value = chosenEdge;
                    }
                  }
                  return value;
                }
              }, {
                key: "pointInRect",
                value: function pointInRect(rect, point, rotationPoint) {
                  if (rect.width <= 0 || rect.height <= 0) {
                    return false;
                  }
                  if (rotationPoint !== void 0) {
                    var tmp = {
                      x: point.x - rotationPoint.x,
                      y: point.y - rotationPoint.y
                    };
                    if (rotationPoint.angle !== 0) {
                      var angle = -rotationPoint.angle;
                      var tmp2 = {
                        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,
                        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y
                      };
                      point = tmp2;
                    } else {
                      point = tmp;
                    }
                  }
                  var right = rect.x + rect.width;
                  var bottom = rect.y + rect.width;
                  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;
                }
              }, {
                key: "isValidLabel",
                value: function isValidLabel(text) {
                  return typeof text === "string" && text !== "";
                }
              }]);
              return ComponentUtil2;
            }();
            exports2["default"] = ComponentUtil;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.onTouch = function(hammer, callback) {
              callback.inputHandler = function(event) {
                if (event.isFirst) {
                  callback(event);
                }
              };
              hammer.on("hammer.input", callback.inputHandler);
            };
            exports2.onRelease = function(hammer, callback) {
              callback.inputHandler = function(event) {
                if (event.isFinal) {
                  callback(event);
                }
              };
              return hammer.on("hammer.input", callback.inputHandler);
            };
            exports2.offTouch = function(hammer, callback) {
              hammer.off("hammer.input", callback.inputHandler);
            };
            exports2.offRelease = exports2.offTouch;
            exports2.disablePreventDefaultVertically = function(pinchRecognizer) {
              var TOUCH_ACTION_PAN_Y = "pan-y";
              pinchRecognizer.getTouchAction = function() {
                return [TOUCH_ACTION_PAN_Y];
              };
              return pinchRecognizer;
            };
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(87);
            var global = __webpack_require__(10);
            var hide3 = __webpack_require__(19);
            var Iterators = __webpack_require__(25);
            var TO_STRING_TAG = __webpack_require__(8)("toStringTag");
            var DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
            for (var i = 0; i < DOMIterables.length; i++) {
              var NAME = DOMIterables[i];
              var Collection = global[NAME];
              var proto = Collection && Collection.prototype;
              if (proto && !proto[TO_STRING_TAG])
                hide3(proto, TO_STRING_TAG, NAME);
              Iterators[NAME] = Iterators.Array;
            }
          },
          function(module2, exports2) {
            var toString = {}.toString;
            module2.exports = function(it) {
              return toString.call(it).slice(8, -1);
            };
          },
          function(module2, exports2) {
            module2.exports = function(it) {
              if (it == void 0)
                throw TypeError("Can't call method on  " + it);
              return it;
            };
          },
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__(21);
            module2.exports = function(it, S) {
              if (!isObject2(it))
                return it;
              var fn, val;
              if (S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
                return val;
              if (typeof (fn = it.valueOf) == "function" && !isObject2(val = fn.call(it)))
                return val;
              if (!S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
                return val;
              throw TypeError("Can't convert object to primitive value");
            };
          },
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__(20);
            var dPs = __webpack_require__(92);
            var enumBugKeys = __webpack_require__(45);
            var IE_PROTO = __webpack_require__(43)("IE_PROTO");
            var Empty = function() {
            };
            var PROTOTYPE = "prototype";
            var createDict = function() {
              var iframe = __webpack_require__(63)("iframe");
              var i = enumBugKeys.length;
              var lt = "<";
              var gt = ">";
              var iframeDocument;
              iframe.style.display = "none";
              __webpack_require__(96).appendChild(iframe);
              iframe.src = "javascript:";
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
              iframeDocument.close();
              createDict = iframeDocument.F;
              while (i--)
                delete createDict[PROTOTYPE][enumBugKeys[i]];
              return createDict();
            };
            module2.exports = Object.create || function create(O, Properties) {
              var result2;
              if (O !== null) {
                Empty[PROTOTYPE] = anObject(O);
                result2 = new Empty();
                Empty[PROTOTYPE] = null;
                result2[IE_PROTO] = O;
              } else
                result2 = createDict();
              return Properties === void 0 ? result2 : dPs(result2, Properties);
            };
          },
          function(module2, exports2) {
            var ceil = Math.ceil;
            var floor = Math.floor;
            module2.exports = function(it) {
              return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
            };
          },
          function(module2, exports2, __webpack_require__) {
            var shared = __webpack_require__(44)("keys");
            var uid = __webpack_require__(29);
            module2.exports = function(key) {
              return shared[key] || (shared[key] = uid(key));
            };
          },
          function(module2, exports2, __webpack_require__) {
            var core = __webpack_require__(6);
            var global = __webpack_require__(10);
            var SHARED = "__core-js_shared__";
            var store = global[SHARED] || (global[SHARED] = {});
            (module2.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: core.version,
              mode: __webpack_require__(27) ? "pure" : "global",
              copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
            });
          },
          function(module2, exports2) {
            module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
          },
          function(module2, exports2, __webpack_require__) {
            var def = __webpack_require__(12).f;
            var has = __webpack_require__(14);
            var TAG = __webpack_require__(8)("toStringTag");
            module2.exports = function(it, tag, stat) {
              if (it && !has(it = stat ? it : it.prototype, TAG))
                def(it, TAG, { configurable: true, value: tag });
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var $at = __webpack_require__(97)(true);
            __webpack_require__(60)(String, "String", function(iterated) {
              this._t = String(iterated);
              this._i = 0;
            }, function() {
              var O = this._t;
              var index = this._i;
              var point;
              if (index >= O.length)
                return { value: void 0, done: true };
              point = $at(O, index);
              this._i += point.length;
              return { value: point, done: false };
            });
          },
          function(module2, exports2, __webpack_require__) {
            exports2.f = __webpack_require__(8);
          },
          function(module2, exports2, __webpack_require__) {
            var global = __webpack_require__(10);
            var core = __webpack_require__(6);
            var LIBRARY = __webpack_require__(27);
            var wksExt = __webpack_require__(48);
            var defineProperty = __webpack_require__(12).f;
            module2.exports = function(name) {
              var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
              if (name.charAt(0) != "_" && !(name in $Symbol))
                defineProperty($Symbol, name, { value: wksExt.f(name) });
            };
          },
          function(module2, exports2) {
            exports2.f = Object.getOwnPropertySymbols;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _keys = __webpack_require__(9);
            var _keys2 = _interopRequireDefault(_keys);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var DataSet2 = __webpack_require__(33);
            function DataView(data, options) {
              this._data = null;
              this._ids = {};
              this.length = 0;
              this._options = options || {};
              this._fieldId = "id";
              this._subscribers = {};
              var me = this;
              this.listener = function() {
                me._onEvent.apply(me, arguments);
              };
              this.setData(data);
            }
            DataView.prototype.setData = function(data) {
              var ids, id2, i, len, items;
              if (this._data) {
                if (this._data.off) {
                  this._data.off("*", this.listener);
                }
                ids = this._data.getIds({ filter: this._options && this._options.filter });
                items = [];
                for (i = 0, len = ids.length; i < len; i++) {
                  items.push(this._data._data[ids[i]]);
                }
                this._ids = {};
                this.length = 0;
                this._trigger("remove", { items: ids, oldData: items });
              }
              this._data = data;
              if (this._data) {
                this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || "id";
                ids = this._data.getIds({ filter: this._options && this._options.filter });
                for (i = 0, len = ids.length; i < len; i++) {
                  id2 = ids[i];
                  this._ids[id2] = true;
                }
                this.length = ids.length;
                this._trigger("add", { items: ids });
                if (this._data.on) {
                  this._data.on("*", this.listener);
                }
              }
            };
            DataView.prototype.refresh = function() {
              var id2, i, len;
              var ids = this._data.getIds({
                filter: this._options && this._options.filter
              }), oldIds = (0, _keys2["default"])(this._ids), newIds = {}, addedIds = [], removedIds = [], removedItems = [];
              for (i = 0, len = ids.length; i < len; i++) {
                id2 = ids[i];
                newIds[id2] = true;
                if (!this._ids[id2]) {
                  addedIds.push(id2);
                  this._ids[id2] = true;
                }
              }
              for (i = 0, len = oldIds.length; i < len; i++) {
                id2 = oldIds[i];
                if (!newIds[id2]) {
                  removedIds.push(id2);
                  removedItems.push(this._data._data[id2]);
                  delete this._ids[id2];
                }
              }
              this.length += addedIds.length - removedIds.length;
              if (addedIds.length) {
                this._trigger("add", { items: addedIds });
              }
              if (removedIds.length) {
                this._trigger("remove", { items: removedIds, oldData: removedItems });
              }
            };
            DataView.prototype.get = function(args) {
              var me = this;
              var ids, options, data;
              var firstType = util.getType(arguments[0]);
              if (firstType == "String" || firstType == "Number" || firstType == "Array") {
                ids = arguments[0];
                options = arguments[1];
                data = arguments[2];
              } else {
                options = arguments[0];
                data = arguments[1];
              }
              var viewOptions = util.extend({}, this._options, options);
              if (this._options.filter && options && options.filter) {
                viewOptions.filter = function(item) {
                  return me._options.filter(item) && options.filter(item);
                };
              }
              var getArguments = [];
              if (ids != void 0) {
                getArguments.push(ids);
              }
              getArguments.push(viewOptions);
              getArguments.push(data);
              return this._data && this._data.get.apply(this._data, getArguments);
            };
            DataView.prototype.getIds = function(options) {
              var ids;
              if (this._data) {
                var defaultFilter = this._options.filter;
                var filter;
                if (options && options.filter) {
                  if (defaultFilter) {
                    filter = function filter2(item) {
                      return defaultFilter(item) && options.filter(item);
                    };
                  } else {
                    filter = options.filter;
                  }
                } else {
                  filter = defaultFilter;
                }
                ids = this._data.getIds({
                  filter,
                  order: options && options.order
                });
              } else {
                ids = [];
              }
              return ids;
            };
            DataView.prototype.map = function(callback, options) {
              var mappedItems = [];
              if (this._data) {
                var defaultFilter = this._options.filter;
                var filter;
                if (options && options.filter) {
                  if (defaultFilter) {
                    filter = function filter2(item) {
                      return defaultFilter(item) && options.filter(item);
                    };
                  } else {
                    filter = options.filter;
                  }
                } else {
                  filter = defaultFilter;
                }
                mappedItems = this._data.map(callback, {
                  filter,
                  order: options && options.order
                });
              } else {
                mappedItems = [];
              }
              return mappedItems;
            };
            DataView.prototype.getDataSet = function() {
              var dataSet = this;
              while (dataSet instanceof DataView) {
                dataSet = dataSet._data;
              }
              return dataSet || null;
            };
            DataView.prototype._onEvent = function(event, params, senderId) {
              var i, len, id2, item;
              var ids = params && params.items;
              var addedIds = [], updatedIds = [], removedIds = [], oldItems = [], updatedItems = [], removedItems = [];
              if (ids && this._data) {
                switch (event) {
                  case "add":
                    for (i = 0, len = ids.length; i < len; i++) {
                      id2 = ids[i];
                      item = this.get(id2);
                      if (item) {
                        this._ids[id2] = true;
                        addedIds.push(id2);
                      }
                    }
                    break;
                  case "update":
                    for (i = 0, len = ids.length; i < len; i++) {
                      id2 = ids[i];
                      item = this.get(id2);
                      if (item) {
                        if (this._ids[id2]) {
                          updatedIds.push(id2);
                          updatedItems.push(params.data[i]);
                          oldItems.push(params.oldData[i]);
                        } else {
                          this._ids[id2] = true;
                          addedIds.push(id2);
                        }
                      } else {
                        if (this._ids[id2]) {
                          delete this._ids[id2];
                          removedIds.push(id2);
                          removedItems.push(params.oldData[i]);
                        } else {
                        }
                      }
                    }
                    break;
                  case "remove":
                    for (i = 0, len = ids.length; i < len; i++) {
                      id2 = ids[i];
                      if (this._ids[id2]) {
                        delete this._ids[id2];
                        removedIds.push(id2);
                        removedItems.push(params.oldData[i]);
                      }
                    }
                    break;
                }
                this.length += addedIds.length - removedIds.length;
                if (addedIds.length) {
                  this._trigger("add", { items: addedIds }, senderId);
                }
                if (updatedIds.length) {
                  this._trigger("update", { items: updatedIds, oldData: oldItems, data: updatedItems }, senderId);
                }
                if (removedIds.length) {
                  this._trigger("remove", { items: removedIds, oldData: removedItems }, senderId);
                }
              }
            };
            DataView.prototype.on = DataSet2.prototype.on;
            DataView.prototype.off = DataSet2.prototype.off;
            DataView.prototype._trigger = DataSet2.prototype._trigger;
            DataView.prototype.subscribe = DataView.prototype.on;
            DataView.prototype.unsubscribe = DataView.prototype.off;
            module2.exports = DataView;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(root, factory) {
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof exports2 === "object") {
                module2.exports = factory();
              } else {
                root.keycharm = factory();
              }
            })(this, function() {
              function keycharm(options) {
                var preventDefault = options && options.preventDefault || false;
                var container = options && options.container || window;
                var _exportFunctions = {};
                var _bound = { keydown: {}, keyup: {} };
                var _keys = {};
                var i;
                for (i = 97; i <= 122; i++) {
                  _keys[String.fromCharCode(i)] = { code: 65 + (i - 97), shift: false };
                }
                for (i = 65; i <= 90; i++) {
                  _keys[String.fromCharCode(i)] = { code: i, shift: true };
                }
                for (i = 0; i <= 9; i++) {
                  _keys["" + i] = { code: 48 + i, shift: false };
                }
                for (i = 1; i <= 12; i++) {
                  _keys["F" + i] = { code: 111 + i, shift: false };
                }
                for (i = 0; i <= 9; i++) {
                  _keys["num" + i] = { code: 96 + i, shift: false };
                }
                _keys["num*"] = { code: 106, shift: false };
                _keys["num+"] = { code: 107, shift: false };
                _keys["num-"] = { code: 109, shift: false };
                _keys["num/"] = { code: 111, shift: false };
                _keys["num."] = { code: 110, shift: false };
                _keys["left"] = { code: 37, shift: false };
                _keys["up"] = { code: 38, shift: false };
                _keys["right"] = { code: 39, shift: false };
                _keys["down"] = { code: 40, shift: false };
                _keys["space"] = { code: 32, shift: false };
                _keys["enter"] = { code: 13, shift: false };
                _keys["shift"] = { code: 16, shift: void 0 };
                _keys["esc"] = { code: 27, shift: false };
                _keys["backspace"] = { code: 8, shift: false };
                _keys["tab"] = { code: 9, shift: false };
                _keys["ctrl"] = { code: 17, shift: false };
                _keys["alt"] = { code: 18, shift: false };
                _keys["delete"] = { code: 46, shift: false };
                _keys["pageup"] = { code: 33, shift: false };
                _keys["pagedown"] = { code: 34, shift: false };
                _keys["="] = { code: 187, shift: false };
                _keys["-"] = { code: 189, shift: false };
                _keys["]"] = { code: 221, shift: false };
                _keys["["] = { code: 219, shift: false };
                var down = function(event) {
                  handleEvent(event, "keydown");
                };
                var up = function(event) {
                  handleEvent(event, "keyup");
                };
                var handleEvent = function(event, type) {
                  if (_bound[type][event.keyCode] !== void 0) {
                    var bound = _bound[type][event.keyCode];
                    for (var i2 = 0; i2 < bound.length; i2++) {
                      if (bound[i2].shift === void 0) {
                        bound[i2].fn(event);
                      } else if (bound[i2].shift == true && event.shiftKey == true) {
                        bound[i2].fn(event);
                      } else if (bound[i2].shift == false && event.shiftKey == false) {
                        bound[i2].fn(event);
                      }
                    }
                    if (preventDefault == true) {
                      event.preventDefault();
                    }
                  }
                };
                _exportFunctions.bind = function(key, callback, type) {
                  if (type === void 0) {
                    type = "keydown";
                  }
                  if (_keys[key] === void 0) {
                    throw new Error("unsupported key: " + key);
                  }
                  if (_bound[type][_keys[key].code] === void 0) {
                    _bound[type][_keys[key].code] = [];
                  }
                  _bound[type][_keys[key].code].push({ fn: callback, shift: _keys[key].shift });
                };
                _exportFunctions.bindAll = function(callback, type) {
                  if (type === void 0) {
                    type = "keydown";
                  }
                  for (var key in _keys) {
                    if (_keys.hasOwnProperty(key)) {
                      _exportFunctions.bind(key, callback, type);
                    }
                  }
                };
                _exportFunctions.getKey = function(event) {
                  for (var key in _keys) {
                    if (_keys.hasOwnProperty(key)) {
                      if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
                        return key;
                      } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
                        return key;
                      } else if (event.keyCode == _keys[key].code && key == "shift") {
                        return key;
                      }
                    }
                  }
                  return "unknown key, currently not supported";
                };
                _exportFunctions.unbind = function(key, callback, type) {
                  if (type === void 0) {
                    type = "keydown";
                  }
                  if (_keys[key] === void 0) {
                    throw new Error("unsupported key: " + key);
                  }
                  if (callback !== void 0) {
                    var newBindings = [];
                    var bound = _bound[type][_keys[key].code];
                    if (bound !== void 0) {
                      for (var i2 = 0; i2 < bound.length; i2++) {
                        if (!(bound[i2].fn == callback && bound[i2].shift == _keys[key].shift)) {
                          newBindings.push(_bound[type][_keys[key].code][i2]);
                        }
                      }
                    }
                    _bound[type][_keys[key].code] = newBindings;
                  } else {
                    _bound[type][_keys[key].code] = [];
                  }
                };
                _exportFunctions.reset = function() {
                  _bound = { keydown: {}, keyup: {} };
                };
                _exportFunctions.destroy = function() {
                  _bound = { keydown: {}, keyup: {} };
                  container.removeEventListener("keydown", down, true);
                  container.removeEventListener("keyup", up, true);
                };
                container.addEventListener("keydown", down, true);
                container.addEventListener("keyup", up, true);
                return _exportFunctions;
              }
              return keycharm;
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(16);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CircleImageBase = function(_NodeBase) {
              (0, _inherits3["default"])(CircleImageBase2, _NodeBase);
              function CircleImageBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, CircleImageBase2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (CircleImageBase2.__proto__ || (0, _getPrototypeOf2["default"])(CircleImageBase2)).call(this, options, body, labelModule));
                _this.labelOffset = 0;
                _this.selected = false;
                return _this;
              }
              (0, _createClass3["default"])(CircleImageBase2, [{
                key: "setOptions",
                value: function setOptions(options, imageObj, imageObjAlt) {
                  this.options = options;
                  if (!(imageObj === void 0 && imageObjAlt === void 0)) {
                    this.setImages(imageObj, imageObjAlt);
                  }
                }
              }, {
                key: "setImages",
                value: function setImages(imageObj, imageObjAlt) {
                  if (imageObjAlt && this.selected) {
                    this.imageObj = imageObjAlt;
                    this.imageObjAlt = imageObj;
                  } else {
                    this.imageObj = imageObj;
                    this.imageObjAlt = imageObjAlt;
                  }
                }
              }, {
                key: "switchImages",
                value: function switchImages(selected) {
                  var selection_changed = selected && !this.selected || !selected && this.selected;
                  this.selected = selected;
                  if (this.imageObjAlt !== void 0 && selection_changed) {
                    var imageTmp = this.imageObj;
                    this.imageObj = this.imageObjAlt;
                    this.imageObjAlt = imageTmp;
                  }
                }
              }, {
                key: "_resizeImage",
                value: function _resizeImage() {
                  var width, height;
                  if (this.options.shapeProperties.useImageSize === false) {
                    var ratio_width = 1;
                    var ratio_height = 1;
                    if (this.imageObj.width && this.imageObj.height) {
                      if (this.imageObj.width > this.imageObj.height) {
                        ratio_width = this.imageObj.width / this.imageObj.height;
                      } else {
                        ratio_height = this.imageObj.height / this.imageObj.width;
                      }
                    }
                    width = this.options.size * 2 * ratio_width;
                    height = this.options.size * 2 * ratio_height;
                  } else {
                    width = this.imageObj.width;
                    height = this.imageObj.height;
                  }
                  this.width = width;
                  this.height = height;
                  this.radius = 0.5 * this.width;
                }
              }, {
                key: "_drawRawCircle",
                value: function _drawRawCircle(ctx, x, y, values) {
                  this.initContextForDraw(ctx, values);
                  ctx.circle(x, y, values.size);
                  this.performFill(ctx, values);
                }
              }, {
                key: "_drawImageAtPosition",
                value: function _drawImageAtPosition(ctx, values) {
                  if (this.imageObj.width != 0) {
                    ctx.globalAlpha = 1;
                    this.enableShadow(ctx, values);
                    var factor = 1;
                    if (this.options.shapeProperties.interpolation === true) {
                      factor = this.imageObj.width / this.width / this.body.view.scale;
                    }
                    this.imageObj.drawImageAtPosition(ctx, factor, this.left, this.top, this.width, this.height);
                    this.disableShadow(ctx, values);
                  }
                }
              }, {
                key: "_drawImageLabel",
                value: function _drawImageLabel(ctx, x, y, selected, hover) {
                  var yLabel;
                  var offset = 0;
                  if (this.height !== void 0) {
                    offset = this.height * 0.5;
                    var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);
                    if (labelDimensions.lineCount >= 1) {
                      offset += labelDimensions.height / 2;
                    }
                  }
                  yLabel = y + offset;
                  if (this.options.label) {
                    this.labelOffset = offset;
                  }
                  this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
                }
              }]);
              return CircleImageBase2;
            }(_NodeBase3["default"]);
            exports2["default"] = CircleImageBase;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.printStyle = void 0;
            var _stringify = __webpack_require__(23);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _keys = __webpack_require__(9);
            var _keys2 = _interopRequireDefault(_keys);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var errorFound = false;
            var allOptions = void 0;
            var printStyle = "background: #FFeeee; color: #dd0000";
            var Validator = function() {
              function Validator2() {
                (0, _classCallCheck3["default"])(this, Validator2);
              }
              (0, _createClass3["default"])(Validator2, null, [{
                key: "validate",
                value: function validate(options, referenceOptions, subObject) {
                  errorFound = false;
                  allOptions = referenceOptions;
                  var usedOptions = referenceOptions;
                  if (subObject !== void 0) {
                    usedOptions = referenceOptions[subObject];
                  }
                  Validator2.parse(options, usedOptions, []);
                  return errorFound;
                }
              }, {
                key: "parse",
                value: function parse(options, referenceOptions, path) {
                  for (var option in options) {
                    if (options.hasOwnProperty(option)) {
                      Validator2.check(option, options, referenceOptions, path);
                    }
                  }
                }
              }, {
                key: "check",
                value: function check(option, options, referenceOptions, path) {
                  if (referenceOptions[option] === void 0 && referenceOptions.__any__ === void 0) {
                    Validator2.getSuggestion(option, referenceOptions, path);
                    return;
                  }
                  var referenceOption = option;
                  var is_object = true;
                  if (referenceOptions[option] === void 0 && referenceOptions.__any__ !== void 0) {
                    referenceOption = "__any__";
                    is_object = Validator2.getType(options[option]) === "object";
                  } else {
                  }
                  var refOptionObj = referenceOptions[referenceOption];
                  if (is_object && refOptionObj.__type__ !== void 0) {
                    refOptionObj = refOptionObj.__type__;
                  }
                  Validator2.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);
                }
              }, {
                key: "checkFields",
                value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
                  var log = function log2(message) {
                    console.log("%c" + message + Validator2.printLocation(path, option), printStyle);
                  };
                  var optionType = Validator2.getType(options[option]);
                  var refOptionType = refOptionObj[optionType];
                  if (refOptionType !== void 0) {
                    if (Validator2.getType(refOptionType) === "array" && refOptionType.indexOf(options[option]) === -1) {
                      log('Invalid option detected in "' + option + '". Allowed values are:' + Validator2.print(refOptionType) + ' not "' + options[option] + '". ');
                      errorFound = true;
                    } else if (optionType === "object" && referenceOption !== "__any__") {
                      path = util.copyAndExtendArray(path, option);
                      Validator2.parse(options[option], referenceOptions[referenceOption], path);
                    }
                  } else if (refOptionObj["any"] === void 0) {
                    log('Invalid type received for "' + option + '". Expected: ' + Validator2.print((0, _keys2["default"])(refOptionObj)) + ". Received [" + optionType + '] "' + options[option] + '"');
                    errorFound = true;
                  }
                }
              }, {
                key: "getType",
                value: function getType(object) {
                  var type = typeof object === "undefined" ? "undefined" : (0, _typeof3["default"])(object);
                  if (type === "object") {
                    if (object === null) {
                      return "null";
                    }
                    if (object instanceof Boolean) {
                      return "boolean";
                    }
                    if (object instanceof Number) {
                      return "number";
                    }
                    if (object instanceof String) {
                      return "string";
                    }
                    if (Array.isArray(object)) {
                      return "array";
                    }
                    if (object instanceof Date) {
                      return "date";
                    }
                    if (object.nodeType !== void 0) {
                      return "dom";
                    }
                    if (object._isAMomentObject === true) {
                      return "moment";
                    }
                    return "object";
                  } else if (type === "number") {
                    return "number";
                  } else if (type === "boolean") {
                    return "boolean";
                  } else if (type === "string") {
                    return "string";
                  } else if (type === void 0) {
                    return "undefined";
                  }
                  return type;
                }
              }, {
                key: "getSuggestion",
                value: function getSuggestion(option, options, path) {
                  var localSearch = Validator2.findInOptions(option, options, path, false);
                  var globalSearch = Validator2.findInOptions(option, allOptions, [], true);
                  var localSearchThreshold = 8;
                  var globalSearchThreshold = 4;
                  var msg = void 0;
                  if (localSearch.indexMatch !== void 0) {
                    msg = " in " + Validator2.printLocation(localSearch.path, option, "") + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
                  } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
                    msg = " in " + Validator2.printLocation(localSearch.path, option, "") + "Perhaps it was misplaced? Matching option found at: " + Validator2.printLocation(globalSearch.path, globalSearch.closestMatch, "");
                  } else if (localSearch.distance <= localSearchThreshold) {
                    msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator2.printLocation(localSearch.path, option);
                  } else {
                    msg = ". Did you mean one of these: " + Validator2.print((0, _keys2["default"])(options)) + Validator2.printLocation(path, option);
                  }
                  console.log('%cUnknown option detected: "' + option + '"' + msg, printStyle);
                  errorFound = true;
                }
              }, {
                key: "findInOptions",
                value: function findInOptions(option, options, path) {
                  var recursive = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  var min = 1e9;
                  var closestMatch = "";
                  var closestMatchPath = [];
                  var lowerCaseOption = option.toLowerCase();
                  var indexMatch = void 0;
                  for (var op in options) {
                    var distance = void 0;
                    if (options[op].__type__ !== void 0 && recursive === true) {
                      var result2 = Validator2.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
                      if (min > result2.distance) {
                        closestMatch = result2.closestMatch;
                        closestMatchPath = result2.path;
                        min = result2.distance;
                        indexMatch = result2.indexMatch;
                      }
                    } else {
                      if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
                        indexMatch = op;
                      }
                      distance = Validator2.levenshteinDistance(option, op);
                      if (min > distance) {
                        closestMatch = op;
                        closestMatchPath = util.copyArray(path);
                        min = distance;
                      }
                    }
                  }
                  return {
                    closestMatch,
                    path: closestMatchPath,
                    distance: min,
                    indexMatch
                  };
                }
              }, {
                key: "printLocation",
                value: function printLocation(path, option) {
                  var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Problem value found at: \n";
                  var str = "\n\n" + prefix + "options = {\n";
                  for (var i = 0; i < path.length; i++) {
                    for (var j = 0; j < i + 1; j++) {
                      str += "  ";
                    }
                    str += path[i] + ": {\n";
                  }
                  for (var _j = 0; _j < path.length + 1; _j++) {
                    str += "  ";
                  }
                  str += option + "\n";
                  for (var _i = 0; _i < path.length + 1; _i++) {
                    for (var _j2 = 0; _j2 < path.length - _i; _j2++) {
                      str += "  ";
                    }
                    str += "}\n";
                  }
                  return str + "\n\n";
                }
              }, {
                key: "print",
                value: function print(options) {
                  return (0, _stringify2["default"])(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ", ");
                }
              }, {
                key: "levenshteinDistance",
                value: function levenshteinDistance(a, b) {
                  if (a.length === 0)
                    return b.length;
                  if (b.length === 0)
                    return a.length;
                  var matrix = [];
                  var i;
                  for (i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                  }
                  var j;
                  for (j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                  }
                  for (i = 1; i <= b.length; i++) {
                    for (j = 1; j <= a.length; j++) {
                      if (b.charAt(i - 1) == a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                      } else {
                        matrix[i][j] = Math.min(
                          matrix[i - 1][j - 1] + 1,
                          Math.min(
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                          )
                        );
                      }
                    }
                  }
                  return matrix[b.length][a.length];
                }
              }]);
              return Validator2;
            }();
            exports2["default"] = Validator;
            exports2.printStyle = printStyle;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _stringify = __webpack_require__(23);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _create = __webpack_require__(31);
            var _create2 = _interopRequireDefault(_create);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Label = __webpack_require__(77)["default"];
            var ComponentUtil = __webpack_require__(35)["default"];
            var CubicBezierEdge = __webpack_require__(166)["default"];
            var BezierEdgeDynamic = __webpack_require__(168)["default"];
            var BezierEdgeStatic = __webpack_require__(169)["default"];
            var StraightEdge = __webpack_require__(170)["default"];
            var Edge = function() {
              function Edge2(options, body, globalOptions, defaultOptions) {
                (0, _classCallCheck3["default"])(this, Edge2);
                if (body === void 0) {
                  throw new Error("No body provided");
                }
                this.options = util.bridgeObject(globalOptions);
                this.globalOptions = globalOptions;
                this.defaultOptions = defaultOptions;
                this.body = body;
                this.id = void 0;
                this.fromId = void 0;
                this.toId = void 0;
                this.selected = false;
                this.hover = false;
                this.labelDirty = true;
                this.baseWidth = this.options.width;
                this.baseFontSize = this.options.font.size;
                this.from = void 0;
                this.to = void 0;
                this.edgeType = void 0;
                this.connected = false;
                this.labelModule = new Label(
                  this.body,
                  this.options,
                  true
                );
                this.setOptions(options);
              }
              (0, _createClass3["default"])(Edge2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (!options) {
                    return;
                  }
                  var oldHidden = this.options.hidden;
                  if (oldHidden === void 0 || oldHidden === null) {
                    oldHidden = false;
                  }
                  Edge2.parseOptions(this.options, options, true, this.globalOptions);
                  if (options.id !== void 0) {
                    this.id = options.id;
                  }
                  if (options.from !== void 0) {
                    this.fromId = options.from;
                  }
                  if (options.to !== void 0) {
                    this.toId = options.to;
                  }
                  if (options.title !== void 0) {
                    this.title = options.title;
                  }
                  if (options.value !== void 0) {
                    options.value = parseFloat(options.value);
                  }
                  var pile = [options, this.options, this.defaultOptions];
                  this.chooser = ComponentUtil.choosify("edge", pile);
                  this.updateLabelModule(options);
                  var dataChanged = this.updateEdgeType();
                  this._setInteractionWidths();
                  this.connect();
                  var newHidden = this.options.hidden;
                  if (newHidden === void 0 || newHidden === null) {
                    newHidden = false;
                  }
                  if (newHidden != oldHidden || options.physics !== void 0) {
                    dataChanged = true;
                  }
                  return dataChanged;
                }
              }, {
                key: "getFormattingValues",
                value: function getFormattingValues() {
                  var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;
                  var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;
                  var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;
                  var inheritsColor = this.options.color.inherit;
                  var values = {
                    toArrow,
                    toArrowScale: this.options.arrows.to.scaleFactor,
                    toArrowType: this.options.arrows.to.type,
                    middleArrow,
                    middleArrowScale: this.options.arrows.middle.scaleFactor,
                    middleArrowType: this.options.arrows.middle.type,
                    fromArrow,
                    fromArrowScale: this.options.arrows.from.scaleFactor,
                    fromArrowType: this.options.arrows.from.type,
                    arrowStrikethrough: this.options.arrowStrikethrough,
                    color: inheritsColor ? void 0 : this.options.color.color,
                    inheritsColor,
                    opacity: this.options.color.opacity,
                    hidden: this.options.hidden,
                    length: this.options.length,
                    shadow: this.options.shadow.enabled,
                    shadowColor: this.options.shadow.color,
                    shadowSize: this.options.shadow.size,
                    shadowX: this.options.shadow.x,
                    shadowY: this.options.shadow.y,
                    dashes: this.options.dashes,
                    width: this.options.width,
                    background: this.options.background.enabled,
                    backgroundColor: this.options.background.color,
                    backgroundSize: this.options.background.size,
                    backgroundDashes: this.options.background.dashes
                  };
                  if (this.selected || this.hover) {
                    if (this.chooser === true) {
                      if (this.selected) {
                        var selectedWidth = this.options.selectionWidth;
                        if (typeof selectedWidth === "function") {
                          values.width = selectedWidth(values.width);
                        } else if (typeof selectedWidth === "number") {
                          values.width += selectedWidth;
                        }
                        values.width = Math.max(values.width, 0.3 / this.body.view.scale);
                        values.color = this.options.color.highlight;
                        values.shadow = this.options.shadow.enabled;
                      } else if (this.hover) {
                        var hoverWidth = this.options.hoverWidth;
                        if (typeof hoverWidth === "function") {
                          values.width = hoverWidth(values.width);
                        } else if (typeof hoverWidth === "number") {
                          values.width += hoverWidth;
                        }
                        values.width = Math.max(values.width, 0.3 / this.body.view.scale);
                        values.color = this.options.color.hover;
                        values.shadow = this.options.shadow.enabled;
                      }
                    } else if (typeof this.chooser === "function") {
                      this.chooser(values, this.options.id, this.selected, this.hover);
                      if (values.color !== void 0) {
                        values.inheritsColor = false;
                      }
                      if (values.shadow === false) {
                        if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
                          values.shadow = true;
                        }
                      }
                    }
                  } else {
                    values.shadow = this.options.shadow.enabled;
                    values.width = Math.max(values.width, 0.3 / this.body.view.scale);
                  }
                  return values;
                }
              }, {
                key: "updateLabelModule",
                value: function updateLabelModule(options) {
                  var pile = [
                    options,
                    this.options,
                    this.globalOptions,
                    this.defaultOptions
                  ];
                  this.labelModule.update(this.options, pile);
                  if (this.labelModule.baseSize !== void 0) {
                    this.baseFontSize = this.labelModule.baseSize;
                  }
                }
              }, {
                key: "updateEdgeType",
                value: function updateEdgeType() {
                  var smooth = this.options.smooth;
                  var dataChanged = false;
                  var changeInType = true;
                  if (this.edgeType !== void 0) {
                    if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === "dynamic" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === "cubicBezier" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== "dynamic" && smooth.type !== "cubicBezier" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {
                      changeInType = false;
                    }
                    if (changeInType === true) {
                      dataChanged = this.cleanup();
                    }
                  }
                  if (changeInType === true) {
                    if (smooth.enabled === true) {
                      if (smooth.type === "dynamic") {
                        dataChanged = true;
                        this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);
                      } else if (smooth.type === "cubicBezier") {
                        this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);
                      } else {
                        this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);
                      }
                    } else {
                      this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);
                    }
                  } else {
                    this.edgeType.setOptions(this.options);
                  }
                  return dataChanged;
                }
              }, {
                key: "connect",
                value: function connect() {
                  this.disconnect();
                  this.from = this.body.nodes[this.fromId] || void 0;
                  this.to = this.body.nodes[this.toId] || void 0;
                  this.connected = this.from !== void 0 && this.to !== void 0;
                  if (this.connected === true) {
                    this.from.attachEdge(this);
                    this.to.attachEdge(this);
                  } else {
                    if (this.from) {
                      this.from.detachEdge(this);
                    }
                    if (this.to) {
                      this.to.detachEdge(this);
                    }
                  }
                  this.edgeType.connect();
                }
              }, {
                key: "disconnect",
                value: function disconnect() {
                  if (this.from) {
                    this.from.detachEdge(this);
                    this.from = void 0;
                  }
                  if (this.to) {
                    this.to.detachEdge(this);
                    this.to = void 0;
                  }
                  this.connected = false;
                }
              }, {
                key: "getTitle",
                value: function getTitle() {
                  return this.title;
                }
              }, {
                key: "isSelected",
                value: function isSelected() {
                  return this.selected;
                }
              }, {
                key: "getValue",
                value: function getValue() {
                  return this.options.value;
                }
              }, {
                key: "setValueRange",
                value: function setValueRange(min, max, total) {
                  if (this.options.value !== void 0) {
                    var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
                    var widthDiff = this.options.scaling.max - this.options.scaling.min;
                    if (this.options.scaling.label.enabled === true) {
                      var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
                      this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
                    }
                    this.options.width = this.options.scaling.min + scale * widthDiff;
                  } else {
                    this.options.width = this.baseWidth;
                    this.options.font.size = this.baseFontSize;
                  }
                  this._setInteractionWidths();
                  this.updateLabelModule();
                }
              }, {
                key: "_setInteractionWidths",
                value: function _setInteractionWidths() {
                  if (typeof this.options.hoverWidth === "function") {
                    this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
                  } else {
                    this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
                  }
                  if (typeof this.options.selectionWidth === "function") {
                    this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
                  } else {
                    this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx) {
                  var values = this.getFormattingValues();
                  if (values.hidden) {
                    return;
                  }
                  var viaNode = this.edgeType.getViaNode();
                  var arrowData = {};
                  this.edgeType.fromPoint = this.edgeType.from;
                  this.edgeType.toPoint = this.edgeType.to;
                  if (values.fromArrow) {
                    arrowData.from = this.edgeType.getArrowData(ctx, "from", viaNode, this.selected, this.hover, values);
                    if (values.arrowStrikethrough === false)
                      this.edgeType.fromPoint = arrowData.from.core;
                  }
                  if (values.toArrow) {
                    arrowData.to = this.edgeType.getArrowData(ctx, "to", viaNode, this.selected, this.hover, values);
                    if (values.arrowStrikethrough === false)
                      this.edgeType.toPoint = arrowData.to.core;
                  }
                  if (values.middleArrow) {
                    arrowData.middle = this.edgeType.getArrowData(ctx, "middle", viaNode, this.selected, this.hover, values);
                  }
                  this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);
                  this.drawArrows(ctx, arrowData, values);
                  this.drawLabel(ctx, viaNode);
                }
              }, {
                key: "drawArrows",
                value: function drawArrows(ctx, arrowData, values) {
                  if (values.fromArrow) {
                    this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);
                  }
                  if (values.middleArrow) {
                    this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);
                  }
                  if (values.toArrow) {
                    this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);
                  }
                }
              }, {
                key: "drawLabel",
                value: function drawLabel(ctx, viaNode) {
                  if (this.options.label !== void 0) {
                    var node1 = this.from;
                    var node2 = this.to;
                    if (this.labelModule.differentState(this.selected, this.hover)) {
                      this.labelModule.getTextSize(ctx, this.selected, this.hover);
                    }
                    if (node1.id != node2.id) {
                      this.labelModule.pointToSelf = false;
                      var point = this.edgeType.getPoint(0.5, viaNode);
                      ctx.save();
                      var rotationPoint = this._getRotation(ctx);
                      if (rotationPoint.angle != 0) {
                        ctx.translate(rotationPoint.x, rotationPoint.y);
                        ctx.rotate(rotationPoint.angle);
                      }
                      this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
                      ctx.restore();
                    } else {
                      this.labelModule.pointToSelf = true;
                      var x, y;
                      var radius = this.options.selfReferenceSize;
                      if (node1.shape.width > node1.shape.height) {
                        x = node1.x + node1.shape.width * 0.5;
                        y = node1.y - radius;
                      } else {
                        x = node1.x + radius;
                        y = node1.y - node1.shape.height * 0.5;
                      }
                      point = this._pointOnCircle(x, y, radius, 0.125);
                      this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
                    }
                  }
                }
              }, {
                key: "getItemsOnPoint",
                value: function getItemsOnPoint(point) {
                  var ret = [];
                  if (this.labelModule.visible()) {
                    var rotationPoint = this._getRotation();
                    if (ComponentUtil.pointInRect(this.labelModule.getSize(), point, rotationPoint)) {
                      ret.push({ edgeId: this.id, labelId: 0 });
                    }
                  }
                  var obj = {
                    left: point.x,
                    top: point.y
                  };
                  if (this.isOverlappingWith(obj)) {
                    ret.push({ edgeId: this.id });
                  }
                  return ret;
                }
              }, {
                key: "isOverlappingWith",
                value: function isOverlappingWith(obj) {
                  if (this.connected) {
                    var distMax = 10;
                    var xFrom = this.from.x;
                    var yFrom = this.from.y;
                    var xTo = this.to.x;
                    var yTo = this.to.y;
                    var xObj = obj.left;
                    var yObj = obj.top;
                    var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);
                    return dist < distMax;
                  } else {
                    return false;
                  }
                }
              }, {
                key: "_getRotation",
                value: function _getRotation(ctx) {
                  var viaNode = this.edgeType.getViaNode();
                  var point = this.edgeType.getPoint(0.5, viaNode);
                  if (ctx !== void 0) {
                    this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);
                  }
                  var ret = {
                    x: point.x,
                    y: this.labelModule.size.yLine,
                    angle: 0
                  };
                  if (!this.labelModule.visible()) {
                    return ret;
                  }
                  if (this.options.font.align === "horizontal") {
                    return ret;
                  }
                  var dy = this.from.y - this.to.y;
                  var dx = this.from.x - this.to.x;
                  var angle = Math.atan2(dy, dx);
                  if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {
                    angle += Math.PI;
                  }
                  ret.angle = angle;
                  return ret;
                }
              }, {
                key: "_pointOnCircle",
                value: function _pointOnCircle(x, y, radius, percentage) {
                  var angle = percentage * 2 * Math.PI;
                  return {
                    x: x + radius * Math.cos(angle),
                    y: y - radius * Math.sin(angle)
                  };
                }
              }, {
                key: "select",
                value: function select() {
                  this.selected = true;
                }
              }, {
                key: "unselect",
                value: function unselect() {
                  this.selected = false;
                }
              }, {
                key: "cleanup",
                value: function cleanup() {
                  if (this.edgeType) {
                    return this.edgeType.cleanup();
                  }
                }
              }, {
                key: "remove",
                value: function remove2() {
                  this.cleanup();
                  this.disconnect();
                  delete this.body.edges[this.id];
                }
              }, {
                key: "endPointsValid",
                value: function endPointsValid() {
                  return this.body.nodes[this.fromId] !== void 0 && this.body.nodes[this.toId] !== void 0;
                }
              }], [{
                key: "parseOptions",
                value: function parseOptions(parentOptions, newOptions) {
                  var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                  var copyFromGlobals = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                  var fields = ["arrowStrikethrough", "id", "from", "hidden", "hoverWidth", "labelHighlightBold", "length", "line", "opacity", "physics", "scaling", "selectionWidth", "selfReferenceSize", "to", "title", "value", "width", "font", "chosen", "widthConstraint"];
                  util.selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);
                  if (ComponentUtil.isValidLabel(newOptions.label)) {
                    parentOptions.label = newOptions.label;
                  } else if (!ComponentUtil.isValidLabel(parentOptions.label)) {
                    parentOptions.label = void 0;
                  }
                  util.mergeOptions(parentOptions, newOptions, "smooth", globalOptions);
                  util.mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
                  util.mergeOptions(parentOptions, newOptions, "background", globalOptions);
                  if (newOptions.dashes !== void 0 && newOptions.dashes !== null) {
                    parentOptions.dashes = newOptions.dashes;
                  } else if (allowDeletion === true && newOptions.dashes === null) {
                    parentOptions.dashes = (0, _create2["default"])(globalOptions.dashes);
                  }
                  if (newOptions.scaling !== void 0 && newOptions.scaling !== null) {
                    if (newOptions.scaling.min !== void 0) {
                      parentOptions.scaling.min = newOptions.scaling.min;
                    }
                    if (newOptions.scaling.max !== void 0) {
                      parentOptions.scaling.max = newOptions.scaling.max;
                    }
                    util.mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
                  } else if (allowDeletion === true && newOptions.scaling === null) {
                    parentOptions.scaling = (0, _create2["default"])(globalOptions.scaling);
                  }
                  if (newOptions.arrows !== void 0 && newOptions.arrows !== null) {
                    if (typeof newOptions.arrows === "string") {
                      var arrows = newOptions.arrows.toLowerCase();
                      parentOptions.arrows.to.enabled = arrows.indexOf("to") != -1;
                      parentOptions.arrows.middle.enabled = arrows.indexOf("middle") != -1;
                      parentOptions.arrows.from.enabled = arrows.indexOf("from") != -1;
                    } else if ((0, _typeof3["default"])(newOptions.arrows) === "object") {
                      util.mergeOptions(parentOptions.arrows, newOptions.arrows, "to", globalOptions.arrows);
                      util.mergeOptions(parentOptions.arrows, newOptions.arrows, "middle", globalOptions.arrows);
                      util.mergeOptions(parentOptions.arrows, newOptions.arrows, "from", globalOptions.arrows);
                    } else {
                      throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + (0, _stringify2["default"])(newOptions.arrows));
                    }
                  } else if (allowDeletion === true && newOptions.arrows === null) {
                    parentOptions.arrows = (0, _create2["default"])(globalOptions.arrows);
                  }
                  if (newOptions.color !== void 0 && newOptions.color !== null) {
                    var fromColor = newOptions.color;
                    var toColor = parentOptions.color;
                    if (copyFromGlobals) {
                      util.deepExtend(toColor, globalOptions.color, false, allowDeletion);
                    } else {
                      for (var i in toColor) {
                        if (toColor.hasOwnProperty(i)) {
                          delete toColor[i];
                        }
                      }
                    }
                    if (util.isString(toColor)) {
                      toColor.color = toColor;
                      toColor.highlight = toColor;
                      toColor.hover = toColor;
                      toColor.inherit = false;
                      if (fromColor.opacity === void 0) {
                        toColor.opacity = 1;
                      }
                    } else {
                      var colorsDefined = false;
                      if (fromColor.color !== void 0) {
                        toColor.color = fromColor.color;
                        colorsDefined = true;
                      }
                      if (fromColor.highlight !== void 0) {
                        toColor.highlight = fromColor.highlight;
                        colorsDefined = true;
                      }
                      if (fromColor.hover !== void 0) {
                        toColor.hover = fromColor.hover;
                        colorsDefined = true;
                      }
                      if (fromColor.inherit !== void 0) {
                        toColor.inherit = fromColor.inherit;
                      }
                      if (fromColor.opacity !== void 0) {
                        toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));
                      }
                      if (colorsDefined === true) {
                        toColor.inherit = false;
                      } else {
                        if (toColor.inherit === void 0) {
                          toColor.inherit = "from";
                        }
                      }
                    }
                  } else if (allowDeletion === true && newOptions.color === null) {
                    parentOptions.color = util.bridgeObject(globalOptions.color);
                  }
                  if (allowDeletion === true && newOptions.font === null) {
                    parentOptions.font = util.bridgeObject(globalOptions.font);
                  }
                }
              }]);
              return Edge2;
            }();
            exports2["default"] = Edge;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _EdgeBase2 = __webpack_require__(79);
            var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BezierEdgeBase = function(_EdgeBase) {
              (0, _inherits3["default"])(BezierEdgeBase2, _EdgeBase);
              function BezierEdgeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, BezierEdgeBase2);
                return (0, _possibleConstructorReturn3["default"])(this, (BezierEdgeBase2.__proto__ || (0, _getPrototypeOf2["default"])(BezierEdgeBase2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(BezierEdgeBase2, [{
                key: "_findBorderPositionBezier",
                value: function _findBorderPositionBezier(nearNode, ctx) {
                  var viaNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this._getViaCoordinates();
                  var maxIterations = 10;
                  var iteration = 0;
                  var low = 0;
                  var high = 1;
                  var pos, angle, distanceToBorder, distanceToPoint, difference;
                  var threshold = 0.2;
                  var node = this.to;
                  var from = false;
                  if (nearNode.id === this.from.id) {
                    node = this.from;
                    from = true;
                  }
                  while (low <= high && iteration < maxIterations) {
                    var middle = (low + high) * 0.5;
                    pos = this.getPoint(middle, viaNode);
                    angle = Math.atan2(node.y - pos.y, node.x - pos.x);
                    distanceToBorder = node.distanceToBorder(ctx, angle);
                    distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
                    difference = distanceToBorder - distanceToPoint;
                    if (Math.abs(difference) < threshold) {
                      break;
                    } else if (difference < 0) {
                      if (from === false) {
                        low = middle;
                      } else {
                        high = middle;
                      }
                    } else {
                      if (from === false) {
                        high = middle;
                      } else {
                        low = middle;
                      }
                    }
                    iteration++;
                  }
                  pos.t = middle;
                  return pos;
                }
              }, {
                key: "_getDistanceToBezierEdge",
                value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
                  var minDistance = 1e9;
                  var distance = void 0;
                  var i = void 0, t = void 0, x = void 0, y = void 0;
                  var lastX = x1;
                  var lastY = y1;
                  for (i = 1; i < 10; i++) {
                    t = 0.1 * i;
                    x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
                    y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;
                    if (i > 0) {
                      distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
                      minDistance = distance < minDistance ? distance : minDistance;
                    }
                    lastX = x;
                    lastY = y;
                  }
                  return minDistance;
                }
              }, {
                key: "_bezierCurve",
                value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {
                  var hasNode1 = viaNode1 !== void 0 && viaNode1.x !== void 0;
                  var hasNode2 = viaNode2 !== void 0 && viaNode2.x !== void 0;
                  ctx.beginPath();
                  ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
                  if (hasNode1 && hasNode2) {
                    ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);
                  } else if (hasNode1) {
                    ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);
                  } else {
                    ctx.lineTo(this.toPoint.x, this.toPoint.y);
                  }
                  this.drawBackground(ctx, values);
                  this.enableShadow(ctx, values);
                  ctx.stroke();
                  this.disableShadow(ctx, values);
                }
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return this._getViaCoordinates();
                }
              }]);
              return BezierEdgeBase2;
            }(_EdgeBase3["default"]);
            exports2["default"] = BezierEdgeBase;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var NetworkUtil = function() {
              function NetworkUtil2() {
                (0, _classCallCheck3["default"])(this, NetworkUtil2);
              }
              (0, _createClass3["default"])(NetworkUtil2, null, [{
                key: "getRange",
                value: function getRange(allNodes) {
                  var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                  var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node;
                  if (specificNodes.length > 0) {
                    for (var i = 0; i < specificNodes.length; i++) {
                      node = allNodes[specificNodes[i]];
                      if (minX > node.shape.boundingBox.left) {
                        minX = node.shape.boundingBox.left;
                      }
                      if (maxX < node.shape.boundingBox.right) {
                        maxX = node.shape.boundingBox.right;
                      }
                      if (minY > node.shape.boundingBox.top) {
                        minY = node.shape.boundingBox.top;
                      }
                      if (maxY < node.shape.boundingBox.bottom) {
                        maxY = node.shape.boundingBox.bottom;
                      }
                    }
                  }
                  if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
                    ;
                    minY = 0, maxY = 0, minX = 0, maxX = 0;
                  }
                  return { minX, maxX, minY, maxY };
                }
              }, {
                key: "getRangeCore",
                value: function getRangeCore(allNodes) {
                  var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                  var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node;
                  if (specificNodes.length > 0) {
                    for (var i = 0; i < specificNodes.length; i++) {
                      node = allNodes[specificNodes[i]];
                      if (minX > node.x) {
                        minX = node.x;
                      }
                      if (maxX < node.x) {
                        maxX = node.x;
                      }
                      if (minY > node.y) {
                        minY = node.y;
                      }
                      if (maxY < node.y) {
                        maxY = node.y;
                      }
                    }
                  }
                  if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
                    ;
                    minY = 0, maxY = 0, minX = 0, maxX = 0;
                  }
                  return { minX, maxX, minY, maxY };
                }
              }, {
                key: "findCenter",
                value: function findCenter(range) {
                  return {
                    x: 0.5 * (range.maxX + range.minX),
                    y: 0.5 * (range.maxY + range.minY)
                  };
                }
              }, {
                key: "cloneOptions",
                value: function cloneOptions(item, type) {
                  var clonedOptions = {};
                  if (type === void 0 || type === "node") {
                    util.deepExtend(clonedOptions, item.options, true);
                    clonedOptions.x = item.x;
                    clonedOptions.y = item.y;
                    clonedOptions.amountOfConnections = item.edges.length;
                  } else {
                    util.deepExtend(clonedOptions, item.options, true);
                  }
                  return clonedOptions;
                }
              }]);
              return NetworkUtil2;
            }();
            exports2["default"] = NetworkUtil;
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(86), __esModule: true };
          },
          function(module2, exports2, __webpack_require__) {
            var cof = __webpack_require__(38);
            module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
              return cof(it) == "String" ? it.split("") : Object(it);
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var LIBRARY = __webpack_require__(27);
            var $export = __webpack_require__(11);
            var redefine = __webpack_require__(64);
            var hide3 = __webpack_require__(19);
            var Iterators = __webpack_require__(25);
            var $iterCreate = __webpack_require__(91);
            var setToStringTag = __webpack_require__(46);
            var getPrototypeOf = __webpack_require__(66);
            var ITERATOR = __webpack_require__(8)("iterator");
            var BUGGY = !([].keys && "next" in [].keys());
            var FF_ITERATOR = "@@iterator";
            var KEYS = "keys";
            var VALUES = "values";
            var returnThis = function() {
              return this;
            };
            module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
              $iterCreate(Constructor, NAME, next);
              var getMethod = function(kind) {
                if (!BUGGY && kind in proto)
                  return proto[kind];
                switch (kind) {
                  case KEYS:
                    return function keys() {
                      return new Constructor(this, kind);
                    };
                  case VALUES:
                    return function values() {
                      return new Constructor(this, kind);
                    };
                }
                return function entries() {
                  return new Constructor(this, kind);
                };
              };
              var TAG = NAME + " Iterator";
              var DEF_VALUES = DEFAULT == VALUES;
              var VALUES_BUG = false;
              var proto = Base.prototype;
              var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
              var $default = $native || getMethod(DEFAULT);
              var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
              var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
              var methods, key, IteratorPrototype;
              if ($anyNative) {
                IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
                if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                  setToStringTag(IteratorPrototype, TAG, true);
                  if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function")
                    hide3(IteratorPrototype, ITERATOR, returnThis);
                }
              }
              if (DEF_VALUES && $native && $native.name !== VALUES) {
                VALUES_BUG = true;
                $default = function values() {
                  return $native.call(this);
                };
              }
              if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                hide3(proto, ITERATOR, $default);
              }
              Iterators[NAME] = $default;
              Iterators[TAG] = returnThis;
              if (DEFAULT) {
                methods = {
                  values: DEF_VALUES ? $default : getMethod(VALUES),
                  keys: IS_SET ? $default : getMethod(KEYS),
                  entries: $entries
                };
                if (FORCED)
                  for (key in methods) {
                    if (!(key in proto))
                      redefine(proto, key, methods[key]);
                  }
                else
                  $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
              }
              return methods;
            };
          },
          function(module2, exports2, __webpack_require__) {
            var aFunction = __webpack_require__(90);
            module2.exports = function(fn, that, length2) {
              aFunction(fn);
              if (that === void 0)
                return fn;
              switch (length2) {
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b) {
                    return fn.call(that, a, b);
                  };
                case 3:
                  return function(a, b, c) {
                    return fn.call(that, a, b, c);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = !__webpack_require__(13) && !__webpack_require__(22)(function() {
              return Object.defineProperty(__webpack_require__(63)("div"), "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          },
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__(21);
            var document2 = __webpack_require__(10).document;
            var is = isObject2(document2) && isObject2(document2.createElement);
            module2.exports = function(it) {
              return is ? document2.createElement(it) : {};
            };
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = __webpack_require__(19);
          },
          function(module2, exports2, __webpack_require__) {
            var has = __webpack_require__(14);
            var toIObject = __webpack_require__(18);
            var arrayIndexOf = __webpack_require__(93)(false);
            var IE_PROTO = __webpack_require__(43)("IE_PROTO");
            module2.exports = function(object, names) {
              var O = toIObject(object);
              var i = 0;
              var result2 = [];
              var key;
              for (key in O)
                if (key != IE_PROTO)
                  has(O, key) && result2.push(key);
              while (names.length > i)
                if (has(O, key = names[i++])) {
                  ~arrayIndexOf(result2, key) || result2.push(key);
                }
              return result2;
            };
          },
          function(module2, exports2, __webpack_require__) {
            var has = __webpack_require__(14);
            var toObject = __webpack_require__(30);
            var IE_PROTO = __webpack_require__(43)("IE_PROTO");
            var ObjectProto = Object.prototype;
            module2.exports = Object.getPrototypeOf || function(O) {
              O = toObject(O);
              if (has(O, IE_PROTO))
                return O[IE_PROTO];
              if (typeof O.constructor == "function" && O instanceof O.constructor) {
                return O.constructor.prototype;
              }
              return O instanceof Object ? ObjectProto : null;
            };
          },
          function(module2, exports2, __webpack_require__) {
            var cof = __webpack_require__(38);
            var TAG = __webpack_require__(8)("toStringTag");
            var ARG = cof(function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function(it, key) {
              try {
                return it[key];
              } catch (e) {
              }
            };
            module2.exports = function(it) {
              var O, T, B;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
            };
          },
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(11);
            var core = __webpack_require__(6);
            var fails = __webpack_require__(22);
            module2.exports = function(KEY, exec) {
              var fn = (core.Object || {})[KEY] || Object[KEY];
              var exp = {};
              exp[KEY] = exec(fn);
              $export($export.S + $export.F * fails(function() {
                fn(1);
              }), "Object", exp);
            };
          },
          function(module2, exports2, __webpack_require__) {
            var $keys = __webpack_require__(65);
            var hiddenKeys = __webpack_require__(45).concat("length", "prototype");
            exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
              return $keys(O, hiddenKeys);
            };
          },
          function(module2, exports2, __webpack_require__) {
            var pIE = __webpack_require__(32);
            var createDesc = __webpack_require__(28);
            var toIObject = __webpack_require__(18);
            var toPrimitive = __webpack_require__(40);
            var has = __webpack_require__(14);
            var IE8_DOM_DEFINE = __webpack_require__(62);
            var gOPD = Object.getOwnPropertyDescriptor;
            exports2.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) {
              O = toIObject(O);
              P = toPrimitive(P, true);
              if (IE8_DOM_DEFINE)
                try {
                  return gOPD(O, P);
                } catch (e) {
                }
              if (has(O, P))
                return createDesc(!pIE.f.call(O, P), O[P]);
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            module2.exports = typeof window !== "undefined" && window["moment"] || __webpack_require__(116);
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function Queue(options) {
              this.delay = null;
              this.max = Infinity;
              this._queue = [];
              this._timeout = null;
              this._extended = null;
              this.setOptions(options);
            }
            Queue.prototype.setOptions = function(options) {
              if (options && typeof options.delay !== "undefined") {
                this.delay = options.delay;
              }
              if (options && typeof options.max !== "undefined") {
                this.max = options.max;
              }
              this._flushIfNeeded();
            };
            Queue.extend = function(object, options) {
              var queue = new Queue(options);
              if (object.flush !== void 0) {
                throw new Error("Target object already has a property flush");
              }
              object.flush = function() {
                queue.flush();
              };
              var methods = [{
                name: "flush",
                original: void 0
              }];
              if (options && options.replace) {
                for (var i = 0; i < options.replace.length; i++) {
                  var name = options.replace[i];
                  methods.push({
                    name,
                    original: object[name]
                  });
                  queue.replace(object, name);
                }
              }
              queue._extended = {
                object,
                methods
              };
              return queue;
            };
            Queue.prototype.destroy = function() {
              this.flush();
              if (this._extended) {
                var object = this._extended.object;
                var methods = this._extended.methods;
                for (var i = 0; i < methods.length; i++) {
                  var method = methods[i];
                  if (method.original) {
                    object[method.name] = method.original;
                  } else {
                    delete object[method.name];
                  }
                }
                this._extended = null;
              }
            };
            Queue.prototype.replace = function(object, method) {
              var me = this;
              var original = object[method];
              if (!original) {
                throw new Error("Method " + method + " undefined");
              }
              object[method] = function() {
                var args = [];
                for (var i = 0; i < arguments.length; i++) {
                  args[i] = arguments[i];
                }
                me.queue({
                  args,
                  fn: original,
                  context: this
                });
              };
            };
            Queue.prototype.queue = function(entry) {
              if (typeof entry === "function") {
                this._queue.push({ fn: entry });
              } else {
                this._queue.push(entry);
              }
              this._flushIfNeeded();
            };
            Queue.prototype._flushIfNeeded = function() {
              if (this._queue.length > this.max) {
                this.flush();
              }
              clearTimeout(this._timeout);
              if (this.queue.length > 0 && typeof this.delay === "number") {
                var me = this;
                this._timeout = setTimeout(function() {
                  me.flush();
                }, this.delay);
              }
            };
            Queue.prototype.flush = function() {
              while (this._queue.length > 0) {
                var entry = this._queue.shift();
                entry.fn.apply(entry.context || entry.fn, entry.args || []);
              }
            };
            module2.exports = Queue;
          },
          function(module2, exports2) {
            module2.exports = Emitter;
            function Emitter(obj) {
              if (obj)
                return mixin(obj);
            }
            ;
            function mixin(obj) {
              for (var key in Emitter.prototype) {
                obj[key] = Emitter.prototype[key];
              }
              return obj;
            }
            Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
              this._callbacks = this._callbacks || {};
              (this._callbacks[event] = this._callbacks[event] || []).push(fn);
              return this;
            };
            Emitter.prototype.once = function(event, fn) {
              var self2 = this;
              this._callbacks = this._callbacks || {};
              function on() {
                self2.off(event, on);
                fn.apply(this, arguments);
              }
              on.fn = fn;
              this.on(event, on);
              return this;
            };
            Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
              this._callbacks = this._callbacks || {};
              if (0 == arguments.length) {
                this._callbacks = {};
                return this;
              }
              var callbacks = this._callbacks[event];
              if (!callbacks)
                return this;
              if (1 == arguments.length) {
                delete this._callbacks[event];
                return this;
              }
              var cb;
              for (var i = 0; i < callbacks.length; i++) {
                cb = callbacks[i];
                if (cb === fn || cb.fn === fn) {
                  callbacks.splice(i, 1);
                  break;
                }
              }
              return this;
            };
            Emitter.prototype.emit = function(event) {
              this._callbacks = this._callbacks || {};
              var args = [].slice.call(arguments, 1), callbacks = this._callbacks[event];
              if (callbacks) {
                callbacks = callbacks.slice(0);
                for (var i = 0, len = callbacks.length; i < len; ++i) {
                  callbacks[i].apply(this, args);
                }
              }
              return this;
            };
            Emitter.prototype.listeners = function(event) {
              this._callbacks = this._callbacks || {};
              return this._callbacks[event] || [];
            };
            Emitter.prototype.hasListeners = function(event) {
              return !!this.listeners(event).length;
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _create = __webpack_require__(31);
            var _create2 = _interopRequireDefault(_create);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function parseDOT(data) {
              dot = data;
              return parseGraph();
            }
            var NODE_ATTR_MAPPING = {
              fontsize: "font.size",
              fontcolor: "font.color",
              labelfontcolor: "font.color",
              fontname: "font.face",
              color: ["color.border", "color.background"],
              fillcolor: "color.background",
              tooltip: "title",
              labeltooltip: "title"
            };
            var EDGE_ATTR_MAPPING = (0, _create2["default"])(NODE_ATTR_MAPPING);
            EDGE_ATTR_MAPPING.color = "color.color";
            EDGE_ATTR_MAPPING.style = "dashes";
            var TOKENTYPE = {
              NULL: 0,
              DELIMITER: 1,
              IDENTIFIER: 2,
              UNKNOWN: 3
            };
            var DELIMITERS = {
              "{": true,
              "}": true,
              "[": true,
              "]": true,
              ";": true,
              "=": true,
              ",": true,
              "->": true,
              "--": true
            };
            var dot = "";
            var index = 0;
            var c = "";
            var token = "";
            var tokenType = TOKENTYPE.NULL;
            function first() {
              index = 0;
              c = dot.charAt(0);
            }
            function next() {
              index++;
              c = dot.charAt(index);
            }
            function nextPreview() {
              return dot.charAt(index + 1);
            }
            var regexAlphaNumeric = /[a-zA-Z_0-9.:#]/;
            function isAlphaNumeric(c2) {
              return regexAlphaNumeric.test(c2);
            }
            function merge(a, b) {
              if (!a) {
                a = {};
              }
              if (b) {
                for (var name in b) {
                  if (b.hasOwnProperty(name)) {
                    a[name] = b[name];
                  }
                }
              }
              return a;
            }
            function setValue(obj, path, value) {
              var keys = path.split(".");
              var o = obj;
              while (keys.length) {
                var key = keys.shift();
                if (keys.length) {
                  if (!o[key]) {
                    o[key] = {};
                  }
                  o = o[key];
                } else {
                  o[key] = value;
                }
              }
            }
            function addNode2(graph, node) {
              var i, len;
              var current = null;
              var graphs = [graph];
              var root = graph;
              while (root.parent) {
                graphs.push(root.parent);
                root = root.parent;
              }
              if (root.nodes) {
                for (i = 0, len = root.nodes.length; i < len; i++) {
                  if (node.id === root.nodes[i].id) {
                    current = root.nodes[i];
                    break;
                  }
                }
              }
              if (!current) {
                current = {
                  id: node.id
                };
                if (graph.node) {
                  current.attr = merge(current.attr, graph.node);
                }
              }
              for (i = graphs.length - 1; i >= 0; i--) {
                var g = graphs[i];
                if (!g.nodes) {
                  g.nodes = [];
                }
                if (g.nodes.indexOf(current) === -1) {
                  g.nodes.push(current);
                }
              }
              if (node.attr) {
                current.attr = merge(current.attr, node.attr);
              }
            }
            function addEdge(graph, edge) {
              if (!graph.edges) {
                graph.edges = [];
              }
              graph.edges.push(edge);
              if (graph.edge) {
                var attr = merge({}, graph.edge);
                edge.attr = merge(attr, edge.attr);
              }
            }
            function createEdge(graph, from, to, type, attr) {
              var edge = {
                from,
                to,
                type
              };
              if (graph.edge) {
                edge.attr = merge({}, graph.edge);
              }
              edge.attr = merge(edge.attr || {}, attr);
              if (attr != null) {
                if (attr.hasOwnProperty("arrows")) {
                  edge["arrows"] = { to: { enabled: true, type: attr.arrows.type } };
                  attr["arrows"] = null;
                }
              }
              return edge;
            }
            function getToken() {
              tokenType = TOKENTYPE.NULL;
              token = "";
              while (c === " " || c === "	" || c === "\n" || c === "\r") {
                next();
              }
              do {
                var isComment = false;
                if (c === "#") {
                  var i = index - 1;
                  while (dot.charAt(i) === " " || dot.charAt(i) === "	") {
                    i--;
                  }
                  if (dot.charAt(i) === "\n" || dot.charAt(i) === "") {
                    while (c != "" && c != "\n") {
                      next();
                    }
                    isComment = true;
                  }
                }
                if (c === "/" && nextPreview() === "/") {
                  while (c != "" && c != "\n") {
                    next();
                  }
                  isComment = true;
                }
                if (c === "/" && nextPreview() === "*") {
                  while (c != "") {
                    if (c === "*" && nextPreview() === "/") {
                      next();
                      next();
                      break;
                    } else {
                      next();
                    }
                  }
                  isComment = true;
                }
                while (c === " " || c === "	" || c === "\n" || c === "\r") {
                  next();
                }
              } while (isComment);
              if (c === "") {
                tokenType = TOKENTYPE.DELIMITER;
                return;
              }
              var c2 = c + nextPreview();
              if (DELIMITERS[c2]) {
                tokenType = TOKENTYPE.DELIMITER;
                token = c2;
                next();
                next();
                return;
              }
              if (DELIMITERS[c]) {
                tokenType = TOKENTYPE.DELIMITER;
                token = c;
                next();
                return;
              }
              if (isAlphaNumeric(c) || c === "-") {
                token += c;
                next();
                while (isAlphaNumeric(c)) {
                  token += c;
                  next();
                }
                if (token === "false") {
                  token = false;
                } else if (token === "true") {
                  token = true;
                } else if (!isNaN(Number(token))) {
                  token = Number(token);
                }
                tokenType = TOKENTYPE.IDENTIFIER;
                return;
              }
              if (c === '"') {
                next();
                while (c != "" && (c != '"' || c === '"' && nextPreview() === '"')) {
                  if (c === '"') {
                    token += c;
                    next();
                  } else if (c === "\\" && nextPreview() === "n") {
                    token += "\n";
                    next();
                  } else {
                    token += c;
                  }
                  next();
                }
                if (c != '"') {
                  throw newSyntaxError('End of string " expected');
                }
                next();
                tokenType = TOKENTYPE.IDENTIFIER;
                return;
              }
              tokenType = TOKENTYPE.UNKNOWN;
              while (c != "") {
                token += c;
                next();
              }
              throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
            }
            function parseGraph() {
              var graph = {};
              first();
              getToken();
              if (token === "strict") {
                graph.strict = true;
                getToken();
              }
              if (token === "graph" || token === "digraph") {
                graph.type = token;
                getToken();
              }
              if (tokenType === TOKENTYPE.IDENTIFIER) {
                graph.id = token;
                getToken();
              }
              if (token != "{") {
                throw newSyntaxError("Angle bracket { expected");
              }
              getToken();
              parseStatements(graph);
              if (token != "}") {
                throw newSyntaxError("Angle bracket } expected");
              }
              getToken();
              if (token !== "") {
                throw newSyntaxError("End of file expected");
              }
              getToken();
              delete graph.node;
              delete graph.edge;
              delete graph.graph;
              return graph;
            }
            function parseStatements(graph) {
              while (token !== "" && token != "}") {
                parseStatement(graph);
                if (token === ";") {
                  getToken();
                }
              }
            }
            function parseStatement(graph) {
              var subgraph = parseSubgraph(graph);
              if (subgraph) {
                parseEdge(graph, subgraph);
                return;
              }
              var attr = parseAttributeStatement(graph);
              if (attr) {
                return;
              }
              if (tokenType != TOKENTYPE.IDENTIFIER) {
                throw newSyntaxError("Identifier expected");
              }
              var id2 = token;
              getToken();
              if (token === "=") {
                getToken();
                if (tokenType != TOKENTYPE.IDENTIFIER) {
                  throw newSyntaxError("Identifier expected");
                }
                graph[id2] = token;
                getToken();
              } else {
                parseNodeStatement(graph, id2);
              }
            }
            function parseSubgraph(graph) {
              var subgraph = null;
              if (token === "subgraph") {
                subgraph = {};
                subgraph.type = "subgraph";
                getToken();
                if (tokenType === TOKENTYPE.IDENTIFIER) {
                  subgraph.id = token;
                  getToken();
                }
              }
              if (token === "{") {
                getToken();
                if (!subgraph) {
                  subgraph = {};
                }
                subgraph.parent = graph;
                subgraph.node = graph.node;
                subgraph.edge = graph.edge;
                subgraph.graph = graph.graph;
                parseStatements(subgraph);
                if (token != "}") {
                  throw newSyntaxError("Angle bracket } expected");
                }
                getToken();
                delete subgraph.node;
                delete subgraph.edge;
                delete subgraph.graph;
                delete subgraph.parent;
                if (!graph.subgraphs) {
                  graph.subgraphs = [];
                }
                graph.subgraphs.push(subgraph);
              }
              return subgraph;
            }
            function parseAttributeStatement(graph) {
              if (token === "node") {
                getToken();
                graph.node = parseAttributeList();
                return "node";
              } else if (token === "edge") {
                getToken();
                graph.edge = parseAttributeList();
                return "edge";
              } else if (token === "graph") {
                getToken();
                graph.graph = parseAttributeList();
                return "graph";
              }
              return null;
            }
            function parseNodeStatement(graph, id2) {
              var node = {
                id: id2
              };
              var attr = parseAttributeList();
              if (attr) {
                node.attr = attr;
              }
              addNode2(graph, node);
              parseEdge(graph, id2);
            }
            function parseEdge(graph, from) {
              while (token === "->" || token === "--") {
                var to;
                var type = token;
                getToken();
                var subgraph = parseSubgraph(graph);
                if (subgraph) {
                  to = subgraph;
                } else {
                  if (tokenType != TOKENTYPE.IDENTIFIER) {
                    throw newSyntaxError("Identifier or subgraph expected");
                  }
                  to = token;
                  addNode2(graph, {
                    id: to
                  });
                  getToken();
                }
                var attr = parseAttributeList();
                var edge = createEdge(graph, from, to, type, attr);
                addEdge(graph, edge);
                from = to;
              }
            }
            function parseDirAttribute(attr_names, attr_list) {
              var i;
              if (attr_names.includes("dir")) {
                var idx = {};
                idx.arrows = {};
                for (i = 0; i < attr_list.length; i++) {
                  if (attr_list[i].name === "arrows") {
                    if (attr_list[i].value.to != null) {
                      idx.arrows.to = i;
                    } else if (attr_list[i].value.from != null) {
                      idx.arrows.from = i;
                    } else {
                      throw newSyntaxError("Invalid value of arrows");
                    }
                  } else if (attr_list[i].name === "dir") {
                    idx.dir = i;
                  }
                }
                var dir_type = attr_list[idx.dir].value;
                if (!attr_names.includes("arrows")) {
                  if (dir_type === "both") {
                    attr_list.push({
                      attr: attr_list[idx.dir].attr,
                      name: "arrows",
                      value: { to: { enabled: true } }
                    });
                    idx.arrows.to = attr_list.length - 1;
                    attr_list.push({
                      attr: attr_list[idx.dir].attr,
                      name: "arrows",
                      value: { from: { enabled: true } }
                    });
                    idx.arrows.from = attr_list.length - 1;
                  } else if (dir_type === "forward") {
                    attr_list.push({
                      attr: attr_list[idx.dir].attr,
                      name: "arrows",
                      value: { to: { enabled: true } }
                    });
                    idx.arrows.to = attr_list.length - 1;
                  } else if (dir_type === "back") {
                    attr_list.push({
                      attr: attr_list[idx.dir].attr,
                      name: "arrows",
                      value: { from: { enabled: true } }
                    });
                    idx.arrows.from = attr_list.length - 1;
                  } else if (dir_type === "none") {
                    attr_list.push({
                      attr: attr_list[idx.dir].attr,
                      name: "arrows",
                      value: ""
                    });
                    idx.arrows.to = attr_list.length - 1;
                  } else {
                    throw newSyntaxError('Invalid dir type "' + dir_type + '"');
                  }
                }
                var from_type;
                var to_type;
                if (dir_type === "both") {
                  if (idx.arrows.to && idx.arrows.from) {
                    to_type = attr_list[idx.arrows.to].value.to.type;
                    from_type = attr_list[idx.arrows.from].value.from.type;
                    attr_list[idx.arrows.to] = {
                      attr: attr_list[idx.arrows.to].attr,
                      name: attr_list[idx.arrows.to].name,
                      value: {
                        to: { enabled: true, type: to_type },
                        from: { enabled: true, type: from_type }
                      }
                    };
                    attr_list.splice(idx.arrows.from, 1);
                  } else if (idx.arrows.to) {
                    to_type = attr_list[idx.arrows.to].value.to.type;
                    from_type = "arrow";
                    attr_list[idx.arrows.to] = {
                      attr: attr_list[idx.arrows.to].attr,
                      name: attr_list[idx.arrows.to].name,
                      value: {
                        to: { enabled: true, type: to_type },
                        from: { enabled: true, type: from_type }
                      }
                    };
                  } else if (idx.arrows.from) {
                    to_type = "arrow";
                    from_type = attr_list[idx.arrows.from].value.from.type;
                    attr_list[idx.arrows.from] = {
                      attr: attr_list[idx.arrows.from].attr,
                      name: attr_list[idx.arrows.from].name,
                      value: {
                        to: { enabled: true, type: to_type },
                        from: { enabled: true, type: from_type }
                      }
                    };
                  }
                } else if (dir_type === "back") {
                  if (idx.arrows.to && idx.arrows.from) {
                    to_type = "";
                    from_type = attr_list[idx.arrows.from].value.from.type;
                    attr_list[idx.arrows.from] = {
                      attr: attr_list[idx.arrows.from].attr,
                      name: attr_list[idx.arrows.from].name,
                      value: {
                        to: { enabled: true, type: to_type },
                        from: { enabled: true, type: from_type }
                      }
                    };
                  } else if (idx.arrows.to) {
                    to_type = "";
                    from_type = "arrow";
                    idx.arrows.from = idx.arrows.to;
                    attr_list[idx.arrows.from] = {
                      attr: attr_list[idx.arrows.from].attr,
                      name: attr_list[idx.arrows.from].name,
                      value: {
                        to: { enabled: true, type: to_type },
                        from: { enabled: true, type: from_type }
                      }
                    };
                  } else if (idx.arrows.from) {
                    to_type = "";
                    from_type = attr_list[idx.arrows.from].value.from.type;
                    attr_list[idx.arrows.to] = {
                      attr: attr_list[idx.arrows.from].attr,
                      name: attr_list[idx.arrows.from].name,
                      value: {
                        to: { enabled: true, type: to_type },
                        from: { enabled: true, type: from_type }
                      }
                    };
                  }
                  attr_list[idx.arrows.from] = {
                    attr: attr_list[idx.arrows.from].attr,
                    name: attr_list[idx.arrows.from].name,
                    value: {
                      from: {
                        enabled: true,
                        type: attr_list[idx.arrows.from].value.from.type
                      }
                    }
                  };
                } else if (dir_type === "none") {
                  var idx_arrow;
                  if (idx.arrows.to) {
                    idx_arrow = idx.arrows.to;
                  } else {
                    idx_arrow = idx.arrows.from;
                  }
                  attr_list[idx_arrow] = {
                    attr: attr_list[idx_arrow].attr,
                    name: attr_list[idx_arrow].name,
                    value: ""
                  };
                } else if (dir_type === "forward") {
                  if (idx.arrows.to && idx.arrows.from) {
                    to_type = attr_list[idx.arrows.to].value.to.type;
                    from_type = "";
                    attr_list[idx.arrows.to] = {
                      attr: attr_list[idx.arrows.to].attr,
                      name: attr_list[idx.arrows.to].name,
                      value: {
                        to: { enabled: true, type: to_type },
                        from: { enabled: true, type: from_type }
                      }
                    };
                  } else if (idx.arrows.to) {
                    to_type = attr_list[idx.arrows.to].value.to.type;
                    from_type = "";
                    attr_list[idx.arrows.to] = {
                      attr: attr_list[idx.arrows.to].attr,
                      name: attr_list[idx.arrows.to].name,
                      value: {
                        to: { enabled: true, type: to_type },
                        from: { enabled: true, type: from_type }
                      }
                    };
                  } else if (idx.arrows.from) {
                    to_type = "arrow";
                    from_type = "";
                    idx.arrows.to = idx.arrows.from;
                    attr_list[idx.arrows.to] = {
                      attr: attr_list[idx.arrows.to].attr,
                      name: attr_list[idx.arrows.to].name,
                      value: {
                        to: { enabled: true, type: to_type },
                        from: { enabled: true, type: from_type }
                      }
                    };
                  }
                  attr_list[idx.arrows.to] = {
                    attr: attr_list[idx.arrows.to].attr,
                    name: attr_list[idx.arrows.to].name,
                    value: {
                      to: {
                        enabled: true,
                        type: attr_list[idx.arrows.to].value.to.type
                      }
                    }
                  };
                } else {
                  throw newSyntaxError('Invalid dir type "' + dir_type + '"');
                }
                attr_list.splice(idx.dir, 1);
              }
              return attr_list;
            }
            function parseAttributeList() {
              var i;
              var attr = null;
              var edgeStyles = {
                dashed: true,
                solid: false,
                dotted: [1, 5]
              };
              var arrowTypes = {
                dot: "circle",
                box: "box",
                crow: "crow",
                curve: "curve",
                icurve: "inv_curve",
                normal: "triangle",
                inv: "inv_triangle",
                diamond: "diamond",
                tee: "bar",
                vee: "vee"
              };
              var attr_list = new Array();
              var attr_names = new Array();
              while (token === "[") {
                getToken();
                attr = {};
                while (token !== "" && token != "]") {
                  if (tokenType != TOKENTYPE.IDENTIFIER) {
                    throw newSyntaxError("Attribute name expected");
                  }
                  var name = token;
                  getToken();
                  if (token != "=") {
                    throw newSyntaxError("Equal sign = expected");
                  }
                  getToken();
                  if (tokenType != TOKENTYPE.IDENTIFIER) {
                    throw newSyntaxError("Attribute value expected");
                  }
                  var value = token;
                  if (name === "style") {
                    value = edgeStyles[value];
                  }
                  var arrowType;
                  if (name === "arrowhead") {
                    arrowType = arrowTypes[value];
                    name = "arrows";
                    value = { to: { enabled: true, type: arrowType } };
                  }
                  if (name === "arrowtail") {
                    arrowType = arrowTypes[value];
                    name = "arrows";
                    value = { from: { enabled: true, type: arrowType } };
                  }
                  attr_list.push({ attr, name, value });
                  attr_names.push(name);
                  getToken();
                  if (token == ",") {
                    getToken();
                  }
                }
                if (token != "]") {
                  throw newSyntaxError("Bracket ] expected");
                }
                getToken();
              }
              attr_list = parseDirAttribute(attr_names, attr_list);
              var nof_attr_list;
              if (attr_names.includes("penwidth")) {
                var tmp_attr_list = [];
                nof_attr_list = attr_list.length;
                for (i = 0; i < nof_attr_list; i++) {
                  if (attr_list[i].name !== "width") {
                    if (attr_list[i].name === "penwidth") {
                      attr_list[i].name = "width";
                    }
                    tmp_attr_list.push(attr_list[i]);
                  }
                }
                attr_list = tmp_attr_list;
              }
              nof_attr_list = attr_list.length;
              for (i = 0; i < nof_attr_list; i++) {
                setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);
              }
              return attr;
            }
            function newSyntaxError(message) {
              return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index + ")");
            }
            function chop(text, maxLength) {
              return text.length <= maxLength ? text : text.substr(0, 27) + "...";
            }
            function forEach2(array1, array2, fn) {
              if (Array.isArray(array1)) {
                array1.forEach(function(elem1) {
                  if (Array.isArray(array2)) {
                    array2.forEach(function(elem2) {
                      fn(elem1, elem2);
                    });
                  } else {
                    fn(elem1, array2);
                  }
                });
              } else {
                if (Array.isArray(array2)) {
                  array2.forEach(function(elem2) {
                    fn(array1, elem2);
                  });
                } else {
                  fn(array1, array2);
                }
              }
            }
            function setProp(object, path, value) {
              var names = path.split(".");
              var prop = names.pop();
              var obj = object;
              for (var i = 0; i < names.length; i++) {
                var name = names[i];
                if (!(name in obj)) {
                  obj[name] = {};
                }
                obj = obj[name];
              }
              obj[prop] = value;
              return object;
            }
            function convertAttr(attr, mapping) {
              var converted = {};
              for (var prop in attr) {
                if (attr.hasOwnProperty(prop)) {
                  var visProp = mapping[prop];
                  if (Array.isArray(visProp)) {
                    visProp.forEach(function(visPropI) {
                      setProp(converted, visPropI, attr[prop]);
                    });
                  } else if (typeof visProp === "string") {
                    setProp(converted, visProp, attr[prop]);
                  } else {
                    setProp(converted, prop, attr[prop]);
                  }
                }
              }
              return converted;
            }
            function DOTToGraph(data) {
              var dotData = parseDOT(data);
              var graphData = {
                nodes: [],
                edges: [],
                options: {}
              };
              if (dotData.nodes) {
                dotData.nodes.forEach(function(dotNode) {
                  var graphNode = {
                    id: dotNode.id,
                    label: String(dotNode.label || dotNode.id)
                  };
                  merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));
                  if (graphNode.image) {
                    graphNode.shape = "image";
                  }
                  graphData.nodes.push(graphNode);
                });
              }
              if (dotData.edges) {
                var convertEdge = function convertEdge2(dotEdge) {
                  var graphEdge = {
                    from: dotEdge.from,
                    to: dotEdge.to
                  };
                  merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));
                  if (graphEdge.arrows == null && dotEdge.type === "->") {
                    graphEdge.arrows = "to";
                  }
                  return graphEdge;
                };
                dotData.edges.forEach(function(dotEdge) {
                  var from, to;
                  if (dotEdge.from instanceof Object) {
                    from = dotEdge.from.nodes;
                  } else {
                    from = {
                      id: dotEdge.from
                    };
                  }
                  if (dotEdge.to instanceof Object) {
                    to = dotEdge.to.nodes;
                  } else {
                    to = {
                      id: dotEdge.to
                    };
                  }
                  if (dotEdge.from instanceof Object && dotEdge.from.edges) {
                    dotEdge.from.edges.forEach(function(subEdge) {
                      var graphEdge = convertEdge(subEdge);
                      graphData.edges.push(graphEdge);
                    });
                  }
                  forEach2(from, to, function(from2, to2) {
                    var subEdge = createEdge(graphData, from2.id, to2.id, dotEdge.type, dotEdge.attr);
                    var graphEdge = convertEdge(subEdge);
                    graphData.edges.push(graphEdge);
                  });
                  if (dotEdge.to instanceof Object && dotEdge.to.edges) {
                    dotEdge.to.edges.forEach(function(subEdge) {
                      var graphEdge = convertEdge(subEdge);
                      graphData.edges.push(graphEdge);
                    });
                  }
                });
              }
              if (dotData.attr) {
                graphData.options = dotData.attr;
              }
              return graphData;
            }
            exports2.parseDOT = parseDOT;
            exports2.DOTToGraph = DOTToGraph;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function parseGephi(gephiJSON, optionsObj) {
              var edges2 = [];
              var nodes2 = [];
              var options = {
                edges: {
                  inheritColor: false
                },
                nodes: {
                  fixed: false,
                  parseColor: false
                }
              };
              if (optionsObj !== void 0) {
                if (optionsObj.fixed !== void 0) {
                  options.nodes.fixed = optionsObj.fixed;
                }
                if (optionsObj.parseColor !== void 0) {
                  options.nodes.parseColor = optionsObj.parseColor;
                }
                if (optionsObj.inheritColor !== void 0) {
                  options.edges.inheritColor = optionsObj.inheritColor;
                }
              }
              var gEdges = gephiJSON.edges;
              var gNodes = gephiJSON.nodes;
              for (var i = 0; i < gEdges.length; i++) {
                var edge = {};
                var gEdge = gEdges[i];
                edge["id"] = gEdge.id;
                edge["from"] = gEdge.source;
                edge["to"] = gEdge.target;
                edge["attributes"] = gEdge.attributes;
                edge["label"] = gEdge.label;
                edge["title"] = gEdge.attributes !== void 0 ? gEdge.attributes.title : void 0;
                if (gEdge["type"] === "Directed") {
                  edge["arrows"] = "to";
                }
                if (gEdge.color && options.inheritColor === false) {
                  edge["color"] = gEdge.color;
                }
                edges2.push(edge);
              }
              for (var j = 0; j < gNodes.length; j++) {
                var node = {};
                var gNode = gNodes[j];
                node["id"] = gNode.id;
                node["attributes"] = gNode.attributes;
                node["x"] = gNode.x;
                node["y"] = gNode.y;
                node["label"] = gNode.label;
                node["title"] = gNode.attributes !== void 0 ? gNode.attributes.title : gNode.title;
                if (options.nodes.parseColor === true) {
                  node["color"] = gNode.color;
                } else {
                  node["color"] = gNode.color !== void 0 ? {
                    background: gNode.color,
                    border: gNode.color,
                    highlight: { background: gNode.color, border: gNode.color },
                    hover: { background: gNode.color, border: gNode.color }
                  } : void 0;
                }
                node["size"] = gNode.size;
                node["fixed"] = options.nodes.fixed && gNode.x !== void 0 && gNode.y !== void 0;
                nodes2.push(node);
              }
              return { nodes: nodes2, edges: edges2 };
            }
            exports2.parseGephi = parseGephi;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _CachedImage = __webpack_require__(133);
            var _CachedImage2 = _interopRequireDefault(_CachedImage);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Images = function() {
              function Images2(callback) {
                (0, _classCallCheck3["default"])(this, Images2);
                this.images = {};
                this.imageBroken = {};
                this.callback = callback;
              }
              (0, _createClass3["default"])(Images2, [{
                key: "_tryloadBrokenUrl",
                value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
                  if (url === void 0 || imageToLoadBrokenUrlOn === void 0)
                    return;
                  if (brokenUrl === void 0) {
                    console.warn("No broken url image defined");
                    return;
                  }
                  imageToLoadBrokenUrlOn.onerror = function() {
                    console.error("Could not load brokenImage:", brokenUrl);
                  };
                  imageToLoadBrokenUrlOn.image.src = brokenUrl;
                }
              }, {
                key: "_redrawWithImage",
                value: function _redrawWithImage(imageToRedrawWith) {
                  if (this.callback) {
                    this.callback(imageToRedrawWith);
                  }
                }
              }, {
                key: "load",
                value: function load2(url, brokenUrl) {
                  var _this = this;
                  var cachedImage = this.images[url];
                  if (cachedImage)
                    return cachedImage;
                  var img = new _CachedImage2["default"]();
                  this.images[url] = img;
                  img.image.onload = function() {
                    _this._fixImageCoordinates(img.image);
                    img.init();
                    _this._redrawWithImage(img);
                  };
                  img.image.onerror = function() {
                    console.error("Could not load image:", url);
                    _this._tryloadBrokenUrl(url, brokenUrl, img);
                  };
                  img.image.src = url;
                  return img;
                }
              }, {
                key: "_fixImageCoordinates",
                value: function _fixImageCoordinates(imageToCache) {
                  if (imageToCache.width === 0) {
                    document.body.appendChild(imageToCache);
                    imageToCache.width = imageToCache.offsetWidth;
                    imageToCache.height = imageToCache.offsetHeight;
                    document.body.removeChild(imageToCache);
                  }
                }
              }]);
              return Images2;
            }();
            exports2["default"] = Images;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(15);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var ComponentUtil = __webpack_require__(35)["default"];
            var LabelSplitter = __webpack_require__(139)["default"];
            var multiFontStyle = ["bold", "ital", "boldital", "mono"];
            var Label = function() {
              function Label2(body, options) {
                var edgelabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                (0, _classCallCheck3["default"])(this, Label2);
                this.body = body;
                this.pointToSelf = false;
                this.baseSize = void 0;
                this.fontOptions = {};
                this.setOptions(options);
                this.size = { top: 0, left: 0, width: 0, height: 0, yLine: 0 };
                this.isEdgeLabel = edgelabel;
              }
              (0, _createClass3["default"])(Label2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.elementOptions = options;
                  this.initFontOptions(options.font);
                  if (ComponentUtil.isValidLabel(options.label)) {
                    this.labelDirty = true;
                  } else {
                    options.label = void 0;
                  }
                  if (options.font !== void 0 && options.font !== null) {
                    if (typeof options.font === "string") {
                      this.baseSize = this.fontOptions.size;
                    } else if ((0, _typeof3["default"])(options.font) === "object") {
                      var size = options.font.size;
                      if (size !== void 0) {
                        this.baseSize = size;
                      }
                    }
                  }
                }
              }, {
                key: "initFontOptions",
                value: function initFontOptions(newFontOptions) {
                  var _this = this;
                  util.forEach(multiFontStyle, function(style) {
                    _this.fontOptions[style] = {};
                  });
                  if (Label2.parseFontString(this.fontOptions, newFontOptions)) {
                    this.fontOptions.vadjust = 0;
                    return;
                  }
                  util.forEach(newFontOptions, function(prop, n) {
                    if (prop !== void 0 && prop !== null && (typeof prop === "undefined" ? "undefined" : (0, _typeof3["default"])(prop)) !== "object") {
                      _this.fontOptions[n] = prop;
                    }
                  });
                }
              }, {
                key: "constrain",
                value: function constrain(pile) {
                  var fontOptions = {
                    constrainWidth: false,
                    maxWdt: -1,
                    minWdt: -1,
                    constrainHeight: false,
                    minHgt: -1,
                    valign: "middle"
                  };
                  var widthConstraint = util.topMost(pile, "widthConstraint");
                  if (typeof widthConstraint === "number") {
                    fontOptions.maxWdt = Number(widthConstraint);
                    fontOptions.minWdt = Number(widthConstraint);
                  } else if ((typeof widthConstraint === "undefined" ? "undefined" : (0, _typeof3["default"])(widthConstraint)) === "object") {
                    var widthConstraintMaximum = util.topMost(pile, ["widthConstraint", "maximum"]);
                    if (typeof widthConstraintMaximum === "number") {
                      fontOptions.maxWdt = Number(widthConstraintMaximum);
                    }
                    var widthConstraintMinimum = util.topMost(pile, ["widthConstraint", "minimum"]);
                    if (typeof widthConstraintMinimum === "number") {
                      fontOptions.minWdt = Number(widthConstraintMinimum);
                    }
                  }
                  var heightConstraint = util.topMost(pile, "heightConstraint");
                  if (typeof heightConstraint === "number") {
                    fontOptions.minHgt = Number(heightConstraint);
                  } else if ((typeof heightConstraint === "undefined" ? "undefined" : (0, _typeof3["default"])(heightConstraint)) === "object") {
                    var heightConstraintMinimum = util.topMost(pile, ["heightConstraint", "minimum"]);
                    if (typeof heightConstraintMinimum === "number") {
                      fontOptions.minHgt = Number(heightConstraintMinimum);
                    }
                    var heightConstraintValign = util.topMost(pile, ["heightConstraint", "valign"]);
                    if (typeof heightConstraintValign === "string") {
                      if (heightConstraintValign === "top" || heightConstraintValign === "bottom") {
                        fontOptions.valign = heightConstraintValign;
                      }
                    }
                  }
                  return fontOptions;
                }
              }, {
                key: "update",
                value: function update(options, pile) {
                  this.setOptions(options, true);
                  this.propagateFonts(pile);
                  util.deepExtend(this.fontOptions, this.constrain(pile));
                  this.fontOptions.chooser = ComponentUtil.choosify("label", pile);
                }
              }, {
                key: "adjustSizes",
                value: function adjustSizes(margins) {
                  var widthBias = margins ? margins.right + margins.left : 0;
                  if (this.fontOptions.constrainWidth) {
                    this.fontOptions.maxWdt -= widthBias;
                    this.fontOptions.minWdt -= widthBias;
                  }
                  var heightBias = margins ? margins.top + margins.bottom : 0;
                  if (this.fontOptions.constrainHeight) {
                    this.fontOptions.minHgt -= heightBias;
                  }
                }
              }, {
                key: "addFontOptionsToPile",
                value: function addFontOptionsToPile(dstPile, srcPile) {
                  for (var i = 0; i < srcPile.length; ++i) {
                    this.addFontToPile(dstPile, srcPile[i]);
                  }
                }
              }, {
                key: "addFontToPile",
                value: function addFontToPile(pile, options) {
                  if (options === void 0)
                    return;
                  if (options.font === void 0 || options.font === null)
                    return;
                  var item = options.font;
                  pile.push(item);
                }
              }, {
                key: "getBasicOptions",
                value: function getBasicOptions(pile) {
                  var ret = {};
                  for (var n = 0; n < pile.length; ++n) {
                    var fontOptions = pile[n];
                    var tmpShorthand = {};
                    if (Label2.parseFontString(tmpShorthand, fontOptions)) {
                      fontOptions = tmpShorthand;
                    }
                    util.forEach(fontOptions, function(opt, name) {
                      if (opt === void 0)
                        return;
                      if (ret.hasOwnProperty(name))
                        return;
                      if (multiFontStyle.indexOf(name) !== -1) {
                        ret[name] = {};
                      } else {
                        ret[name] = opt;
                      }
                    });
                  }
                  return ret;
                }
              }, {
                key: "getFontOption",
                value: function getFontOption(pile, multiName, option) {
                  var multiFont = void 0;
                  for (var n = 0; n < pile.length; ++n) {
                    var fontOptions = pile[n];
                    if (fontOptions.hasOwnProperty(multiName)) {
                      multiFont = fontOptions[multiName];
                      if (multiFont === void 0 || multiFont === null)
                        continue;
                      var tmpShorthand = {};
                      if (Label2.parseFontString(tmpShorthand, multiFont)) {
                        multiFont = tmpShorthand;
                      }
                      if (multiFont.hasOwnProperty(option)) {
                        return multiFont[option];
                      }
                    }
                  }
                  if (this.fontOptions.hasOwnProperty(option)) {
                    return this.fontOptions[option];
                  }
                  throw new Error("Did not find value for multi-font for property: '" + option + "'");
                }
              }, {
                key: "getFontOptions",
                value: function getFontOptions(pile, multiName) {
                  var result2 = {};
                  var optionNames = ["color", "size", "face", "mod", "vadjust"];
                  for (var i = 0; i < optionNames.length; ++i) {
                    var mod = optionNames[i];
                    result2[mod] = this.getFontOption(pile, multiName, mod);
                  }
                  return result2;
                }
              }, {
                key: "propagateFonts",
                value: function propagateFonts(pile) {
                  var _this2 = this;
                  var fontPile = [];
                  this.addFontOptionsToPile(fontPile, pile);
                  this.fontOptions = this.getBasicOptions(fontPile);
                  var _loop = function _loop2(i2) {
                    var mod = multiFontStyle[i2];
                    var modOptions = _this2.fontOptions[mod];
                    var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod);
                    util.forEach(tmpMultiFontOptions, function(option, n) {
                      modOptions[n] = option;
                    });
                    modOptions.size = Number(modOptions.size);
                    modOptions.vadjust = Number(modOptions.vadjust);
                  };
                  for (var i = 0; i < multiFontStyle.length; ++i) {
                    _loop(i);
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover) {
                  var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "middle";
                  if (this.elementOptions.label === void 0)
                    return;
                  var viewFontSize = this.fontOptions.size * this.body.view.scale;
                  if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1)
                    return;
                  if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {
                    viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;
                  }
                  this.calculateLabelSize(ctx, selected, hover, x, y, baseline);
                  this._drawBackground(ctx);
                  this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);
                }
              }, {
                key: "_drawBackground",
                value: function _drawBackground(ctx) {
                  if (this.fontOptions.background !== void 0 && this.fontOptions.background !== "none") {
                    ctx.fillStyle = this.fontOptions.background;
                    var size = this.getSize();
                    ctx.fillRect(size.left, size.top, size.width, size.height);
                  }
                }
              }, {
                key: "_drawText",
                value: function _drawText(ctx, x, y) {
                  var baseline = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "middle";
                  var viewFontSize = arguments[4];
                  ;
                  var _setAlignment2 = this._setAlignment(ctx, x, y, baseline);
                  var _setAlignment3 = (0, _slicedToArray3["default"])(_setAlignment2, 2);
                  x = _setAlignment3[0];
                  y = _setAlignment3[1];
                  ctx.textAlign = "left";
                  x = x - this.size.width / 2;
                  if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {
                    if (this.fontOptions.valign === "top") {
                      y -= (this.size.height - this.size.labelHeight) / 2;
                    }
                    if (this.fontOptions.valign === "bottom") {
                      y += (this.size.height - this.size.labelHeight) / 2;
                    }
                  }
                  for (var i = 0; i < this.lineCount; i++) {
                    var line = this.lines[i];
                    if (line && line.blocks) {
                      var width = 0;
                      if (this.isEdgeLabel || this.fontOptions.align === "center") {
                        width += (this.size.width - line.width) / 2;
                      } else if (this.fontOptions.align === "right") {
                        width += this.size.width - line.width;
                      }
                      for (var j = 0; j < line.blocks.length; j++) {
                        var block = line.blocks[j];
                        ctx.font = block.font;
                        var _getColor2 = this._getColor(block.color, viewFontSize, block.strokeColor), _getColor3 = (0, _slicedToArray3["default"])(_getColor2, 2), fontColor = _getColor3[0], strokeColor = _getColor3[1];
                        if (block.strokeWidth > 0) {
                          ctx.lineWidth = block.strokeWidth;
                          ctx.strokeStyle = strokeColor;
                          ctx.lineJoin = "round";
                        }
                        ctx.fillStyle = fontColor;
                        if (block.strokeWidth > 0) {
                          ctx.strokeText(block.text, x + width, y + block.vadjust);
                        }
                        ctx.fillText(block.text, x + width, y + block.vadjust);
                        width += block.width;
                      }
                      y += line.height;
                    }
                  }
                }
              }, {
                key: "_setAlignment",
                value: function _setAlignment(ctx, x, y, baseline) {
                  if (this.isEdgeLabel && this.fontOptions.align !== "horizontal" && this.pointToSelf === false) {
                    x = 0;
                    y = 0;
                    var lineMargin = 2;
                    if (this.fontOptions.align === "top") {
                      ctx.textBaseline = "alphabetic";
                      y -= 2 * lineMargin;
                    } else if (this.fontOptions.align === "bottom") {
                      ctx.textBaseline = "hanging";
                      y += 2 * lineMargin;
                    } else {
                      ctx.textBaseline = "middle";
                    }
                  } else {
                    ctx.textBaseline = baseline;
                  }
                  return [x, y];
                }
              }, {
                key: "_getColor",
                value: function _getColor(color, viewFontSize, initialStrokeColor) {
                  var fontColor = color || "#000000";
                  var strokeColor = initialStrokeColor || "#ffffff";
                  if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {
                    var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));
                    fontColor = util.overrideOpacity(fontColor, opacity);
                    strokeColor = util.overrideOpacity(strokeColor, opacity);
                  }
                  return [fontColor, strokeColor];
                }
              }, {
                key: "getTextSize",
                value: function getTextSize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  this._processLabel(ctx, selected, hover);
                  return {
                    width: this.size.width,
                    height: this.size.height,
                    lineCount: this.lineCount
                  };
                }
              }, {
                key: "getSize",
                value: function getSize() {
                  var lineMargin = 2;
                  var x = this.size.left;
                  var y = this.size.top - 0.5 * lineMargin;
                  if (this.isEdgeLabel) {
                    var x2 = -this.size.width * 0.5;
                    switch (this.fontOptions.align) {
                      case "middle":
                        x = x2;
                        y = -this.size.height * 0.5;
                        break;
                      case "top":
                        x = x2;
                        y = -(this.size.height + lineMargin);
                        break;
                      case "bottom":
                        x = x2;
                        y = lineMargin;
                        break;
                    }
                  }
                  var ret = {
                    left: x,
                    top: y,
                    width: this.size.width,
                    height: this.size.height
                  };
                  return ret;
                }
              }, {
                key: "calculateLabelSize",
                value: function calculateLabelSize(ctx, selected, hover) {
                  var x = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                  var y = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
                  var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "middle";
                  this._processLabel(ctx, selected, hover);
                  this.size.left = x - this.size.width * 0.5;
                  this.size.top = y - this.size.height * 0.5;
                  this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;
                  if (baseline === "hanging") {
                    this.size.top += 0.5 * this.fontOptions.size;
                    this.size.top += 4;
                    this.size.yLine += 4;
                  }
                }
              }, {
                key: "getFormattingValues",
                value: function getFormattingValues(ctx, selected, hover, mod) {
                  var getValue = function getValue2(fontOptions, mod2, option) {
                    if (mod2 === "normal") {
                      if (option === "mod")
                        return "";
                      return fontOptions[option];
                    }
                    if (fontOptions[mod2][option] !== void 0) {
                      return fontOptions[mod2][option];
                    } else {
                      return fontOptions[option];
                    }
                  };
                  var values = {
                    color: getValue(this.fontOptions, mod, "color"),
                    size: getValue(this.fontOptions, mod, "size"),
                    face: getValue(this.fontOptions, mod, "face"),
                    mod: getValue(this.fontOptions, mod, "mod"),
                    vadjust: getValue(this.fontOptions, mod, "vadjust"),
                    strokeWidth: this.fontOptions.strokeWidth,
                    strokeColor: this.fontOptions.strokeColor
                  };
                  if (selected || hover) {
                    if (mod === "normal" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {
                      values.mod = "bold";
                    } else {
                      if (typeof this.fontOptions.chooser === "function") {
                        this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);
                      }
                    }
                  }
                  var fontString = "";
                  if (values.mod !== void 0 && values.mod !== "") {
                    fontString += values.mod + " ";
                  }
                  fontString += values.size + "px " + values.face;
                  ctx.font = fontString.replace(/"/g, "");
                  values.font = ctx.font;
                  values.height = values.size;
                  return values;
                }
              }, {
                key: "differentState",
                value: function differentState(selected, hover) {
                  return selected !== this.selectedState || hover !== this.hoverState;
                }
              }, {
                key: "_processLabelText",
                value: function _processLabelText(ctx, selected, hover, inText) {
                  var splitter = new LabelSplitter(ctx, this, selected, hover);
                  return splitter.process(inText);
                }
              }, {
                key: "_processLabel",
                value: function _processLabel(ctx, selected, hover) {
                  if (this.labelDirty === false && !this.differentState(selected, hover))
                    return;
                  var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);
                  if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {
                    state.width = this.fontOptions.minWdt;
                  }
                  this.size.labelHeight = state.height;
                  if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {
                    state.height = this.fontOptions.minHgt;
                  }
                  this.lines = state.lines;
                  this.lineCount = state.lines.length;
                  this.size.width = state.width;
                  this.size.height = state.height;
                  this.selectedState = selected;
                  this.hoverState = hover;
                  this.labelDirty = false;
                }
              }, {
                key: "visible",
                value: function visible() {
                  if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === void 0) {
                    return false;
                  }
                  var viewFontSize = this.fontOptions.size * this.body.view.scale;
                  if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {
                    return false;
                  }
                  return true;
                }
              }], [{
                key: "parseFontString",
                value: function parseFontString(outOptions, inOptions) {
                  if (!inOptions || typeof inOptions !== "string")
                    return false;
                  var newOptionsArray = inOptions.split(" ");
                  outOptions.size = newOptionsArray[0].replace("px", "");
                  outOptions.face = newOptionsArray[1];
                  outOptions.color = newOptionsArray[2];
                  return true;
                }
              }]);
              return Label2;
            }();
            exports2["default"] = Label;
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(141), __esModule: true };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(15);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var EndPoints = __webpack_require__(80)["default"];
            var EdgeBase = function() {
              function EdgeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, EdgeBase2);
                this.body = body;
                this.labelModule = labelModule;
                this.options = {};
                this.setOptions(options);
                this.colorDirty = true;
                this.color = {};
                this.selectionWidth = 2;
                this.hoverWidth = 1.5;
                this.fromPoint = this.from;
                this.toPoint = this.to;
              }
              (0, _createClass3["default"])(EdgeBase2, [{
                key: "connect",
                value: function connect() {
                  this.from = this.body.nodes[this.options.from];
                  this.to = this.body.nodes[this.options.to];
                }
              }, {
                key: "cleanup",
                value: function cleanup() {
                  return false;
                }
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                  this.from = this.body.nodes[this.options.from];
                  this.to = this.body.nodes[this.options.to];
                  this.id = this.options.id;
                }
              }, {
                key: "drawLine",
                value: function drawLine(ctx, values, selected, hover, viaNode) {
                  ctx.strokeStyle = this.getColor(ctx, values, selected, hover);
                  ctx.lineWidth = values.width;
                  if (values.dashes !== false) {
                    this._drawDashedLine(ctx, values, viaNode);
                  } else {
                    this._drawLine(ctx, values, viaNode);
                  }
                }
              }, {
                key: "_drawLine",
                value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {
                  if (this.from != this.to) {
                    this._line(ctx, values, viaNode, fromPoint, toPoint);
                  } else {
                    var _getCircleData2 = this._getCircleData(ctx), _getCircleData3 = (0, _slicedToArray3["default"])(_getCircleData2, 3), x = _getCircleData3[0], y = _getCircleData3[1], radius = _getCircleData3[2];
                    this._circle(ctx, values, x, y, radius);
                  }
                }
              }, {
                key: "_drawDashedLine",
                value: function _drawDashedLine(ctx, values, viaNode, fromPoint, toPoint) {
                  ctx.lineCap = "round";
                  var pattern = [5, 5];
                  if (Array.isArray(values.dashes) === true) {
                    pattern = values.dashes;
                  }
                  if (ctx.setLineDash !== void 0) {
                    ctx.save();
                    ctx.setLineDash(pattern);
                    ctx.lineDashOffset = 0;
                    if (this.from != this.to) {
                      this._line(ctx, values, viaNode);
                    } else {
                      var _getCircleData4 = this._getCircleData(ctx), _getCircleData5 = (0, _slicedToArray3["default"])(_getCircleData4, 3), x = _getCircleData5[0], y = _getCircleData5[1], radius = _getCircleData5[2];
                      this._circle(ctx, values, x, y, radius);
                    }
                    ctx.setLineDash([0]);
                    ctx.lineDashOffset = 0;
                    ctx.restore();
                  } else {
                    if (this.from != this.to) {
                      ctx.dashedLine(this.from.x, this.from.y, this.to.x, this.to.y, pattern);
                    } else {
                      var _getCircleData6 = this._getCircleData(ctx), _getCircleData7 = (0, _slicedToArray3["default"])(_getCircleData6, 3), _x = _getCircleData7[0], _y = _getCircleData7[1], _radius = _getCircleData7[2];
                      this._circle(ctx, values, _x, _y, _radius);
                    }
                    this.enableShadow(ctx, values);
                    ctx.stroke();
                    this.disableShadow(ctx, values);
                  }
                }
              }, {
                key: "findBorderPosition",
                value: function findBorderPosition(nearNode, ctx, options) {
                  if (this.from != this.to) {
                    return this._findBorderPosition(nearNode, ctx, options);
                  } else {
                    return this._findBorderPositionCircle(nearNode, ctx, options);
                  }
                }
              }, {
                key: "findBorderPositions",
                value: function findBorderPositions(ctx) {
                  var from = {};
                  var to = {};
                  if (this.from != this.to) {
                    from = this._findBorderPosition(this.from, ctx);
                    to = this._findBorderPosition(this.to, ctx);
                  } else {
                    var _getCircleData$slice = this._getCircleData(ctx).slice(0, 2), _getCircleData$slice2 = (0, _slicedToArray3["default"])(_getCircleData$slice, 2), x = _getCircleData$slice2[0], y = _getCircleData$slice2[1];
                    from = this._findBorderPositionCircle(this.from, ctx, {
                      x,
                      y,
                      low: 0.25,
                      high: 0.6,
                      direction: -1
                    });
                    to = this._findBorderPositionCircle(this.from, ctx, {
                      x,
                      y,
                      low: 0.6,
                      high: 0.8,
                      direction: 1
                    });
                  }
                  return { from, to };
                }
              }, {
                key: "_getCircleData",
                value: function _getCircleData(ctx) {
                  var x = void 0, y = void 0;
                  var node = this.from;
                  var radius = this.options.selfReferenceSize;
                  if (ctx !== void 0) {
                    if (node.shape.width === void 0) {
                      node.shape.resize(ctx);
                    }
                  }
                  if (node.shape.width > node.shape.height) {
                    x = node.x + node.shape.width * 0.5;
                    y = node.y - radius;
                  } else {
                    x = node.x + radius;
                    y = node.y - node.shape.height * 0.5;
                  }
                  return [x, y, radius];
                }
              }, {
                key: "_pointOnCircle",
                value: function _pointOnCircle(x, y, radius, percentage) {
                  var angle = percentage * 2 * Math.PI;
                  return {
                    x: x + radius * Math.cos(angle),
                    y: y - radius * Math.sin(angle)
                  };
                }
              }, {
                key: "_findBorderPositionCircle",
                value: function _findBorderPositionCircle(node, ctx, options) {
                  var x = options.x;
                  var y = options.y;
                  var low = options.low;
                  var high = options.high;
                  var direction = options.direction;
                  var maxIterations = 10;
                  var iteration = 0;
                  var radius = this.options.selfReferenceSize;
                  var pos = void 0, angle = void 0, distanceToBorder = void 0, distanceToPoint = void 0, difference = void 0;
                  var threshold = 0.05;
                  var middle = (low + high) * 0.5;
                  while (low <= high && iteration < maxIterations) {
                    middle = (low + high) * 0.5;
                    pos = this._pointOnCircle(x, y, radius, middle);
                    angle = Math.atan2(node.y - pos.y, node.x - pos.x);
                    distanceToBorder = node.distanceToBorder(ctx, angle);
                    distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
                    difference = distanceToBorder - distanceToPoint;
                    if (Math.abs(difference) < threshold) {
                      break;
                    } else if (difference > 0) {
                      if (direction > 0) {
                        low = middle;
                      } else {
                        high = middle;
                      }
                    } else {
                      if (direction > 0) {
                        high = middle;
                      } else {
                        low = middle;
                      }
                    }
                    iteration++;
                  }
                  pos.t = middle;
                  return pos;
                }
              }, {
                key: "getLineWidth",
                value: function getLineWidth(selected, hover) {
                  if (selected === true) {
                    return Math.max(this.selectionWidth, 0.3 / this.body.view.scale);
                  } else {
                    if (hover === true) {
                      return Math.max(this.hoverWidth, 0.3 / this.body.view.scale);
                    } else {
                      return Math.max(this.options.width, 0.3 / this.body.view.scale);
                    }
                  }
                }
              }, {
                key: "getColor",
                value: function getColor(ctx, values, selected, hover) {
                  if (values.inheritsColor !== false) {
                    if (values.inheritsColor === "both" && this.from.id !== this.to.id) {
                      var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
                      var fromColor = void 0, toColor = void 0;
                      fromColor = this.from.options.color.highlight.border;
                      toColor = this.to.options.color.highlight.border;
                      if (this.from.selected === false && this.to.selected === false) {
                        fromColor = util.overrideOpacity(this.from.options.color.border, values.opacity);
                        toColor = util.overrideOpacity(this.to.options.color.border, values.opacity);
                      } else if (this.from.selected === true && this.to.selected === false) {
                        toColor = this.to.options.color.border;
                      } else if (this.from.selected === false && this.to.selected === true) {
                        fromColor = this.from.options.color.border;
                      }
                      grd.addColorStop(0, fromColor);
                      grd.addColorStop(1, toColor);
                      return grd;
                    }
                    if (values.inheritsColor === "to") {
                      return util.overrideOpacity(this.to.options.color.border, values.opacity);
                    } else {
                      return util.overrideOpacity(this.from.options.color.border, values.opacity);
                    }
                  } else {
                    return util.overrideOpacity(values.color, values.opacity);
                  }
                }
              }, {
                key: "_circle",
                value: function _circle(ctx, values, x, y, radius) {
                  this.enableShadow(ctx, values);
                  ctx.beginPath();
                  ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
                  ctx.stroke();
                  this.disableShadow(ctx, values);
                }
              }, {
                key: "getDistanceToEdge",
                value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3, via, values) {
                  var returnValue = 0;
                  if (this.from != this.to) {
                    returnValue = this._getDistanceToEdge(x1, y1, x2, y2, x3, y3, via);
                  } else {
                    var _getCircleData8 = this._getCircleData(void 0), _getCircleData9 = (0, _slicedToArray3["default"])(_getCircleData8, 3), x = _getCircleData9[0], y = _getCircleData9[1], radius = _getCircleData9[2];
                    var dx = x - x3;
                    var dy = y - y3;
                    returnValue = Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
                  }
                  return returnValue;
                }
              }, {
                key: "_getDistanceToLine",
                value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
                  var px = x2 - x1;
                  var py = y2 - y1;
                  var something = px * px + py * py;
                  var u = ((x3 - x1) * px + (y3 - y1) * py) / something;
                  if (u > 1) {
                    u = 1;
                  } else if (u < 0) {
                    u = 0;
                  }
                  var x = x1 + u * px;
                  var y = y1 + u * py;
                  var dx = x - x3;
                  var dy = y - y3;
                  return Math.sqrt(dx * dx + dy * dy);
                }
              }, {
                key: "getArrowData",
                value: function getArrowData(ctx, position, viaNode, selected, hover, values) {
                  var angle = void 0;
                  var arrowPoint = void 0;
                  var node1 = void 0;
                  var node2 = void 0;
                  var guideOffset = void 0;
                  var scaleFactor = void 0;
                  var type = void 0;
                  var lineWidth = values.width;
                  if (position === "from") {
                    node1 = this.from;
                    node2 = this.to;
                    guideOffset = 0.1;
                    scaleFactor = values.fromArrowScale;
                    type = values.fromArrowType;
                  } else if (position === "to") {
                    node1 = this.to;
                    node2 = this.from;
                    guideOffset = -0.1;
                    scaleFactor = values.toArrowScale;
                    type = values.toArrowType;
                  } else {
                    node1 = this.to;
                    node2 = this.from;
                    scaleFactor = values.middleArrowScale;
                    type = values.middleArrowType;
                  }
                  if (node1 != node2) {
                    if (position !== "middle") {
                      if (this.options.smooth.enabled === true) {
                        arrowPoint = this.findBorderPosition(node1, ctx, { via: viaNode });
                        var guidePos = this.getPoint(Math.max(0, Math.min(1, arrowPoint.t + guideOffset)), viaNode);
                        angle = Math.atan2(arrowPoint.y - guidePos.y, arrowPoint.x - guidePos.x);
                      } else {
                        angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
                        arrowPoint = this.findBorderPosition(node1, ctx);
                      }
                    } else {
                      angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
                      arrowPoint = this.getPoint(0.5, viaNode);
                    }
                  } else {
                    var _getCircleData10 = this._getCircleData(ctx), _getCircleData11 = (0, _slicedToArray3["default"])(_getCircleData10, 3), x = _getCircleData11[0], y = _getCircleData11[1], radius = _getCircleData11[2];
                    if (position === "from") {
                      arrowPoint = this.findBorderPosition(this.from, ctx, {
                        x,
                        y,
                        low: 0.25,
                        high: 0.6,
                        direction: -1
                      });
                      angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
                    } else if (position === "to") {
                      arrowPoint = this.findBorderPosition(this.from, ctx, {
                        x,
                        y,
                        low: 0.6,
                        high: 1,
                        direction: 1
                      });
                      angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
                    } else {
                      arrowPoint = this._pointOnCircle(x, y, radius, 0.175);
                      angle = 3.9269908169872414;
                    }
                  }
                  if (position === "middle" && scaleFactor < 0)
                    lineWidth *= -1;
                  var length2 = 15 * scaleFactor + 3 * lineWidth;
                  var xi = arrowPoint.x - length2 * 0.9 * Math.cos(angle);
                  var yi = arrowPoint.y - length2 * 0.9 * Math.sin(angle);
                  var arrowCore = { x: xi, y: yi };
                  return {
                    point: arrowPoint,
                    core: arrowCore,
                    angle,
                    length: length2,
                    type
                  };
                }
              }, {
                key: "drawArrowHead",
                value: function drawArrowHead(ctx, values, selected, hover, arrowData) {
                  ctx.strokeStyle = this.getColor(ctx, values, selected, hover);
                  ctx.fillStyle = ctx.strokeStyle;
                  ctx.lineWidth = values.width;
                  EndPoints.draw(ctx, arrowData);
                  this.enableShadow(ctx, values);
                  ctx.fill();
                  this.disableShadow(ctx, values);
                }
              }, {
                key: "enableShadow",
                value: function enableShadow(ctx, values) {
                  if (values.shadow === true) {
                    ctx.shadowColor = values.shadowColor;
                    ctx.shadowBlur = values.shadowSize;
                    ctx.shadowOffsetX = values.shadowX;
                    ctx.shadowOffsetY = values.shadowY;
                  }
                }
              }, {
                key: "disableShadow",
                value: function disableShadow(ctx, values) {
                  if (values.shadow === true) {
                    ctx.shadowColor = "rgba(0,0,0,0)";
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                  }
                }
              }, {
                key: "drawBackground",
                value: function drawBackground(ctx, values) {
                  if (values.background !== false) {
                    var attrs = ["strokeStyle", "lineWidth", "dashes"];
                    var origCtxAttr = {};
                    attrs.forEach(function(attrname) {
                      origCtxAttr[attrname] = ctx[attrname];
                    });
                    ctx.strokeStyle = values.backgroundColor;
                    ctx.lineWidth = values.backgroundSize;
                    this.setStrokeDashed(ctx, values.backgroundDashes);
                    ctx.stroke();
                    attrs.forEach(function(attrname) {
                      ctx[attrname] = origCtxAttr[attrname];
                    });
                    this.setStrokeDashed(ctx, values.dashes);
                  }
                }
              }, {
                key: "setStrokeDashed",
                value: function setStrokeDashed(ctx, dashes) {
                  if (dashes !== false) {
                    if (ctx.setLineDash !== void 0) {
                      var pattern = [5, 5];
                      if (Array.isArray(dashes) === true) {
                        pattern = dashes;
                      }
                      ctx.setLineDash(pattern);
                    } else {
                      console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
                    }
                  } else {
                    if (ctx.setLineDash !== void 0) {
                      ctx.setLineDash([]);
                    } else {
                      console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
                    }
                  }
                }
              }]);
              return EdgeBase2;
            }();
            exports2["default"] = EdgeBase;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var EndPoint = function() {
              function EndPoint2() {
                (0, _classCallCheck3["default"])(this, EndPoint2);
              }
              (0, _createClass3["default"])(EndPoint2, null, [{
                key: "transform",
                value: function transform(points, arrowData) {
                  if (!(points instanceof Array)) {
                    points = [points];
                  }
                  var x = arrowData.point.x;
                  var y = arrowData.point.y;
                  var angle = arrowData.angle;
                  var length2 = arrowData.length;
                  for (var i = 0; i < points.length; ++i) {
                    var p = points[i];
                    var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);
                    var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);
                    p.x = x + length2 * xt;
                    p.y = y + length2 * yt;
                  }
                }
              }, {
                key: "drawPath",
                value: function drawPath(ctx, points) {
                  ctx.beginPath();
                  ctx.moveTo(points[0].x, points[0].y);
                  for (var i = 1; i < points.length; ++i) {
                    ctx.lineTo(points[i].x, points[i].y);
                  }
                  ctx.closePath();
                }
              }]);
              return EndPoint2;
            }();
            var Arrow = function(_EndPoint) {
              (0, _inherits3["default"])(Arrow2, _EndPoint);
              function Arrow2() {
                (0, _classCallCheck3["default"])(this, Arrow2);
                return (0, _possibleConstructorReturn3["default"])(this, (Arrow2.__proto__ || (0, _getPrototypeOf2["default"])(Arrow2)).apply(this, arguments));
              }
              (0, _createClass3["default"])(Arrow2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var points = [{ x: 0, y: 0 }, { x: -1, y: 0.3 }, { x: -0.9, y: 0 }, { x: -1, y: -0.3 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return Arrow2;
            }(EndPoint);
            var Crow = function() {
              function Crow2() {
                (0, _classCallCheck3["default"])(this, Crow2);
              }
              (0, _createClass3["default"])(Crow2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var points = [{ x: -1, y: 0 }, { x: 0, y: 0.3 }, { x: -0.4, y: 0 }, { x: 0, y: -0.3 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return Crow2;
            }();
            var Curve = function() {
              function Curve2() {
                (0, _classCallCheck3["default"])(this, Curve2);
              }
              (0, _createClass3["default"])(Curve2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var point = { x: -0.4, y: 0 };
                  EndPoint.transform(point, arrowData);
                  ctx.strokeStyle = ctx.fillStyle;
                  ctx.fillStyle = "rgba(0, 0, 0, 0)";
                  var pi = Math.PI;
                  var start_angle = arrowData.angle - pi / 2;
                  var end_angle = arrowData.angle + pi / 2;
                  ctx.beginPath();
                  ctx.arc(point.x, point.y, arrowData.length * 0.4, start_angle, end_angle, false);
                  ctx.stroke();
                }
              }]);
              return Curve2;
            }();
            var InvertedCurve = function() {
              function InvertedCurve2() {
                (0, _classCallCheck3["default"])(this, InvertedCurve2);
              }
              (0, _createClass3["default"])(InvertedCurve2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var point = { x: -0.3, y: 0 };
                  EndPoint.transform(point, arrowData);
                  ctx.strokeStyle = ctx.fillStyle;
                  ctx.fillStyle = "rgba(0, 0, 0, 0)";
                  var pi = Math.PI;
                  var start_angle = arrowData.angle + pi / 2;
                  var end_angle = arrowData.angle + 3 * pi / 2;
                  ctx.beginPath();
                  ctx.arc(point.x, point.y, arrowData.length * 0.4, start_angle, end_angle, false);
                  ctx.stroke();
                }
              }]);
              return InvertedCurve2;
            }();
            var Triangle = function() {
              function Triangle2() {
                (0, _classCallCheck3["default"])(this, Triangle2);
              }
              (0, _createClass3["default"])(Triangle2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var points = [{ x: 0.02, y: 0 }, { x: -1, y: 0.3 }, { x: -1, y: -0.3 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return Triangle2;
            }();
            var InvertedTriangle = function() {
              function InvertedTriangle2() {
                (0, _classCallCheck3["default"])(this, InvertedTriangle2);
              }
              (0, _createClass3["default"])(InvertedTriangle2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var points = [{ x: 0, y: 0.3 }, { x: 0, y: -0.3 }, { x: -1, y: 0 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return InvertedTriangle2;
            }();
            var Circle = function() {
              function Circle2() {
                (0, _classCallCheck3["default"])(this, Circle2);
              }
              (0, _createClass3["default"])(Circle2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var point = { x: -0.4, y: 0 };
                  EndPoint.transform(point, arrowData);
                  ctx.circle(point.x, point.y, arrowData.length * 0.4);
                }
              }]);
              return Circle2;
            }();
            var Bar = function() {
              function Bar2() {
                (0, _classCallCheck3["default"])(this, Bar2);
              }
              (0, _createClass3["default"])(Bar2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var points = [{ x: 0, y: 0.5 }, { x: 0, y: -0.5 }, { x: -0.15, y: -0.5 }, { x: -0.15, y: 0.5 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return Bar2;
            }();
            var Box = function() {
              function Box2() {
                (0, _classCallCheck3["default"])(this, Box2);
              }
              (0, _createClass3["default"])(Box2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var points = [{ x: 0, y: 0.3 }, { x: 0, y: -0.3 }, { x: -0.6, y: -0.3 }, { x: -0.6, y: 0.3 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return Box2;
            }();
            var Diamond = function() {
              function Diamond2() {
                (0, _classCallCheck3["default"])(this, Diamond2);
              }
              (0, _createClass3["default"])(Diamond2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var points = [{ x: 0, y: 0 }, { x: -0.5, y: -0.3 }, { x: -1, y: 0 }, { x: -0.5, y: 0.3 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return Diamond2;
            }();
            var Vee = function() {
              function Vee2() {
                (0, _classCallCheck3["default"])(this, Vee2);
              }
              (0, _createClass3["default"])(Vee2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var points = [{ x: -1, y: 0.3 }, { x: -0.5, y: 0 }, { x: -1, y: -0.3 }, { x: 0, y: 0 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return Vee2;
            }();
            var EndPoints = function() {
              function EndPoints2() {
                (0, _classCallCheck3["default"])(this, EndPoints2);
              }
              (0, _createClass3["default"])(EndPoints2, null, [{
                key: "draw",
                value: function draw(ctx, arrowData) {
                  var type;
                  if (arrowData.type) {
                    type = arrowData.type.toLowerCase();
                  }
                  switch (type) {
                    case "circle":
                      Circle.draw(ctx, arrowData);
                      break;
                    case "box":
                      Box.draw(ctx, arrowData);
                      break;
                    case "crow":
                      Crow.draw(ctx, arrowData);
                      break;
                    case "curve":
                      Curve.draw(ctx, arrowData);
                      break;
                    case "diamond":
                      Diamond.draw(ctx, arrowData);
                      break;
                    case "inv_curve":
                      InvertedCurve.draw(ctx, arrowData);
                      break;
                    case "triangle":
                      Triangle.draw(ctx, arrowData);
                      break;
                    case "inv_triangle":
                      InvertedTriangle.draw(ctx, arrowData);
                      break;
                    case "bar":
                      Bar.draw(ctx, arrowData);
                      break;
                    case "vee":
                      Vee.draw(ctx, arrowData);
                      break;
                    case "arrow":
                    default:
                      Arrow.draw(ctx, arrowData);
                  }
                }
              }]);
              return EndPoints2;
            }();
            exports2["default"] = EndPoints;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BarnesHutSolver = function() {
              function BarnesHutSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, BarnesHutSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.barnesHutTree;
                this.setOptions(options);
                this.randomSeed = 5;
              }
              (0, _createClass3["default"])(BarnesHutSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                  this.thetaInversed = 1 / this.options.theta;
                  this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
                }
              }, {
                key: "seededRandom",
                value: function seededRandom() {
                  var x = Math.sin(this.randomSeed++) * 1e4;
                  return x - Math.floor(x);
                }
              }, {
                key: "solve",
                value: function solve() {
                  if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
                    var node = void 0;
                    var nodes2 = this.body.nodes;
                    var nodeIndices = this.physicsBody.physicsNodeIndices;
                    var nodeCount = nodeIndices.length;
                    var barnesHutTree = this._formBarnesHutTree(nodes2, nodeIndices);
                    this.barnesHutTree = barnesHutTree;
                    for (var i = 0; i < nodeCount; i++) {
                      node = nodes2[nodeIndices[i]];
                      if (node.options.mass > 0) {
                        this._getForceContributions(barnesHutTree.root, node);
                      }
                    }
                  }
                }
              }, {
                key: "_getForceContributions",
                value: function _getForceContributions(parentBranch, node) {
                  this._getForceContribution(parentBranch.children.NW, node);
                  this._getForceContribution(parentBranch.children.NE, node);
                  this._getForceContribution(parentBranch.children.SW, node);
                  this._getForceContribution(parentBranch.children.SE, node);
                }
              }, {
                key: "_getForceContribution",
                value: function _getForceContribution(parentBranch, node) {
                  if (parentBranch.childrenCount > 0) {
                    var dx = void 0, dy = void 0, distance = void 0;
                    dx = parentBranch.centerOfMass.x - node.x;
                    dy = parentBranch.centerOfMass.y - node.y;
                    distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance * parentBranch.calcSize > this.thetaInversed) {
                      this._calculateForces(distance, dx, dy, node, parentBranch);
                    } else {
                      if (parentBranch.childrenCount === 4) {
                        this._getForceContributions(parentBranch, node);
                      } else {
                        if (parentBranch.children.data.id != node.id) {
                          this._calculateForces(distance, dx, dy, node, parentBranch);
                        }
                      }
                    }
                  }
                }
              }, {
                key: "_calculateForces",
                value: function _calculateForces(distance, dx, dy, node, parentBranch) {
                  if (distance === 0) {
                    distance = 0.1;
                    dx = distance;
                  }
                  if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
                    distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
                  }
                  var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
                  var fx = dx * gravityForce;
                  var fy = dy * gravityForce;
                  this.physicsBody.forces[node.id].x += fx;
                  this.physicsBody.forces[node.id].y += fy;
                }
              }, {
                key: "_formBarnesHutTree",
                value: function _formBarnesHutTree(nodes2, nodeIndices) {
                  var node = void 0;
                  var nodeCount = nodeIndices.length;
                  var minX = nodes2[nodeIndices[0]].x;
                  var minY = nodes2[nodeIndices[0]].y;
                  var maxX = nodes2[nodeIndices[0]].x;
                  var maxY = nodes2[nodeIndices[0]].y;
                  for (var i = 1; i < nodeCount; i++) {
                    var _node = nodes2[nodeIndices[i]];
                    var x = _node.x;
                    var y = _node.y;
                    if (_node.options.mass > 0) {
                      if (x < minX) {
                        minX = x;
                      }
                      if (x > maxX) {
                        maxX = x;
                      }
                      if (y < minY) {
                        minY = y;
                      }
                      if (y > maxY) {
                        maxY = y;
                      }
                    }
                  }
                  var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY);
                  if (sizeDiff > 0) {
                    minY -= 0.5 * sizeDiff;
                    maxY += 0.5 * sizeDiff;
                  } else {
                    minX += 0.5 * sizeDiff;
                    maxX -= 0.5 * sizeDiff;
                  }
                  var minimumTreeSize = 1e-5;
                  var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
                  var halfRootSize = 0.5 * rootSize;
                  var centerX = 0.5 * (minX + maxX), centerY = 0.5 * (minY + maxY);
                  var barnesHutTree = {
                    root: {
                      centerOfMass: { x: 0, y: 0 },
                      mass: 0,
                      range: {
                        minX: centerX - halfRootSize,
                        maxX: centerX + halfRootSize,
                        minY: centerY - halfRootSize,
                        maxY: centerY + halfRootSize
                      },
                      size: rootSize,
                      calcSize: 1 / rootSize,
                      children: { data: null },
                      maxWidth: 0,
                      level: 0,
                      childrenCount: 4
                    }
                  };
                  this._splitBranch(barnesHutTree.root);
                  for (var _i = 0; _i < nodeCount; _i++) {
                    node = nodes2[nodeIndices[_i]];
                    if (node.options.mass > 0) {
                      this._placeInTree(barnesHutTree.root, node);
                    }
                  }
                  return barnesHutTree;
                }
              }, {
                key: "_updateBranchMass",
                value: function _updateBranchMass(parentBranch, node) {
                  var centerOfMass = parentBranch.centerOfMass;
                  var totalMass = parentBranch.mass + node.options.mass;
                  var totalMassInv = 1 / totalMass;
                  centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
                  centerOfMass.x *= totalMassInv;
                  centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
                  centerOfMass.y *= totalMassInv;
                  parentBranch.mass = totalMass;
                  var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
                  parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
                }
              }, {
                key: "_placeInTree",
                value: function _placeInTree(parentBranch, node, skipMassUpdate) {
                  if (skipMassUpdate != true || skipMassUpdate === void 0) {
                    this._updateBranchMass(parentBranch, node);
                  }
                  var range = parentBranch.children.NW.range;
                  var region = void 0;
                  if (range.maxX > node.x) {
                    if (range.maxY > node.y) {
                      region = "NW";
                    } else {
                      region = "SW";
                    }
                  } else {
                    if (range.maxY > node.y) {
                      region = "NE";
                    } else {
                      region = "SE";
                    }
                  }
                  this._placeInRegion(parentBranch, node, region);
                }
              }, {
                key: "_placeInRegion",
                value: function _placeInRegion(parentBranch, node, region) {
                  var children = parentBranch.children[region];
                  switch (children.childrenCount) {
                    case 0:
                      children.children.data = node;
                      children.childrenCount = 1;
                      this._updateBranchMass(children, node);
                      break;
                    case 1:
                      if (children.children.data.x === node.x && children.children.data.y === node.y) {
                        node.x += this.seededRandom();
                        node.y += this.seededRandom();
                      } else {
                        this._splitBranch(children);
                        this._placeInTree(children, node);
                      }
                      break;
                    case 4:
                      this._placeInTree(children, node);
                      break;
                  }
                }
              }, {
                key: "_splitBranch",
                value: function _splitBranch(parentBranch) {
                  var containedNode = null;
                  if (parentBranch.childrenCount === 1) {
                    containedNode = parentBranch.children.data;
                    parentBranch.mass = 0;
                    parentBranch.centerOfMass.x = 0;
                    parentBranch.centerOfMass.y = 0;
                  }
                  parentBranch.childrenCount = 4;
                  parentBranch.children.data = null;
                  this._insertRegion(parentBranch, "NW");
                  this._insertRegion(parentBranch, "NE");
                  this._insertRegion(parentBranch, "SW");
                  this._insertRegion(parentBranch, "SE");
                  if (containedNode != null) {
                    this._placeInTree(parentBranch, containedNode);
                  }
                }
              }, {
                key: "_insertRegion",
                value: function _insertRegion(parentBranch, region) {
                  var minX = void 0, maxX = void 0, minY = void 0, maxY = void 0;
                  var childSize = 0.5 * parentBranch.size;
                  switch (region) {
                    case "NW":
                      minX = parentBranch.range.minX;
                      maxX = parentBranch.range.minX + childSize;
                      minY = parentBranch.range.minY;
                      maxY = parentBranch.range.minY + childSize;
                      break;
                    case "NE":
                      minX = parentBranch.range.minX + childSize;
                      maxX = parentBranch.range.maxX;
                      minY = parentBranch.range.minY;
                      maxY = parentBranch.range.minY + childSize;
                      break;
                    case "SW":
                      minX = parentBranch.range.minX;
                      maxX = parentBranch.range.minX + childSize;
                      minY = parentBranch.range.minY + childSize;
                      maxY = parentBranch.range.maxY;
                      break;
                    case "SE":
                      minX = parentBranch.range.minX + childSize;
                      maxX = parentBranch.range.maxX;
                      minY = parentBranch.range.minY + childSize;
                      maxY = parentBranch.range.maxY;
                      break;
                  }
                  parentBranch.children[region] = {
                    centerOfMass: { x: 0, y: 0 },
                    mass: 0,
                    range: { minX, maxX, minY, maxY },
                    size: 0.5 * parentBranch.size,
                    calcSize: 2 * parentBranch.calcSize,
                    children: { data: null },
                    maxWidth: 0,
                    level: parentBranch.level + 1,
                    childrenCount: 0
                  };
                }
              }, {
                key: "_debug",
                value: function _debug(ctx, color) {
                  if (this.barnesHutTree !== void 0) {
                    ctx.lineWidth = 1;
                    this._drawBranch(this.barnesHutTree.root, ctx, color);
                  }
                }
              }, {
                key: "_drawBranch",
                value: function _drawBranch(branch, ctx, color) {
                  if (color === void 0) {
                    color = "#FF0000";
                  }
                  if (branch.childrenCount === 4) {
                    this._drawBranch(branch.children.NW, ctx);
                    this._drawBranch(branch.children.NE, ctx);
                    this._drawBranch(branch.children.SE, ctx);
                    this._drawBranch(branch.children.SW, ctx);
                  }
                  ctx.strokeStyle = color;
                  ctx.beginPath();
                  ctx.moveTo(branch.range.minX, branch.range.minY);
                  ctx.lineTo(branch.range.maxX, branch.range.minY);
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.moveTo(branch.range.maxX, branch.range.minY);
                  ctx.lineTo(branch.range.maxX, branch.range.maxY);
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.moveTo(branch.range.maxX, branch.range.maxY);
                  ctx.lineTo(branch.range.minX, branch.range.maxY);
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.moveTo(branch.range.minX, branch.range.maxY);
                  ctx.lineTo(branch.range.minX, branch.range.minY);
                  ctx.stroke();
                }
              }]);
              return BarnesHutSolver2;
            }();
            exports2["default"] = BarnesHutSolver;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CentralGravitySolver = function() {
              function CentralGravitySolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, CentralGravitySolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(CentralGravitySolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
              }, {
                key: "solve",
                value: function solve() {
                  var dx = void 0, dy = void 0, distance = void 0, node = void 0;
                  var nodes2 = this.body.nodes;
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var forces = this.physicsBody.forces;
                  for (var i = 0; i < nodeIndices.length; i++) {
                    var nodeId = nodeIndices[i];
                    node = nodes2[nodeId];
                    dx = -node.x;
                    dy = -node.y;
                    distance = Math.sqrt(dx * dx + dy * dy);
                    this._calculateForces(distance, dx, dy, forces, node);
                  }
                }
              }, {
                key: "_calculateForces",
                value: function _calculateForces(distance, dx, dy, forces, node) {
                  var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
                  forces[node.id].x = dx * gravityForce;
                  forces[node.id].y = dy * gravityForce;
                }
              }]);
              return CentralGravitySolver2;
            }();
            exports2["default"] = CentralGravitySolver;
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = __webpack_require__(188);
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var string = "string";
            var bool = "boolean";
            var number = "number";
            var array = "array";
            var object = "object";
            var dom2 = "dom";
            var any = "any";
            var endPoints = ["arrow", "circle", "bar"];
            var allOptions = {
              configure: {
                enabled: { boolean: bool },
                filter: { boolean: bool, string, array, "function": "function" },
                container: { dom: dom2 },
                showButton: { boolean: bool },
                __type__: { object, boolean: bool, string, array, "function": "function" }
              },
              edges: {
                arrows: {
                  to: {
                    enabled: { boolean: bool },
                    scaleFactor: { number },
                    type: { string: endPoints },
                    __type__: { object, boolean: bool }
                  },
                  middle: {
                    enabled: { boolean: bool },
                    scaleFactor: { number },
                    type: { string: endPoints },
                    __type__: { object, boolean: bool }
                  },
                  from: {
                    enabled: { boolean: bool },
                    scaleFactor: { number },
                    type: { string: endPoints },
                    __type__: { object, boolean: bool }
                  },
                  __type__: { string: ["from", "to", "middle"], object }
                },
                arrowStrikethrough: { boolean: bool },
                background: {
                  enabled: { boolean: bool },
                  color: { string },
                  size: { number },
                  dashes: { boolean: bool, array },
                  __type__: { object, boolean: bool }
                },
                chosen: {
                  label: { boolean: bool, "function": "function" },
                  edge: { boolean: bool, "function": "function" },
                  __type__: { object, boolean: bool }
                },
                color: {
                  color: { string },
                  highlight: { string },
                  hover: { string },
                  inherit: { string: ["from", "to", "both"], boolean: bool },
                  opacity: { number },
                  __type__: { object, string }
                },
                dashes: { boolean: bool, array },
                font: {
                  color: { string },
                  size: { number },
                  face: { string },
                  background: { string },
                  strokeWidth: { number },
                  strokeColor: { string },
                  align: { string: ["horizontal", "top", "middle", "bottom"] },
                  vadjust: { number },
                  multi: { boolean: bool, string },
                  bold: {
                    color: { string },
                    size: { number },
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  boldital: {
                    color: { string },
                    size: { number },
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  ital: {
                    color: { string },
                    size: { number },
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  mono: {
                    color: { string },
                    size: { number },
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  __type__: { object, string }
                },
                hidden: { boolean: bool },
                hoverWidth: { "function": "function", number },
                label: { string, undefined: "undefined" },
                labelHighlightBold: { boolean: bool },
                length: { number, undefined: "undefined" },
                physics: { boolean: bool },
                scaling: {
                  min: { number },
                  max: { number },
                  label: {
                    enabled: { boolean: bool },
                    min: { number },
                    max: { number },
                    maxVisible: { number },
                    drawThreshold: { number },
                    __type__: { object, boolean: bool }
                  },
                  customScalingFunction: { "function": "function" },
                  __type__: { object }
                },
                selectionWidth: { "function": "function", number },
                selfReferenceSize: { number },
                shadow: {
                  enabled: { boolean: bool },
                  color: { string },
                  size: { number },
                  x: { number },
                  y: { number },
                  __type__: { object, boolean: bool }
                },
                smooth: {
                  enabled: { boolean: bool },
                  type: {
                    string: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"]
                  },
                  roundness: { number },
                  forceDirection: {
                    string: ["horizontal", "vertical", "none"],
                    boolean: bool
                  },
                  __type__: { object, boolean: bool }
                },
                title: { string, undefined: "undefined" },
                width: { number },
                widthConstraint: {
                  maximum: { number },
                  __type__: { object, boolean: bool, number }
                },
                value: { number, undefined: "undefined" },
                __type__: { object }
              },
              groups: {
                useDefaultGroups: { boolean: bool },
                __any__: "get from nodes, will be overwritten below",
                __type__: { object }
              },
              interaction: {
                dragNodes: { boolean: bool },
                dragView: { boolean: bool },
                hideEdgesOnDrag: { boolean: bool },
                hideEdgesOnZoom: { boolean: bool },
                hideNodesOnDrag: { boolean: bool },
                hover: { boolean: bool },
                keyboard: {
                  enabled: { boolean: bool },
                  speed: {
                    x: { number },
                    y: { number },
                    zoom: { number },
                    __type__: { object }
                  },
                  bindToWindow: { boolean: bool },
                  __type__: { object, boolean: bool }
                },
                multiselect: { boolean: bool },
                navigationButtons: { boolean: bool },
                selectable: { boolean: bool },
                selectConnectedEdges: { boolean: bool },
                hoverConnectedEdges: { boolean: bool },
                tooltipDelay: { number },
                zoomView: { boolean: bool },
                zoomSpeed: { number },
                __type__: { object }
              },
              layout: {
                randomSeed: { undefined: "undefined", number },
                improvedLayout: { boolean: bool },
                hierarchical: {
                  enabled: { boolean: bool },
                  levelSeparation: { number },
                  nodeSpacing: { number },
                  treeSpacing: { number },
                  blockShifting: { boolean: bool },
                  edgeMinimization: { boolean: bool },
                  parentCentralization: { boolean: bool },
                  direction: { string: ["UD", "DU", "LR", "RL"] },
                  sortMethod: { string: ["hubsize", "directed"] },
                  __type__: { object, boolean: bool }
                },
                __type__: { object }
              },
              manipulation: {
                enabled: { boolean: bool },
                initiallyActive: { boolean: bool },
                addNode: { boolean: bool, "function": "function" },
                addEdge: { boolean: bool, "function": "function" },
                editNode: { "function": "function" },
                editEdge: {
                  editWithoutDrag: { "function": "function" },
                  __type__: { object, boolean: bool, "function": "function" }
                },
                deleteNode: { boolean: bool, "function": "function" },
                deleteEdge: { boolean: bool, "function": "function" },
                controlNodeStyle: "get from nodes, will be overwritten below",
                __type__: { object, boolean: bool }
              },
              nodes: {
                borderWidth: { number },
                borderWidthSelected: { number, undefined: "undefined" },
                brokenImage: { string, undefined: "undefined" },
                chosen: {
                  label: { boolean: bool, "function": "function" },
                  node: { boolean: bool, "function": "function" },
                  __type__: { object, boolean: bool }
                },
                color: {
                  border: { string },
                  background: { string },
                  highlight: {
                    border: { string },
                    background: { string },
                    __type__: { object, string }
                  },
                  hover: {
                    border: { string },
                    background: { string },
                    __type__: { object, string }
                  },
                  __type__: { object, string }
                },
                fixed: {
                  x: { boolean: bool },
                  y: { boolean: bool },
                  __type__: { object, boolean: bool }
                },
                font: {
                  align: { string },
                  color: { string },
                  size: { number },
                  face: { string },
                  background: { string },
                  strokeWidth: { number },
                  strokeColor: { string },
                  vadjust: { number },
                  multi: { boolean: bool, string },
                  bold: {
                    color: { string },
                    size: { number },
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  boldital: {
                    color: { string },
                    size: { number },
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  ital: {
                    color: { string },
                    size: { number },
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  mono: {
                    color: { string },
                    size: { number },
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  __type__: { object, string }
                },
                group: { string, number, undefined: "undefined" },
                heightConstraint: {
                  minimum: { number },
                  valign: { string },
                  __type__: { object, boolean: bool, number }
                },
                hidden: { boolean: bool },
                icon: {
                  face: { string },
                  code: { string },
                  size: { number },
                  color: { string },
                  __type__: { object }
                },
                id: { string, number },
                image: {
                  selected: { string, undefined: "undefined" },
                  unselected: { string, undefined: "undefined" },
                  __type__: { object, string }
                },
                label: { string, undefined: "undefined" },
                labelHighlightBold: { boolean: bool },
                level: { number, undefined: "undefined" },
                margin: {
                  top: { number },
                  right: { number },
                  bottom: { number },
                  left: { number },
                  __type__: { object, number }
                },
                mass: { number },
                physics: { boolean: bool },
                scaling: {
                  min: { number },
                  max: { number },
                  label: {
                    enabled: { boolean: bool },
                    min: { number },
                    max: { number },
                    maxVisible: { number },
                    drawThreshold: { number },
                    __type__: { object, boolean: bool }
                  },
                  customScalingFunction: { "function": "function" },
                  __type__: { object }
                },
                shadow: {
                  enabled: { boolean: bool },
                  color: { string },
                  size: { number },
                  x: { number },
                  y: { number },
                  __type__: { object, boolean: bool }
                },
                shape: {
                  string: ["ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"]
                },
                shapeProperties: {
                  borderDashes: { boolean: bool, array },
                  borderRadius: { number },
                  interpolation: { boolean: bool },
                  useImageSize: { boolean: bool },
                  useBorderWithImage: { boolean: bool },
                  __type__: { object }
                },
                size: { number },
                title: { string, dom: dom2, undefined: "undefined" },
                value: { number, undefined: "undefined" },
                widthConstraint: {
                  minimum: { number },
                  maximum: { number },
                  __type__: { object, boolean: bool, number }
                },
                x: { number },
                y: { number },
                __type__: { object }
              },
              physics: {
                enabled: { boolean: bool },
                barnesHut: {
                  gravitationalConstant: { number },
                  centralGravity: { number },
                  springLength: { number },
                  springConstant: { number },
                  damping: { number },
                  avoidOverlap: { number },
                  __type__: { object }
                },
                forceAtlas2Based: {
                  gravitationalConstant: { number },
                  centralGravity: { number },
                  springLength: { number },
                  springConstant: { number },
                  damping: { number },
                  avoidOverlap: { number },
                  __type__: { object }
                },
                repulsion: {
                  centralGravity: { number },
                  springLength: { number },
                  springConstant: { number },
                  nodeDistance: { number },
                  damping: { number },
                  __type__: { object }
                },
                hierarchicalRepulsion: {
                  centralGravity: { number },
                  springLength: { number },
                  springConstant: { number },
                  nodeDistance: { number },
                  damping: { number },
                  __type__: { object }
                },
                maxVelocity: { number },
                minVelocity: { number },
                solver: {
                  string: ["barnesHut", "repulsion", "hierarchicalRepulsion", "forceAtlas2Based"]
                },
                stabilization: {
                  enabled: { boolean: bool },
                  iterations: { number },
                  updateInterval: { number },
                  onlyDynamicEdges: { boolean: bool },
                  fit: { boolean: bool },
                  __type__: { object, boolean: bool }
                },
                timestep: { number },
                adaptiveTimestep: { boolean: bool },
                __type__: { object, boolean: bool }
              },
              autoResize: { boolean: bool },
              clickToUse: { boolean: bool },
              locale: { string },
              locales: {
                __any__: { any },
                __type__: { object }
              },
              height: { string },
              width: { string },
              __type__: { object }
            };
            allOptions.groups.__any__ = allOptions.nodes;
            allOptions.manipulation.controlNodeStyle = allOptions.nodes;
            var configureOptions = {
              nodes: {
                borderWidth: [1, 0, 10, 1],
                borderWidthSelected: [2, 0, 10, 1],
                color: {
                  border: ["color", "#2B7CE9"],
                  background: ["color", "#97C2FC"],
                  highlight: {
                    border: ["color", "#2B7CE9"],
                    background: ["color", "#D2E5FF"]
                  },
                  hover: {
                    border: ["color", "#2B7CE9"],
                    background: ["color", "#D2E5FF"]
                  }
                },
                fixed: {
                  x: false,
                  y: false
                },
                font: {
                  color: ["color", "#343434"],
                  size: [14, 0, 100, 1],
                  face: ["arial", "verdana", "tahoma"],
                  background: ["color", "none"],
                  strokeWidth: [0, 0, 50, 1],
                  strokeColor: ["color", "#ffffff"]
                },
                hidden: false,
                labelHighlightBold: true,
                physics: true,
                scaling: {
                  min: [10, 0, 200, 1],
                  max: [30, 0, 200, 1],
                  label: {
                    enabled: false,
                    min: [14, 0, 200, 1],
                    max: [30, 0, 200, 1],
                    maxVisible: [30, 0, 200, 1],
                    drawThreshold: [5, 0, 20, 1]
                  }
                },
                shadow: {
                  enabled: false,
                  color: "rgba(0,0,0,0.5)",
                  size: [10, 0, 20, 1],
                  x: [5, -30, 30, 1],
                  y: [5, -30, 30, 1]
                },
                shape: ["ellipse", "box", "circle", "database", "diamond", "dot", "square", "star", "text", "triangle", "triangleDown", "hexagon"],
                shapeProperties: {
                  borderDashes: false,
                  borderRadius: [6, 0, 20, 1],
                  interpolation: true,
                  useImageSize: false
                },
                size: [25, 0, 200, 1]
              },
              edges: {
                arrows: {
                  to: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: "arrow" },
                  middle: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: "arrow" },
                  from: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: "arrow" }
                },
                arrowStrikethrough: true,
                color: {
                  color: ["color", "#848484"],
                  highlight: ["color", "#848484"],
                  hover: ["color", "#848484"],
                  inherit: ["from", "to", "both", true, false],
                  opacity: [1, 0, 1, 0.05]
                },
                dashes: false,
                font: {
                  color: ["color", "#343434"],
                  size: [14, 0, 100, 1],
                  face: ["arial", "verdana", "tahoma"],
                  background: ["color", "none"],
                  strokeWidth: [2, 0, 50, 1],
                  strokeColor: ["color", "#ffffff"],
                  align: ["horizontal", "top", "middle", "bottom"]
                },
                hidden: false,
                hoverWidth: [1.5, 0, 5, 0.1],
                labelHighlightBold: true,
                physics: true,
                scaling: {
                  min: [1, 0, 100, 1],
                  max: [15, 0, 100, 1],
                  label: {
                    enabled: true,
                    min: [14, 0, 200, 1],
                    max: [30, 0, 200, 1],
                    maxVisible: [30, 0, 200, 1],
                    drawThreshold: [5, 0, 20, 1]
                  }
                },
                selectionWidth: [1.5, 0, 5, 0.1],
                selfReferenceSize: [20, 0, 200, 1],
                shadow: {
                  enabled: false,
                  color: "rgba(0,0,0,0.5)",
                  size: [10, 0, 20, 1],
                  x: [5, -30, 30, 1],
                  y: [5, -30, 30, 1]
                },
                smooth: {
                  enabled: true,
                  type: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"],
                  forceDirection: ["horizontal", "vertical", "none"],
                  roundness: [0.5, 0, 1, 0.05]
                },
                width: [1, 0, 30, 1]
              },
              layout: {
                hierarchical: {
                  enabled: false,
                  levelSeparation: [150, 20, 500, 5],
                  nodeSpacing: [100, 20, 500, 5],
                  treeSpacing: [200, 20, 500, 5],
                  blockShifting: true,
                  edgeMinimization: true,
                  parentCentralization: true,
                  direction: ["UD", "DU", "LR", "RL"],
                  sortMethod: ["hubsize", "directed"]
                }
              },
              interaction: {
                dragNodes: true,
                dragView: true,
                hideEdgesOnDrag: false,
                hideEdgesOnZoom: false,
                hideNodesOnDrag: false,
                hover: false,
                keyboard: {
                  enabled: false,
                  speed: {
                    x: [10, 0, 40, 1],
                    y: [10, 0, 40, 1],
                    zoom: [0.02, 0, 0.1, 5e-3]
                  },
                  bindToWindow: true
                },
                multiselect: false,
                navigationButtons: false,
                selectable: true,
                selectConnectedEdges: true,
                hoverConnectedEdges: true,
                tooltipDelay: [300, 0, 1e3, 25],
                zoomView: true,
                zoomSpeed: [1, 1, 1, 1]
              },
              manipulation: {
                enabled: false,
                initiallyActive: false
              },
              physics: {
                enabled: true,
                barnesHut: {
                  gravitationalConstant: [-2e3, -3e4, 0, 50],
                  centralGravity: [0.3, 0, 10, 0.05],
                  springLength: [95, 0, 500, 5],
                  springConstant: [0.04, 0, 1.2, 5e-3],
                  damping: [0.09, 0, 1, 0.01],
                  avoidOverlap: [0, 0, 1, 0.01]
                },
                forceAtlas2Based: {
                  gravitationalConstant: [-50, -500, 0, 1],
                  centralGravity: [0.01, 0, 1, 5e-3],
                  springLength: [95, 0, 500, 5],
                  springConstant: [0.08, 0, 1.2, 5e-3],
                  damping: [0.4, 0, 1, 0.01],
                  avoidOverlap: [0, 0, 1, 0.01]
                },
                repulsion: {
                  centralGravity: [0.2, 0, 10, 0.05],
                  springLength: [200, 0, 500, 5],
                  springConstant: [0.05, 0, 1.2, 5e-3],
                  nodeDistance: [100, 0, 500, 5],
                  damping: [0.09, 0, 1, 0.01]
                },
                hierarchicalRepulsion: {
                  centralGravity: [0.2, 0, 10, 0.05],
                  springLength: [100, 0, 500, 5],
                  springConstant: [0.01, 0, 1.2, 5e-3],
                  nodeDistance: [120, 0, 500, 5],
                  damping: [0.09, 0, 1, 0.01]
                },
                maxVelocity: [50, 0, 150, 1],
                minVelocity: [0.1, 0.01, 0.5, 0.01],
                solver: ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"],
                timestep: [0.5, 0.01, 1, 0.01]
              }
            };
            exports2.allOptions = allOptions;
            exports2.configureOptions = configureOptions;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var util = __webpack_require__(2);
            util.extend(exports2, __webpack_require__(121));
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(37);
            __webpack_require__(47);
            module2.exports = __webpack_require__(98);
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var addToUnscopables = __webpack_require__(88);
            var step = __webpack_require__(89);
            var Iterators = __webpack_require__(25);
            var toIObject = __webpack_require__(18);
            module2.exports = __webpack_require__(60)(Array, "Array", function(iterated, kind) {
              this._t = toIObject(iterated);
              this._i = 0;
              this._k = kind;
            }, function() {
              var O = this._t;
              var kind = this._k;
              var index = this._i++;
              if (!O || index >= O.length) {
                this._t = void 0;
                return step(1);
              }
              if (kind == "keys")
                return step(0, index);
              if (kind == "values")
                return step(0, O[index]);
              return step(0, [index, O[index]]);
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
          },
          function(module2, exports2) {
            module2.exports = function() {
            };
          },
          function(module2, exports2) {
            module2.exports = function(done, value) {
              return { value, done: !!done };
            };
          },
          function(module2, exports2) {
            module2.exports = function(it) {
              if (typeof it != "function")
                throw TypeError(it + " is not a function!");
              return it;
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var create = __webpack_require__(41);
            var descriptor = __webpack_require__(28);
            var setToStringTag = __webpack_require__(46);
            var IteratorPrototype = {};
            __webpack_require__(19)(IteratorPrototype, __webpack_require__(8)("iterator"), function() {
              return this;
            });
            module2.exports = function(Constructor, NAME, next) {
              Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
              setToStringTag(Constructor, NAME + " Iterator");
            };
          },
          function(module2, exports2, __webpack_require__) {
            var dP = __webpack_require__(12);
            var anObject = __webpack_require__(20);
            var getKeys = __webpack_require__(26);
            module2.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) {
              anObject(O);
              var keys = getKeys(Properties);
              var length2 = keys.length;
              var i = 0;
              var P;
              while (length2 > i)
                dP.f(O, P = keys[i++], Properties[P]);
              return O;
            };
          },
          function(module2, exports2, __webpack_require__) {
            var toIObject = __webpack_require__(18);
            var toLength = __webpack_require__(94);
            var toAbsoluteIndex = __webpack_require__(95);
            module2.exports = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIObject($this);
                var length2 = toLength(O.length);
                var index = toAbsoluteIndex(fromIndex, length2);
                var value;
                if (IS_INCLUDES && el != el)
                  while (length2 > index) {
                    value = O[index++];
                    if (value != value)
                      return true;
                  }
                else
                  for (; length2 > index; index++)
                    if (IS_INCLUDES || index in O) {
                      if (O[index] === el)
                        return IS_INCLUDES || index || 0;
                    }
                return !IS_INCLUDES && -1;
              };
            };
          },
          function(module2, exports2, __webpack_require__) {
            var toInteger = __webpack_require__(42);
            var min = Math.min;
            module2.exports = function(it) {
              return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
            };
          },
          function(module2, exports2, __webpack_require__) {
            var toInteger = __webpack_require__(42);
            var max = Math.max;
            var min = Math.min;
            module2.exports = function(index, length2) {
              index = toInteger(index);
              return index < 0 ? max(index + length2, 0) : min(index, length2);
            };
          },
          function(module2, exports2, __webpack_require__) {
            var document2 = __webpack_require__(10).document;
            module2.exports = document2 && document2.documentElement;
          },
          function(module2, exports2, __webpack_require__) {
            var toInteger = __webpack_require__(42);
            var defined = __webpack_require__(39);
            module2.exports = function(TO_STRING) {
              return function(that, pos) {
                var s = String(defined(that));
                var i = toInteger(pos);
                var l = s.length;
                var a, b;
                if (i < 0 || i >= l)
                  return TO_STRING ? "" : void 0;
                a = s.charCodeAt(i);
                return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
              };
            };
          },
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__(20);
            var get3 = __webpack_require__(99);
            module2.exports = __webpack_require__(6).getIterator = function(it) {
              var iterFn = get3(it);
              if (typeof iterFn != "function")
                throw TypeError(it + " is not iterable!");
              return anObject(iterFn.call(it));
            };
          },
          function(module2, exports2, __webpack_require__) {
            var classof = __webpack_require__(67);
            var ITERATOR = __webpack_require__(8)("iterator");
            var Iterators = __webpack_require__(25);
            module2.exports = __webpack_require__(6).getIteratorMethod = function(it) {
              if (it != void 0)
                return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
            };
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(101);
            var $Object = __webpack_require__(6).Object;
            module2.exports = function create(P, D) {
              return $Object.create(P, D);
            };
          },
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(11);
            $export($export.S, "Object", { create: __webpack_require__(41) });
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(103);
            module2.exports = __webpack_require__(6).Object.keys;
          },
          function(module2, exports2, __webpack_require__) {
            var toObject = __webpack_require__(30);
            var $keys = __webpack_require__(26);
            __webpack_require__(68)("keys", function() {
              return function keys(it) {
                return $keys(toObject(it));
              };
            });
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(105), __esModule: true };
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(47);
            __webpack_require__(37);
            module2.exports = __webpack_require__(48).f("iterator");
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(107), __esModule: true };
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(108);
            __webpack_require__(113);
            __webpack_require__(114);
            __webpack_require__(115);
            module2.exports = __webpack_require__(6).Symbol;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var global = __webpack_require__(10);
            var has = __webpack_require__(14);
            var DESCRIPTORS = __webpack_require__(13);
            var $export = __webpack_require__(11);
            var redefine = __webpack_require__(64);
            var META = __webpack_require__(109).KEY;
            var $fails = __webpack_require__(22);
            var shared = __webpack_require__(44);
            var setToStringTag = __webpack_require__(46);
            var uid = __webpack_require__(29);
            var wks = __webpack_require__(8);
            var wksExt = __webpack_require__(48);
            var wksDefine = __webpack_require__(49);
            var enumKeys = __webpack_require__(110);
            var isArray = __webpack_require__(111);
            var anObject = __webpack_require__(20);
            var isObject2 = __webpack_require__(21);
            var toIObject = __webpack_require__(18);
            var toPrimitive = __webpack_require__(40);
            var createDesc = __webpack_require__(28);
            var _create = __webpack_require__(41);
            var gOPNExt = __webpack_require__(112);
            var $GOPD = __webpack_require__(70);
            var $DP = __webpack_require__(12);
            var $keys = __webpack_require__(26);
            var gOPD = $GOPD.f;
            var dP = $DP.f;
            var gOPN = gOPNExt.f;
            var $Symbol = global.Symbol;
            var $JSON = global.JSON;
            var _stringify = $JSON && $JSON.stringify;
            var PROTOTYPE = "prototype";
            var HIDDEN = wks("_hidden");
            var TO_PRIMITIVE = wks("toPrimitive");
            var isEnum = {}.propertyIsEnumerable;
            var SymbolRegistry = shared("symbol-registry");
            var AllSymbols = shared("symbols");
            var OPSymbols = shared("op-symbols");
            var ObjectProto = Object[PROTOTYPE];
            var USE_NATIVE = typeof $Symbol == "function";
            var QObject = global.QObject;
            var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
            var setSymbolDesc = DESCRIPTORS && $fails(function() {
              return _create(dP({}, "a", {
                get: function() {
                  return dP(this, "a", { value: 7 }).a;
                }
              })).a != 7;
            }) ? function(it, key, D) {
              var protoDesc = gOPD(ObjectProto, key);
              if (protoDesc)
                delete ObjectProto[key];
              dP(it, key, D);
              if (protoDesc && it !== ObjectProto)
                dP(ObjectProto, key, protoDesc);
            } : dP;
            var wrap = function(tag) {
              var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
              sym._k = tag;
              return sym;
            };
            var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
              return typeof it == "symbol";
            } : function(it) {
              return it instanceof $Symbol;
            };
            var $defineProperty = function defineProperty(it, key, D) {
              if (it === ObjectProto)
                $defineProperty(OPSymbols, key, D);
              anObject(it);
              key = toPrimitive(key, true);
              anObject(D);
              if (has(AllSymbols, key)) {
                if (!D.enumerable) {
                  if (!has(it, HIDDEN))
                    dP(it, HIDDEN, createDesc(1, {}));
                  it[HIDDEN][key] = true;
                } else {
                  if (has(it, HIDDEN) && it[HIDDEN][key])
                    it[HIDDEN][key] = false;
                  D = _create(D, { enumerable: createDesc(0, false) });
                }
                return setSymbolDesc(it, key, D);
              }
              return dP(it, key, D);
            };
            var $defineProperties = function defineProperties(it, P) {
              anObject(it);
              var keys = enumKeys(P = toIObject(P));
              var i = 0;
              var l = keys.length;
              var key;
              while (l > i)
                $defineProperty(it, key = keys[i++], P[key]);
              return it;
            };
            var $create = function create(it, P) {
              return P === void 0 ? _create(it) : $defineProperties(_create(it), P);
            };
            var $propertyIsEnumerable = function propertyIsEnumerable(key) {
              var E = isEnum.call(this, key = toPrimitive(key, true));
              if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
                return false;
              return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
            };
            var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
              it = toIObject(it);
              key = toPrimitive(key, true);
              if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
                return;
              var D = gOPD(it, key);
              if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
                D.enumerable = true;
              return D;
            };
            var $getOwnPropertyNames = function getOwnPropertyNames(it) {
              var names = gOPN(toIObject(it));
              var result2 = [];
              var i = 0;
              var key;
              while (names.length > i) {
                if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)
                  result2.push(key);
              }
              return result2;
            };
            var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
              var IS_OP = it === ObjectProto;
              var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
              var result2 = [];
              var i = 0;
              var key;
              while (names.length > i) {
                if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))
                  result2.push(AllSymbols[key]);
              }
              return result2;
            };
            if (!USE_NATIVE) {
              $Symbol = function Symbol2() {
                if (this instanceof $Symbol)
                  throw TypeError("Symbol is not a constructor!");
                var tag = uid(arguments.length > 0 ? arguments[0] : void 0);
                var $set = function(value) {
                  if (this === ObjectProto)
                    $set.call(OPSymbols, value);
                  if (has(this, HIDDEN) && has(this[HIDDEN], tag))
                    this[HIDDEN][tag] = false;
                  setSymbolDesc(this, tag, createDesc(1, value));
                };
                if (DESCRIPTORS && setter)
                  setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
                return wrap(tag);
              };
              redefine($Symbol[PROTOTYPE], "toString", function toString() {
                return this._k;
              });
              $GOPD.f = $getOwnPropertyDescriptor;
              $DP.f = $defineProperty;
              __webpack_require__(69).f = gOPNExt.f = $getOwnPropertyNames;
              __webpack_require__(32).f = $propertyIsEnumerable;
              __webpack_require__(50).f = $getOwnPropertySymbols;
              if (DESCRIPTORS && !__webpack_require__(27)) {
                redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
              }
              wksExt.f = function(name) {
                return wrap(wks(name));
              };
            }
            $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
            for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; )
              wks(es6Symbols[j++]);
            for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k; )
              wksDefine(wellKnownSymbols[k++]);
            $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
              "for": function(key) {
                return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
              },
              keyFor: function keyFor(sym) {
                if (!isSymbol(sym))
                  throw TypeError(sym + " is not a symbol!");
                for (var key in SymbolRegistry)
                  if (SymbolRegistry[key] === sym)
                    return key;
              },
              useSetter: function() {
                setter = true;
              },
              useSimple: function() {
                setter = false;
              }
            });
            $export($export.S + $export.F * !USE_NATIVE, "Object", {
              create: $create,
              defineProperty: $defineProperty,
              defineProperties: $defineProperties,
              getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
              getOwnPropertyNames: $getOwnPropertyNames,
              getOwnPropertySymbols: $getOwnPropertySymbols
            });
            $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
              var S = $Symbol();
              return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
            })), "JSON", {
              stringify: function stringify(it) {
                var args = [it];
                var i = 1;
                var replacer, $replacer;
                while (arguments.length > i)
                  args.push(arguments[i++]);
                $replacer = replacer = args[1];
                if (!isObject2(replacer) && it === void 0 || isSymbol(it))
                  return;
                if (!isArray(replacer))
                  replacer = function(key, value) {
                    if (typeof $replacer == "function")
                      value = $replacer.call(this, key, value);
                    if (!isSymbol(value))
                      return value;
                  };
                args[1] = replacer;
                return _stringify.apply($JSON, args);
              }
            });
            $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(19)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
            setToStringTag($Symbol, "Symbol");
            setToStringTag(Math, "Math", true);
            setToStringTag(global.JSON, "JSON", true);
          },
          function(module2, exports2, __webpack_require__) {
            var META = __webpack_require__(29)("meta");
            var isObject2 = __webpack_require__(21);
            var has = __webpack_require__(14);
            var setDesc = __webpack_require__(12).f;
            var id2 = 0;
            var isExtensible = Object.isExtensible || function() {
              return true;
            };
            var FREEZE = !__webpack_require__(22)(function() {
              return isExtensible(Object.preventExtensions({}));
            });
            var setMeta = function(it) {
              setDesc(it, META, { value: {
                i: "O" + ++id2,
                w: {}
              } });
            };
            var fastKey = function(it, create) {
              if (!isObject2(it))
                return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
              if (!has(it, META)) {
                if (!isExtensible(it))
                  return "F";
                if (!create)
                  return "E";
                setMeta(it);
              }
              return it[META].i;
            };
            var getWeak = function(it, create) {
              if (!has(it, META)) {
                if (!isExtensible(it))
                  return true;
                if (!create)
                  return false;
                setMeta(it);
              }
              return it[META].w;
            };
            var onFreeze = function(it) {
              if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META))
                setMeta(it);
              return it;
            };
            var meta = module2.exports = {
              KEY: META,
              NEED: false,
              fastKey,
              getWeak,
              onFreeze
            };
          },
          function(module2, exports2, __webpack_require__) {
            var getKeys = __webpack_require__(26);
            var gOPS = __webpack_require__(50);
            var pIE = __webpack_require__(32);
            module2.exports = function(it) {
              var result2 = getKeys(it);
              var getSymbols = gOPS.f;
              if (getSymbols) {
                var symbols = getSymbols(it);
                var isEnum = pIE.f;
                var i = 0;
                var key;
                while (symbols.length > i)
                  if (isEnum.call(it, key = symbols[i++]))
                    result2.push(key);
              }
              return result2;
            };
          },
          function(module2, exports2, __webpack_require__) {
            var cof = __webpack_require__(38);
            module2.exports = Array.isArray || function isArray(arg) {
              return cof(arg) == "Array";
            };
          },
          function(module2, exports2, __webpack_require__) {
            var toIObject = __webpack_require__(18);
            var gOPN = __webpack_require__(69).f;
            var toString = {}.toString;
            var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
            var getWindowNames = function(it) {
              try {
                return gOPN(it);
              } catch (e) {
                return windowNames.slice();
              }
            };
            module2.exports.f = function getOwnPropertyNames(it) {
              return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it));
            };
          },
          function(module2, exports2) {
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(49)("asyncIterator");
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(49)("observable");
          },
          function(module2, exports2, __webpack_require__) {
            (function(module3) {
              var require2;
              ;
              (function(global, factory) {
                true ? module3.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
              })(this, function() {
                "use strict";
                var hookCallback;
                function hooks() {
                  return hookCallback.apply(null, arguments);
                }
                function setHookCallback(callback) {
                  hookCallback = callback;
                }
                function isArray(input) {
                  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
                }
                function isObject2(input) {
                  return input != null && Object.prototype.toString.call(input) === "[object Object]";
                }
                function isObjectEmpty(obj) {
                  if (Object.getOwnPropertyNames) {
                    return Object.getOwnPropertyNames(obj).length === 0;
                  } else {
                    var k;
                    for (k in obj) {
                      if (obj.hasOwnProperty(k)) {
                        return false;
                      }
                    }
                    return true;
                  }
                }
                function isUndefined2(input) {
                  return input === void 0;
                }
                function isNumber2(input) {
                  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
                }
                function isDate(input) {
                  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
                }
                function map2(arr, fn) {
                  var res = [], i;
                  for (i = 0; i < arr.length; ++i) {
                    res.push(fn(arr[i], i));
                  }
                  return res;
                }
                function hasOwnProp(a, b) {
                  return Object.prototype.hasOwnProperty.call(a, b);
                }
                function extend2(a, b) {
                  for (var i in b) {
                    if (hasOwnProp(b, i)) {
                      a[i] = b[i];
                    }
                  }
                  if (hasOwnProp(b, "toString")) {
                    a.toString = b.toString;
                  }
                  if (hasOwnProp(b, "valueOf")) {
                    a.valueOf = b.valueOf;
                  }
                  return a;
                }
                function createUTC(input, format2, locale2, strict) {
                  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
                }
                function defaultParsingFlags() {
                  return {
                    empty: false,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: false,
                    invalidMonth: null,
                    invalidFormat: false,
                    userInvalidated: false,
                    iso: false,
                    parsedDateParts: [],
                    meridiem: null,
                    rfc2822: false,
                    weekdayMismatch: false
                  };
                }
                function getParsingFlags(m) {
                  if (m._pf == null) {
                    m._pf = defaultParsingFlags();
                  }
                  return m._pf;
                }
                var some;
                if (Array.prototype.some) {
                  some = Array.prototype.some;
                } else {
                  some = function(fun) {
                    var t = Object(this);
                    var len = t.length >>> 0;
                    for (var i = 0; i < len; i++) {
                      if (i in t && fun.call(this, t[i], i, t)) {
                        return true;
                      }
                    }
                    return false;
                  };
                }
                function isValid(m) {
                  if (m._isValid == null) {
                    var flags = getParsingFlags(m);
                    var parsedParts = some.call(flags.parsedDateParts, function(i) {
                      return i != null;
                    });
                    var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
                    if (m._strict) {
                      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
                    }
                    if (Object.isFrozen == null || !Object.isFrozen(m)) {
                      m._isValid = isNowValid;
                    } else {
                      return isNowValid;
                    }
                  }
                  return m._isValid;
                }
                function createInvalid(flags) {
                  var m = createUTC(NaN);
                  if (flags != null) {
                    extend2(getParsingFlags(m), flags);
                  } else {
                    getParsingFlags(m).userInvalidated = true;
                  }
                  return m;
                }
                var momentProperties = hooks.momentProperties = [];
                function copyConfig(to2, from2) {
                  var i, prop, val;
                  if (!isUndefined2(from2._isAMomentObject)) {
                    to2._isAMomentObject = from2._isAMomentObject;
                  }
                  if (!isUndefined2(from2._i)) {
                    to2._i = from2._i;
                  }
                  if (!isUndefined2(from2._f)) {
                    to2._f = from2._f;
                  }
                  if (!isUndefined2(from2._l)) {
                    to2._l = from2._l;
                  }
                  if (!isUndefined2(from2._strict)) {
                    to2._strict = from2._strict;
                  }
                  if (!isUndefined2(from2._tzm)) {
                    to2._tzm = from2._tzm;
                  }
                  if (!isUndefined2(from2._isUTC)) {
                    to2._isUTC = from2._isUTC;
                  }
                  if (!isUndefined2(from2._offset)) {
                    to2._offset = from2._offset;
                  }
                  if (!isUndefined2(from2._pf)) {
                    to2._pf = getParsingFlags(from2);
                  }
                  if (!isUndefined2(from2._locale)) {
                    to2._locale = from2._locale;
                  }
                  if (momentProperties.length > 0) {
                    for (i = 0; i < momentProperties.length; i++) {
                      prop = momentProperties[i];
                      val = from2[prop];
                      if (!isUndefined2(val)) {
                        to2[prop] = val;
                      }
                    }
                  }
                  return to2;
                }
                var updateInProgress = false;
                function Moment(config) {
                  copyConfig(this, config);
                  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
                  if (!this.isValid()) {
                    this._d = new Date(NaN);
                  }
                  if (updateInProgress === false) {
                    updateInProgress = true;
                    hooks.updateOffset(this);
                    updateInProgress = false;
                  }
                }
                function isMoment(obj) {
                  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
                }
                function absFloor(number) {
                  if (number < 0) {
                    return Math.ceil(number) || 0;
                  } else {
                    return Math.floor(number);
                  }
                }
                function toInt(argumentForCoercion) {
                  var coercedNumber = +argumentForCoercion, value = 0;
                  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                    value = absFloor(coercedNumber);
                  }
                  return value;
                }
                function compareArrays(array1, array2, dontConvert) {
                  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
                  for (i = 0; i < len; i++) {
                    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                      diffs++;
                    }
                  }
                  return diffs + lengthDiff;
                }
                function warn(msg) {
                  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
                    console.warn("Deprecation warning: " + msg);
                  }
                }
                function deprecate(msg, fn) {
                  var firstTime = true;
                  return extend2(function() {
                    if (hooks.deprecationHandler != null) {
                      hooks.deprecationHandler(null, msg);
                    }
                    if (firstTime) {
                      var args = [];
                      var arg;
                      for (var i = 0; i < arguments.length; i++) {
                        arg = "";
                        if (typeof arguments[i] === "object") {
                          arg += "\n[" + i + "] ";
                          for (var key in arguments[0]) {
                            arg += key + ": " + arguments[0][key] + ", ";
                          }
                          arg = arg.slice(0, -2);
                        } else {
                          arg = arguments[i];
                        }
                        args.push(arg);
                      }
                      warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
                      firstTime = false;
                    }
                    return fn.apply(this, arguments);
                  }, fn);
                }
                var deprecations = {};
                function deprecateSimple(name, msg) {
                  if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(name, msg);
                  }
                  if (!deprecations[name]) {
                    warn(msg);
                    deprecations[name] = true;
                  }
                }
                hooks.suppressDeprecationWarnings = false;
                hooks.deprecationHandler = null;
                function isFunction2(input) {
                  return input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
                }
                function set(config) {
                  var prop, i;
                  for (i in config) {
                    prop = config[i];
                    if (isFunction2(prop)) {
                      this[i] = prop;
                    } else {
                      this["_" + i] = prop;
                    }
                  }
                  this._config = config;
                  this._dayOfMonthOrdinalParseLenient = new RegExp(
                    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
                  );
                }
                function mergeConfigs(parentConfig, childConfig) {
                  var res = extend2({}, parentConfig), prop;
                  for (prop in childConfig) {
                    if (hasOwnProp(childConfig, prop)) {
                      if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
                        res[prop] = {};
                        extend2(res[prop], parentConfig[prop]);
                        extend2(res[prop], childConfig[prop]);
                      } else if (childConfig[prop] != null) {
                        res[prop] = childConfig[prop];
                      } else {
                        delete res[prop];
                      }
                    }
                  }
                  for (prop in parentConfig) {
                    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
                      res[prop] = extend2({}, res[prop]);
                    }
                  }
                  return res;
                }
                function Locale(config) {
                  if (config != null) {
                    this.set(config);
                  }
                }
                var keys;
                if (Object.keys) {
                  keys = Object.keys;
                } else {
                  keys = function(obj) {
                    var i, res = [];
                    for (i in obj) {
                      if (hasOwnProp(obj, i)) {
                        res.push(i);
                      }
                    }
                    return res;
                  };
                }
                var defaultCalendar = {
                  sameDay: "[Today at] LT",
                  nextDay: "[Tomorrow at] LT",
                  nextWeek: "dddd [at] LT",
                  lastDay: "[Yesterday at] LT",
                  lastWeek: "[Last] dddd [at] LT",
                  sameElse: "L"
                };
                function calendar(key, mom, now2) {
                  var output = this._calendar[key] || this._calendar["sameElse"];
                  return isFunction2(output) ? output.call(mom, now2) : output;
                }
                var defaultLongDateFormat = {
                  LTS: "h:mm:ss A",
                  LT: "h:mm A",
                  L: "MM/DD/YYYY",
                  LL: "MMMM D, YYYY",
                  LLL: "MMMM D, YYYY h:mm A",
                  LLLL: "dddd, MMMM D, YYYY h:mm A"
                };
                function longDateFormat(key) {
                  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
                  if (format2 || !formatUpper) {
                    return format2;
                  }
                  this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
                    return val.slice(1);
                  });
                  return this._longDateFormat[key];
                }
                var defaultInvalidDate = "Invalid date";
                function invalidDate() {
                  return this._invalidDate;
                }
                var defaultOrdinal = "%d";
                var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
                function ordinal(number) {
                  return this._ordinal.replace("%d", number);
                }
                var defaultRelativeTime = {
                  future: "in %s",
                  past: "%s ago",
                  s: "a few seconds",
                  ss: "%d seconds",
                  m: "a minute",
                  mm: "%d minutes",
                  h: "an hour",
                  hh: "%d hours",
                  d: "a day",
                  dd: "%d days",
                  M: "a month",
                  MM: "%d months",
                  y: "a year",
                  yy: "%d years"
                };
                function relativeTime(number, withoutSuffix, string, isFuture) {
                  var output = this._relativeTime[string];
                  return isFunction2(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
                }
                function pastFuture(diff2, output) {
                  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
                  return isFunction2(format2) ? format2(output) : format2.replace(/%s/i, output);
                }
                var aliases = {};
                function addUnitAlias(unit, shorthand) {
                  var lowerCase = unit.toLowerCase();
                  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
                }
                function normalizeUnits(units) {
                  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
                }
                function normalizeObjectUnits(inputObject) {
                  var normalizedInput = {}, normalizedProp, prop;
                  for (prop in inputObject) {
                    if (hasOwnProp(inputObject, prop)) {
                      normalizedProp = normalizeUnits(prop);
                      if (normalizedProp) {
                        normalizedInput[normalizedProp] = inputObject[prop];
                      }
                    }
                  }
                  return normalizedInput;
                }
                var priorities = {};
                function addUnitPriority(unit, priority) {
                  priorities[unit] = priority;
                }
                function getPrioritizedUnits(unitsObj) {
                  var units = [];
                  for (var u in unitsObj) {
                    units.push({ unit: u, priority: priorities[u] });
                  }
                  units.sort(function(a, b) {
                    return a.priority - b.priority;
                  });
                  return units;
                }
                function zeroFill(number, targetLength, forceSign) {
                  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
                  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
                }
                var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
                var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
                var formatFunctions = {};
                var formatTokenFunctions = {};
                function addFormatToken(token2, padded, ordinal2, callback) {
                  var func = callback;
                  if (typeof callback === "string") {
                    func = function() {
                      return this[callback]();
                    };
                  }
                  if (token2) {
                    formatTokenFunctions[token2] = func;
                  }
                  if (padded) {
                    formatTokenFunctions[padded[0]] = function() {
                      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                    };
                  }
                  if (ordinal2) {
                    formatTokenFunctions[ordinal2] = function() {
                      return this.localeData().ordinal(func.apply(this, arguments), token2);
                    };
                  }
                }
                function removeFormattingTokens(input) {
                  if (input.match(/\[[\s\S]/)) {
                    return input.replace(/^\[|\]$/g, "");
                  }
                  return input.replace(/\\/g, "");
                }
                function makeFormatFunction(format2) {
                  var array = format2.match(formattingTokens), i, length2;
                  for (i = 0, length2 = array.length; i < length2; i++) {
                    if (formatTokenFunctions[array[i]]) {
                      array[i] = formatTokenFunctions[array[i]];
                    } else {
                      array[i] = removeFormattingTokens(array[i]);
                    }
                  }
                  return function(mom) {
                    var output = "", i2;
                    for (i2 = 0; i2 < length2; i2++) {
                      output += isFunction2(array[i2]) ? array[i2].call(mom, format2) : array[i2];
                    }
                    return output;
                  };
                }
                function formatMoment(m, format2) {
                  if (!m.isValid()) {
                    return m.localeData().invalidDate();
                  }
                  format2 = expandFormat(format2, m.localeData());
                  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
                  return formatFunctions[format2](m);
                }
                function expandFormat(format2, locale2) {
                  var i = 5;
                  function replaceLongDateFormatTokens(input) {
                    return locale2.longDateFormat(input) || input;
                  }
                  localFormattingTokens.lastIndex = 0;
                  while (i >= 0 && localFormattingTokens.test(format2)) {
                    format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
                    localFormattingTokens.lastIndex = 0;
                    i -= 1;
                  }
                  return format2;
                }
                var match1 = /\d/;
                var match2 = /\d\d/;
                var match3 = /\d{3}/;
                var match4 = /\d{4}/;
                var match6 = /[+-]?\d{6}/;
                var match1to2 = /\d\d?/;
                var match3to4 = /\d\d\d\d?/;
                var match5to6 = /\d\d\d\d\d\d?/;
                var match1to3 = /\d{1,3}/;
                var match1to4 = /\d{1,4}/;
                var match1to6 = /[+-]?\d{1,6}/;
                var matchUnsigned = /\d+/;
                var matchSigned = /[+-]?\d+/;
                var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
                var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
                var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
                var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
                var regexes = {};
                function addRegexToken(token2, regex, strictRegex) {
                  regexes[token2] = isFunction2(regex) ? regex : function(isStrict, localeData2) {
                    return isStrict && strictRegex ? strictRegex : regex;
                  };
                }
                function getParseRegexForToken(token2, config) {
                  if (!hasOwnProp(regexes, token2)) {
                    return new RegExp(unescapeFormat(token2));
                  }
                  return regexes[token2](config._strict, config._locale);
                }
                function unescapeFormat(s) {
                  return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
                    return p1 || p2 || p3 || p4;
                  }));
                }
                function regexEscape(s) {
                  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                }
                var tokens = {};
                function addParseToken(token2, callback) {
                  var i, func = callback;
                  if (typeof token2 === "string") {
                    token2 = [token2];
                  }
                  if (isNumber2(callback)) {
                    func = function(input, array) {
                      array[callback] = toInt(input);
                    };
                  }
                  for (i = 0; i < token2.length; i++) {
                    tokens[token2[i]] = func;
                  }
                }
                function addWeekParseToken(token2, callback) {
                  addParseToken(token2, function(input, array, config, token3) {
                    config._w = config._w || {};
                    callback(input, config._w, config, token3);
                  });
                }
                function addTimeToArrayFromToken(token2, input, config) {
                  if (input != null && hasOwnProp(tokens, token2)) {
                    tokens[token2](input, config._a, config, token2);
                  }
                }
                var YEAR = 0;
                var MONTH = 1;
                var DATE = 2;
                var HOUR = 3;
                var MINUTE = 4;
                var SECOND = 5;
                var MILLISECOND = 6;
                var WEEK = 7;
                var WEEKDAY = 8;
                addFormatToken("Y", 0, 0, function() {
                  var y = this.year();
                  return y <= 9999 ? "" + y : "+" + y;
                });
                addFormatToken(0, ["YY", 2], 0, function() {
                  return this.year() % 100;
                });
                addFormatToken(0, ["YYYY", 4], 0, "year");
                addFormatToken(0, ["YYYYY", 5], 0, "year");
                addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
                addUnitAlias("year", "y");
                addUnitPriority("year", 1);
                addRegexToken("Y", matchSigned);
                addRegexToken("YY", match1to2, match2);
                addRegexToken("YYYY", match1to4, match4);
                addRegexToken("YYYYY", match1to6, match6);
                addRegexToken("YYYYYY", match1to6, match6);
                addParseToken(["YYYYY", "YYYYYY"], YEAR);
                addParseToken("YYYY", function(input, array) {
                  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
                });
                addParseToken("YY", function(input, array) {
                  array[YEAR] = hooks.parseTwoDigitYear(input);
                });
                addParseToken("Y", function(input, array) {
                  array[YEAR] = parseInt(input, 10);
                });
                function daysInYear(year) {
                  return isLeapYear(year) ? 366 : 365;
                }
                function isLeapYear(year) {
                  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
                }
                hooks.parseTwoDigitYear = function(input) {
                  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
                };
                var getSetYear = makeGetSet("FullYear", true);
                function getIsLeapYear() {
                  return isLeapYear(this.year());
                }
                function makeGetSet(unit, keepTime) {
                  return function(value) {
                    if (value != null) {
                      set$1(this, unit, value);
                      hooks.updateOffset(this, keepTime);
                      return this;
                    } else {
                      return get3(this, unit);
                    }
                  };
                }
                function get3(mom, unit) {
                  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
                }
                function set$1(mom, unit, value) {
                  if (mom.isValid() && !isNaN(value)) {
                    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
                    } else {
                      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
                    }
                  }
                }
                function stringGet(units) {
                  units = normalizeUnits(units);
                  if (isFunction2(this[units])) {
                    return this[units]();
                  }
                  return this;
                }
                function stringSet(units, value) {
                  if (typeof units === "object") {
                    units = normalizeObjectUnits(units);
                    var prioritized = getPrioritizedUnits(units);
                    for (var i = 0; i < prioritized.length; i++) {
                      this[prioritized[i].unit](units[prioritized[i].unit]);
                    }
                  } else {
                    units = normalizeUnits(units);
                    if (isFunction2(this[units])) {
                      return this[units](value);
                    }
                  }
                  return this;
                }
                function mod(n, x) {
                  return (n % x + x) % x;
                }
                var indexOf;
                if (Array.prototype.indexOf) {
                  indexOf = Array.prototype.indexOf;
                } else {
                  indexOf = function(o) {
                    var i;
                    for (i = 0; i < this.length; ++i) {
                      if (this[i] === o) {
                        return i;
                      }
                    }
                    return -1;
                  };
                }
                function daysInMonth(year, month) {
                  if (isNaN(year) || isNaN(month)) {
                    return NaN;
                  }
                  var modMonth = mod(month, 12);
                  year += (month - modMonth) / 12;
                  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
                }
                addFormatToken("M", ["MM", 2], "Mo", function() {
                  return this.month() + 1;
                });
                addFormatToken("MMM", 0, 0, function(format2) {
                  return this.localeData().monthsShort(this, format2);
                });
                addFormatToken("MMMM", 0, 0, function(format2) {
                  return this.localeData().months(this, format2);
                });
                addUnitAlias("month", "M");
                addUnitPriority("month", 8);
                addRegexToken("M", match1to2);
                addRegexToken("MM", match1to2, match2);
                addRegexToken("MMM", function(isStrict, locale2) {
                  return locale2.monthsShortRegex(isStrict);
                });
                addRegexToken("MMMM", function(isStrict, locale2) {
                  return locale2.monthsRegex(isStrict);
                });
                addParseToken(["M", "MM"], function(input, array) {
                  array[MONTH] = toInt(input) - 1;
                });
                addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
                  var month = config._locale.monthsParse(input, token2, config._strict);
                  if (month != null) {
                    array[MONTH] = month;
                  } else {
                    getParsingFlags(config).invalidMonth = input;
                  }
                });
                var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
                var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
                function localeMonths(m, format2) {
                  if (!m) {
                    return isArray(this._months) ? this._months : this._months["standalone"];
                  }
                  return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
                }
                var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
                function localeMonthsShort(m, format2) {
                  if (!m) {
                    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
                  }
                  return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
                }
                function handleStrictParse(monthName, format2, strict) {
                  var i, ii, mom, llc = monthName.toLocaleLowerCase();
                  if (!this._monthsParse) {
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                    for (i = 0; i < 12; ++i) {
                      mom = createUTC([2e3, i]);
                      this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
                      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
                    }
                  }
                  if (strict) {
                    if (format2 === "MMM") {
                      ii = indexOf.call(this._shortMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                    } else {
                      ii = indexOf.call(this._longMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                    }
                  } else {
                    if (format2 === "MMM") {
                      ii = indexOf.call(this._shortMonthsParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._longMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                    } else {
                      ii = indexOf.call(this._longMonthsParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._shortMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                    }
                  }
                }
                function localeMonthsParse(monthName, format2, strict) {
                  var i, mom, regex;
                  if (this._monthsParseExact) {
                    return handleStrictParse.call(this, monthName, format2, strict);
                  }
                  if (!this._monthsParse) {
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                  }
                  for (i = 0; i < 12; i++) {
                    mom = createUTC([2e3, i]);
                    if (strict && !this._longMonthsParse[i]) {
                      this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                      this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
                    }
                    if (!strict && !this._monthsParse[i]) {
                      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                    }
                    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                      return i;
                    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                      return i;
                    } else if (!strict && this._monthsParse[i].test(monthName)) {
                      return i;
                    }
                  }
                }
                function setMonth(mom, value) {
                  var dayOfMonth;
                  if (!mom.isValid()) {
                    return mom;
                  }
                  if (typeof value === "string") {
                    if (/^\d+$/.test(value)) {
                      value = toInt(value);
                    } else {
                      value = mom.localeData().monthsParse(value);
                      if (!isNumber2(value)) {
                        return mom;
                      }
                    }
                  }
                  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
                  return mom;
                }
                function getSetMonth(value) {
                  if (value != null) {
                    setMonth(this, value);
                    hooks.updateOffset(this, true);
                    return this;
                  } else {
                    return get3(this, "Month");
                  }
                }
                function getDaysInMonth() {
                  return daysInMonth(this.year(), this.month());
                }
                var defaultMonthsShortRegex = matchWord;
                function monthsShortRegex(isStrict) {
                  if (this._monthsParseExact) {
                    if (!hasOwnProp(this, "_monthsRegex")) {
                      computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                      return this._monthsShortStrictRegex;
                    } else {
                      return this._monthsShortRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_monthsShortRegex")) {
                      this._monthsShortRegex = defaultMonthsShortRegex;
                    }
                    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
                  }
                }
                var defaultMonthsRegex = matchWord;
                function monthsRegex(isStrict) {
                  if (this._monthsParseExact) {
                    if (!hasOwnProp(this, "_monthsRegex")) {
                      computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                      return this._monthsStrictRegex;
                    } else {
                      return this._monthsRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_monthsRegex")) {
                      this._monthsRegex = defaultMonthsRegex;
                    }
                    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
                  }
                }
                function computeMonthsParse() {
                  function cmpLenRev(a, b) {
                    return b.length - a.length;
                  }
                  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
                  for (i = 0; i < 12; i++) {
                    mom = createUTC([2e3, i]);
                    shortPieces.push(this.monthsShort(mom, ""));
                    longPieces.push(this.months(mom, ""));
                    mixedPieces.push(this.months(mom, ""));
                    mixedPieces.push(this.monthsShort(mom, ""));
                  }
                  shortPieces.sort(cmpLenRev);
                  longPieces.sort(cmpLenRev);
                  mixedPieces.sort(cmpLenRev);
                  for (i = 0; i < 12; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                  }
                  for (i = 0; i < 24; i++) {
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                  }
                  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                  this._monthsShortRegex = this._monthsRegex;
                  this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                  this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
                }
                function createDate(y, m, d, h, M, s, ms) {
                  var date = new Date(y, m, d, h, M, s, ms);
                  if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                  }
                  return date;
                }
                function createUTCDate(y) {
                  var date = new Date(Date.UTC.apply(null, arguments));
                  if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                  }
                  return date;
                }
                function firstWeekOffset(year, dow, doy) {
                  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
                  return -fwdlw + fwd - 1;
                }
                function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
                  if (dayOfYear <= 0) {
                    resYear = year - 1;
                    resDayOfYear = daysInYear(resYear) + dayOfYear;
                  } else if (dayOfYear > daysInYear(year)) {
                    resYear = year + 1;
                    resDayOfYear = dayOfYear - daysInYear(year);
                  } else {
                    resYear = year;
                    resDayOfYear = dayOfYear;
                  }
                  return {
                    year: resYear,
                    dayOfYear: resDayOfYear
                  };
                }
                function weekOfYear(mom, dow, doy) {
                  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
                  if (week < 1) {
                    resYear = mom.year() - 1;
                    resWeek = week + weeksInYear(resYear, dow, doy);
                  } else if (week > weeksInYear(mom.year(), dow, doy)) {
                    resWeek = week - weeksInYear(mom.year(), dow, doy);
                    resYear = mom.year() + 1;
                  } else {
                    resYear = mom.year();
                    resWeek = week;
                  }
                  return {
                    week: resWeek,
                    year: resYear
                  };
                }
                function weeksInYear(year, dow, doy) {
                  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
                }
                addFormatToken("w", ["ww", 2], "wo", "week");
                addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
                addUnitAlias("week", "w");
                addUnitAlias("isoWeek", "W");
                addUnitPriority("week", 5);
                addUnitPriority("isoWeek", 5);
                addRegexToken("w", match1to2);
                addRegexToken("ww", match1to2, match2);
                addRegexToken("W", match1to2);
                addRegexToken("WW", match1to2, match2);
                addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
                  week[token2.substr(0, 1)] = toInt(input);
                });
                function localeWeek(mom) {
                  return weekOfYear(mom, this._week.dow, this._week.doy).week;
                }
                var defaultLocaleWeek = {
                  dow: 0,
                  doy: 6
                };
                function localeFirstDayOfWeek() {
                  return this._week.dow;
                }
                function localeFirstDayOfYear() {
                  return this._week.doy;
                }
                function getSetWeek(input) {
                  var week = this.localeData().week(this);
                  return input == null ? week : this.add((input - week) * 7, "d");
                }
                function getSetISOWeek(input) {
                  var week = weekOfYear(this, 1, 4).week;
                  return input == null ? week : this.add((input - week) * 7, "d");
                }
                addFormatToken("d", 0, "do", "day");
                addFormatToken("dd", 0, 0, function(format2) {
                  return this.localeData().weekdaysMin(this, format2);
                });
                addFormatToken("ddd", 0, 0, function(format2) {
                  return this.localeData().weekdaysShort(this, format2);
                });
                addFormatToken("dddd", 0, 0, function(format2) {
                  return this.localeData().weekdays(this, format2);
                });
                addFormatToken("e", 0, 0, "weekday");
                addFormatToken("E", 0, 0, "isoWeekday");
                addUnitAlias("day", "d");
                addUnitAlias("weekday", "e");
                addUnitAlias("isoWeekday", "E");
                addUnitPriority("day", 11);
                addUnitPriority("weekday", 11);
                addUnitPriority("isoWeekday", 11);
                addRegexToken("d", match1to2);
                addRegexToken("e", match1to2);
                addRegexToken("E", match1to2);
                addRegexToken("dd", function(isStrict, locale2) {
                  return locale2.weekdaysMinRegex(isStrict);
                });
                addRegexToken("ddd", function(isStrict, locale2) {
                  return locale2.weekdaysShortRegex(isStrict);
                });
                addRegexToken("dddd", function(isStrict, locale2) {
                  return locale2.weekdaysRegex(isStrict);
                });
                addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
                  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
                  if (weekday != null) {
                    week.d = weekday;
                  } else {
                    getParsingFlags(config).invalidWeekday = input;
                  }
                });
                addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
                  week[token2] = toInt(input);
                });
                function parseWeekday(input, locale2) {
                  if (typeof input !== "string") {
                    return input;
                  }
                  if (!isNaN(input)) {
                    return parseInt(input, 10);
                  }
                  input = locale2.weekdaysParse(input);
                  if (typeof input === "number") {
                    return input;
                  }
                  return null;
                }
                function parseIsoWeekday(input, locale2) {
                  if (typeof input === "string") {
                    return locale2.weekdaysParse(input) % 7 || 7;
                  }
                  return isNaN(input) ? null : input;
                }
                var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
                function localeWeekdays(m, format2) {
                  if (!m) {
                    return isArray(this._weekdays) ? this._weekdays : this._weekdays["standalone"];
                  }
                  return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format2) ? "format" : "standalone"][m.day()];
                }
                var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
                function localeWeekdaysShort(m) {
                  return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
                }
                var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
                function localeWeekdaysMin(m) {
                  return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
                }
                function handleStrictParse$1(weekdayName, format2, strict) {
                  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
                  if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._minWeekdaysParse = [];
                    for (i = 0; i < 7; ++i) {
                      mom = createUTC([2e3, 1]).day(i);
                      this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
                      this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
                      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
                    }
                  }
                  if (strict) {
                    if (format2 === "dddd") {
                      ii = indexOf.call(this._weekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    } else if (format2 === "ddd") {
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    } else {
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    }
                  } else {
                    if (format2 === "dddd") {
                      ii = indexOf.call(this._weekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    } else if (format2 === "ddd") {
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._weekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    } else {
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._weekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    }
                  }
                }
                function localeWeekdaysParse(weekdayName, format2, strict) {
                  var i, mom, regex;
                  if (this._weekdaysParseExact) {
                    return handleStrictParse$1.call(this, weekdayName, format2, strict);
                  }
                  if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._minWeekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._fullWeekdaysParse = [];
                  }
                  for (i = 0; i < 7; i++) {
                    mom = createUTC([2e3, 1]).day(i);
                    if (strict && !this._fullWeekdaysParse[i]) {
                      this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
                      this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
                      this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
                    }
                    if (!this._weekdaysParse[i]) {
                      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
                    }
                    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
                      return i;
                    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
                      return i;
                    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
                      return i;
                    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                      return i;
                    }
                  }
                }
                function getSetDayOfWeek(input) {
                  if (!this.isValid()) {
                    return input != null ? this : NaN;
                  }
                  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                  if (input != null) {
                    input = parseWeekday(input, this.localeData());
                    return this.add(input - day, "d");
                  } else {
                    return day;
                  }
                }
                function getSetLocaleDayOfWeek(input) {
                  if (!this.isValid()) {
                    return input != null ? this : NaN;
                  }
                  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                  return input == null ? weekday : this.add(input - weekday, "d");
                }
                function getSetISODayOfWeek(input) {
                  if (!this.isValid()) {
                    return input != null ? this : NaN;
                  }
                  if (input != null) {
                    var weekday = parseIsoWeekday(input, this.localeData());
                    return this.day(this.day() % 7 ? weekday : weekday - 7);
                  } else {
                    return this.day() || 7;
                  }
                }
                var defaultWeekdaysRegex = matchWord;
                function weekdaysRegex(isStrict) {
                  if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                      computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                      return this._weekdaysStrictRegex;
                    } else {
                      return this._weekdaysRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                      this._weekdaysRegex = defaultWeekdaysRegex;
                    }
                    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
                  }
                }
                var defaultWeekdaysShortRegex = matchWord;
                function weekdaysShortRegex(isStrict) {
                  if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                      computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                      return this._weekdaysShortStrictRegex;
                    } else {
                      return this._weekdaysShortRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
                      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                    }
                    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
                  }
                }
                var defaultWeekdaysMinRegex = matchWord;
                function weekdaysMinRegex(isStrict) {
                  if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                      computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                      return this._weekdaysMinStrictRegex;
                    } else {
                      return this._weekdaysMinRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
                      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                    }
                    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
                  }
                }
                function computeWeekdaysParse() {
                  function cmpLenRev(a, b) {
                    return b.length - a.length;
                  }
                  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
                  for (i = 0; i < 7; i++) {
                    mom = createUTC([2e3, 1]).day(i);
                    minp = this.weekdaysMin(mom, "");
                    shortp = this.weekdaysShort(mom, "");
                    longp = this.weekdays(mom, "");
                    minPieces.push(minp);
                    shortPieces.push(shortp);
                    longPieces.push(longp);
                    mixedPieces.push(minp);
                    mixedPieces.push(shortp);
                    mixedPieces.push(longp);
                  }
                  minPieces.sort(cmpLenRev);
                  shortPieces.sort(cmpLenRev);
                  longPieces.sort(cmpLenRev);
                  mixedPieces.sort(cmpLenRev);
                  for (i = 0; i < 7; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                  }
                  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                  this._weekdaysShortRegex = this._weekdaysRegex;
                  this._weekdaysMinRegex = this._weekdaysRegex;
                  this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                  this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
                  this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
                }
                function hFormat() {
                  return this.hours() % 12 || 12;
                }
                function kFormat() {
                  return this.hours() || 24;
                }
                addFormatToken("H", ["HH", 2], 0, "hour");
                addFormatToken("h", ["hh", 2], 0, hFormat);
                addFormatToken("k", ["kk", 2], 0, kFormat);
                addFormatToken("hmm", 0, 0, function() {
                  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
                });
                addFormatToken("hmmss", 0, 0, function() {
                  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
                });
                addFormatToken("Hmm", 0, 0, function() {
                  return "" + this.hours() + zeroFill(this.minutes(), 2);
                });
                addFormatToken("Hmmss", 0, 0, function() {
                  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
                });
                function meridiem(token2, lowercase) {
                  addFormatToken(token2, 0, 0, function() {
                    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                  });
                }
                meridiem("a", true);
                meridiem("A", false);
                addUnitAlias("hour", "h");
                addUnitPriority("hour", 13);
                function matchMeridiem(isStrict, locale2) {
                  return locale2._meridiemParse;
                }
                addRegexToken("a", matchMeridiem);
                addRegexToken("A", matchMeridiem);
                addRegexToken("H", match1to2);
                addRegexToken("h", match1to2);
                addRegexToken("k", match1to2);
                addRegexToken("HH", match1to2, match2);
                addRegexToken("hh", match1to2, match2);
                addRegexToken("kk", match1to2, match2);
                addRegexToken("hmm", match3to4);
                addRegexToken("hmmss", match5to6);
                addRegexToken("Hmm", match3to4);
                addRegexToken("Hmmss", match5to6);
                addParseToken(["H", "HH"], HOUR);
                addParseToken(["k", "kk"], function(input, array, config) {
                  var kInput = toInt(input);
                  array[HOUR] = kInput === 24 ? 0 : kInput;
                });
                addParseToken(["a", "A"], function(input, array, config) {
                  config._isPm = config._locale.isPM(input);
                  config._meridiem = input;
                });
                addParseToken(["h", "hh"], function(input, array, config) {
                  array[HOUR] = toInt(input);
                  getParsingFlags(config).bigHour = true;
                });
                addParseToken("hmm", function(input, array, config) {
                  var pos = input.length - 2;
                  array[HOUR] = toInt(input.substr(0, pos));
                  array[MINUTE] = toInt(input.substr(pos));
                  getParsingFlags(config).bigHour = true;
                });
                addParseToken("hmmss", function(input, array, config) {
                  var pos1 = input.length - 4;
                  var pos2 = input.length - 2;
                  array[HOUR] = toInt(input.substr(0, pos1));
                  array[MINUTE] = toInt(input.substr(pos1, 2));
                  array[SECOND] = toInt(input.substr(pos2));
                  getParsingFlags(config).bigHour = true;
                });
                addParseToken("Hmm", function(input, array, config) {
                  var pos = input.length - 2;
                  array[HOUR] = toInt(input.substr(0, pos));
                  array[MINUTE] = toInt(input.substr(pos));
                });
                addParseToken("Hmmss", function(input, array, config) {
                  var pos1 = input.length - 4;
                  var pos2 = input.length - 2;
                  array[HOUR] = toInt(input.substr(0, pos1));
                  array[MINUTE] = toInt(input.substr(pos1, 2));
                  array[SECOND] = toInt(input.substr(pos2));
                });
                function localeIsPM(input) {
                  return (input + "").toLowerCase().charAt(0) === "p";
                }
                var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
                function localeMeridiem(hours2, minutes2, isLower) {
                  if (hours2 > 11) {
                    return isLower ? "pm" : "PM";
                  } else {
                    return isLower ? "am" : "AM";
                  }
                }
                var getSetHour = makeGetSet("Hours", true);
                var baseConfig = {
                  calendar: defaultCalendar,
                  longDateFormat: defaultLongDateFormat,
                  invalidDate: defaultInvalidDate,
                  ordinal: defaultOrdinal,
                  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                  relativeTime: defaultRelativeTime,
                  months: defaultLocaleMonths,
                  monthsShort: defaultLocaleMonthsShort,
                  week: defaultLocaleWeek,
                  weekdays: defaultLocaleWeekdays,
                  weekdaysMin: defaultLocaleWeekdaysMin,
                  weekdaysShort: defaultLocaleWeekdaysShort,
                  meridiemParse: defaultLocaleMeridiemParse
                };
                var locales = {};
                var localeFamilies = {};
                var globalLocale;
                function normalizeLocale(key) {
                  return key ? key.toLowerCase().replace("_", "-") : key;
                }
                function chooseLocale(names) {
                  var i = 0, j, next, locale2, split;
                  while (i < names.length) {
                    split = normalizeLocale(names[i]).split("-");
                    j = split.length;
                    next = normalizeLocale(names[i + 1]);
                    next = next ? next.split("-") : null;
                    while (j > 0) {
                      locale2 = loadLocale(split.slice(0, j).join("-"));
                      if (locale2) {
                        return locale2;
                      }
                      if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                        break;
                      }
                      j--;
                    }
                    i++;
                  }
                  return globalLocale;
                }
                function loadLocale(name) {
                  var oldLocale = null;
                  if (!locales[name] && typeof module3 !== "undefined" && module3 && module3.exports) {
                    try {
                      oldLocale = globalLocale._abbr;
                      var aliasedRequire = require2;
                      !function webpackMissingModule() {
                        var e = new Error('Cannot find module "./locale"');
                        e.code = "MODULE_NOT_FOUND";
                        throw e;
                      }();
                      getSetGlobalLocale(oldLocale);
                    } catch (e) {
                    }
                  }
                  return locales[name];
                }
                function getSetGlobalLocale(key, values) {
                  var data;
                  if (key) {
                    if (isUndefined2(values)) {
                      data = getLocale(key);
                    } else {
                      data = defineLocale(key, values);
                    }
                    if (data) {
                      globalLocale = data;
                    } else {
                      if (typeof console !== "undefined" && console.warn) {
                        console.warn("Locale " + key + " not found. Did you forget to load it?");
                      }
                    }
                  }
                  return globalLocale._abbr;
                }
                function defineLocale(name, config) {
                  if (config !== null) {
                    var locale2, parentConfig = baseConfig;
                    config.abbr = name;
                    if (locales[name] != null) {
                      deprecateSimple(
                        "defineLocaleOverride",
                        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
                      );
                      parentConfig = locales[name]._config;
                    } else if (config.parentLocale != null) {
                      if (locales[config.parentLocale] != null) {
                        parentConfig = locales[config.parentLocale]._config;
                      } else {
                        locale2 = loadLocale(config.parentLocale);
                        if (locale2 != null) {
                          parentConfig = locale2._config;
                        } else {
                          if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                          }
                          localeFamilies[config.parentLocale].push({
                            name,
                            config
                          });
                          return null;
                        }
                      }
                    }
                    locales[name] = new Locale(mergeConfigs(parentConfig, config));
                    if (localeFamilies[name]) {
                      localeFamilies[name].forEach(function(x) {
                        defineLocale(x.name, x.config);
                      });
                    }
                    getSetGlobalLocale(name);
                    return locales[name];
                  } else {
                    delete locales[name];
                    return null;
                  }
                }
                function updateLocale(name, config) {
                  if (config != null) {
                    var locale2, tmpLocale, parentConfig = baseConfig;
                    tmpLocale = loadLocale(name);
                    if (tmpLocale != null) {
                      parentConfig = tmpLocale._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    locale2 = new Locale(config);
                    locale2.parentLocale = locales[name];
                    locales[name] = locale2;
                    getSetGlobalLocale(name);
                  } else {
                    if (locales[name] != null) {
                      if (locales[name].parentLocale != null) {
                        locales[name] = locales[name].parentLocale;
                      } else if (locales[name] != null) {
                        delete locales[name];
                      }
                    }
                  }
                  return locales[name];
                }
                function getLocale(key) {
                  var locale2;
                  if (key && key._locale && key._locale._abbr) {
                    key = key._locale._abbr;
                  }
                  if (!key) {
                    return globalLocale;
                  }
                  if (!isArray(key)) {
                    locale2 = loadLocale(key);
                    if (locale2) {
                      return locale2;
                    }
                    key = [key];
                  }
                  return chooseLocale(key);
                }
                function listLocales() {
                  return keys(locales);
                }
                function checkOverflow(m) {
                  var overflow;
                  var a = m._a;
                  if (a && getParsingFlags(m).overflow === -2) {
                    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
                    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                      overflow = DATE;
                    }
                    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                      overflow = WEEK;
                    }
                    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                      overflow = WEEKDAY;
                    }
                    getParsingFlags(m).overflow = overflow;
                  }
                  return m;
                }
                function defaults2(a, b, c) {
                  if (a != null) {
                    return a;
                  }
                  if (b != null) {
                    return b;
                  }
                  return c;
                }
                function currentDateArray(config) {
                  var nowValue = new Date(hooks.now());
                  if (config._useUTC) {
                    return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
                  }
                  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
                }
                function configFromArray(config) {
                  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
                  if (config._d) {
                    return;
                  }
                  currentDate = currentDateArray(config);
                  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                    dayOfYearFromWeekInfo(config);
                  }
                  if (config._dayOfYear != null) {
                    yearToUse = defaults2(config._a[YEAR], currentDate[YEAR]);
                    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                      getParsingFlags(config)._overflowDayOfYear = true;
                    }
                    date = createUTCDate(yearToUse, 0, config._dayOfYear);
                    config._a[MONTH] = date.getUTCMonth();
                    config._a[DATE] = date.getUTCDate();
                  }
                  for (i = 0; i < 3 && config._a[i] == null; ++i) {
                    config._a[i] = input[i] = currentDate[i];
                  }
                  for (; i < 7; i++) {
                    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
                  }
                  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
                    config._nextDay = true;
                    config._a[HOUR] = 0;
                  }
                  config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
                  if (config._tzm != null) {
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                  }
                  if (config._nextDay) {
                    config._a[HOUR] = 24;
                  }
                  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
                    getParsingFlags(config).weekdayMismatch = true;
                  }
                }
                function dayOfYearFromWeekInfo(config) {
                  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
                  w = config._w;
                  if (w.GG != null || w.W != null || w.E != null) {
                    dow = 1;
                    doy = 4;
                    weekYear = defaults2(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
                    week = defaults2(w.W, 1);
                    weekday = defaults2(w.E, 1);
                    if (weekday < 1 || weekday > 7) {
                      weekdayOverflow = true;
                    }
                  } else {
                    dow = config._locale._week.dow;
                    doy = config._locale._week.doy;
                    var curWeek = weekOfYear(createLocal(), dow, doy);
                    weekYear = defaults2(w.gg, config._a[YEAR], curWeek.year);
                    week = defaults2(w.w, curWeek.week);
                    if (w.d != null) {
                      weekday = w.d;
                      if (weekday < 0 || weekday > 6) {
                        weekdayOverflow = true;
                      }
                    } else if (w.e != null) {
                      weekday = w.e + dow;
                      if (w.e < 0 || w.e > 6) {
                        weekdayOverflow = true;
                      }
                    } else {
                      weekday = dow;
                    }
                  }
                  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                    getParsingFlags(config)._overflowWeeks = true;
                  } else if (weekdayOverflow != null) {
                    getParsingFlags(config)._overflowWeekday = true;
                  } else {
                    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                    config._a[YEAR] = temp.year;
                    config._dayOfYear = temp.dayOfYear;
                  }
                }
                var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
                var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
                var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
                var isoDates = [
                  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
                  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
                  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
                  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
                  ["YYYY-DDD", /\d{4}-\d{3}/],
                  ["YYYY-MM", /\d{4}-\d\d/, false],
                  ["YYYYYYMMDD", /[+-]\d{10}/],
                  ["YYYYMMDD", /\d{8}/],
                  ["GGGG[W]WWE", /\d{4}W\d{3}/],
                  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
                  ["YYYYDDD", /\d{7}/]
                ];
                var isoTimes = [
                  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
                  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
                  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
                  ["HH:mm", /\d\d:\d\d/],
                  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
                  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
                  ["HHmmss", /\d\d\d\d\d\d/],
                  ["HHmm", /\d\d\d\d/],
                  ["HH", /\d\d/]
                ];
                var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
                function configFromISO(config) {
                  var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
                  if (match) {
                    getParsingFlags(config).iso = true;
                    for (i = 0, l = isoDates.length; i < l; i++) {
                      if (isoDates[i][1].exec(match[1])) {
                        dateFormat = isoDates[i][0];
                        allowTime = isoDates[i][2] !== false;
                        break;
                      }
                    }
                    if (dateFormat == null) {
                      config._isValid = false;
                      return;
                    }
                    if (match[3]) {
                      for (i = 0, l = isoTimes.length; i < l; i++) {
                        if (isoTimes[i][1].exec(match[3])) {
                          timeFormat = (match[2] || " ") + isoTimes[i][0];
                          break;
                        }
                      }
                      if (timeFormat == null) {
                        config._isValid = false;
                        return;
                      }
                    }
                    if (!allowTime && timeFormat != null) {
                      config._isValid = false;
                      return;
                    }
                    if (match[4]) {
                      if (tzRegex.exec(match[4])) {
                        tzFormat = "Z";
                      } else {
                        config._isValid = false;
                        return;
                      }
                    }
                    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
                    configFromStringAndFormat(config);
                  } else {
                    config._isValid = false;
                  }
                }
                var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
                function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
                  var result2 = [
                    untruncateYear(yearStr),
                    defaultLocaleMonthsShort.indexOf(monthStr),
                    parseInt(dayStr, 10),
                    parseInt(hourStr, 10),
                    parseInt(minuteStr, 10)
                  ];
                  if (secondStr) {
                    result2.push(parseInt(secondStr, 10));
                  }
                  return result2;
                }
                function untruncateYear(yearStr) {
                  var year = parseInt(yearStr, 10);
                  if (year <= 49) {
                    return 2e3 + year;
                  } else if (year <= 999) {
                    return 1900 + year;
                  }
                  return year;
                }
                function preprocessRFC2822(s) {
                  return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
                }
                function checkWeekday(weekdayStr, parsedInput, config) {
                  if (weekdayStr) {
                    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
                    if (weekdayProvided !== weekdayActual) {
                      getParsingFlags(config).weekdayMismatch = true;
                      config._isValid = false;
                      return false;
                    }
                  }
                  return true;
                }
                var obsOffsets = {
                  UT: 0,
                  GMT: 0,
                  EDT: -4 * 60,
                  EST: -5 * 60,
                  CDT: -5 * 60,
                  CST: -6 * 60,
                  MDT: -6 * 60,
                  MST: -7 * 60,
                  PDT: -7 * 60,
                  PST: -8 * 60
                };
                function calculateOffset(obsOffset, militaryOffset, numOffset) {
                  if (obsOffset) {
                    return obsOffsets[obsOffset];
                  } else if (militaryOffset) {
                    return 0;
                  } else {
                    var hm = parseInt(numOffset, 10);
                    var m = hm % 100, h = (hm - m) / 100;
                    return h * 60 + m;
                  }
                }
                function configFromRFC2822(config) {
                  var match = rfc2822.exec(preprocessRFC2822(config._i));
                  if (match) {
                    var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
                    if (!checkWeekday(match[1], parsedArray, config)) {
                      return;
                    }
                    config._a = parsedArray;
                    config._tzm = calculateOffset(match[8], match[9], match[10]);
                    config._d = createUTCDate.apply(null, config._a);
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                    getParsingFlags(config).rfc2822 = true;
                  } else {
                    config._isValid = false;
                  }
                }
                function configFromString(config) {
                  var matched = aspNetJsonRegex.exec(config._i);
                  if (matched !== null) {
                    config._d = new Date(+matched[1]);
                    return;
                  }
                  configFromISO(config);
                  if (config._isValid === false) {
                    delete config._isValid;
                  } else {
                    return;
                  }
                  configFromRFC2822(config);
                  if (config._isValid === false) {
                    delete config._isValid;
                  } else {
                    return;
                  }
                  hooks.createFromInputFallback(config);
                }
                hooks.createFromInputFallback = deprecate(
                  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
                  function(config) {
                    config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
                  }
                );
                hooks.ISO_8601 = function() {
                };
                hooks.RFC_2822 = function() {
                };
                function configFromStringAndFormat(config) {
                  if (config._f === hooks.ISO_8601) {
                    configFromISO(config);
                    return;
                  }
                  if (config._f === hooks.RFC_2822) {
                    configFromRFC2822(config);
                    return;
                  }
                  config._a = [];
                  getParsingFlags(config).empty = true;
                  var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0;
                  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
                  for (i = 0; i < tokens2.length; i++) {
                    token2 = tokens2[i];
                    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
                    if (parsedInput) {
                      skipped = string.substr(0, string.indexOf(parsedInput));
                      if (skipped.length > 0) {
                        getParsingFlags(config).unusedInput.push(skipped);
                      }
                      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                      totalParsedInputLength += parsedInput.length;
                    }
                    if (formatTokenFunctions[token2]) {
                      if (parsedInput) {
                        getParsingFlags(config).empty = false;
                      } else {
                        getParsingFlags(config).unusedTokens.push(token2);
                      }
                      addTimeToArrayFromToken(token2, parsedInput, config);
                    } else if (config._strict && !parsedInput) {
                      getParsingFlags(config).unusedTokens.push(token2);
                    }
                  }
                  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                  if (string.length > 0) {
                    getParsingFlags(config).unusedInput.push(string);
                  }
                  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
                    getParsingFlags(config).bigHour = void 0;
                  }
                  getParsingFlags(config).parsedDateParts = config._a.slice(0);
                  getParsingFlags(config).meridiem = config._meridiem;
                  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
                  configFromArray(config);
                  checkOverflow(config);
                }
                function meridiemFixWrap(locale2, hour, meridiem2) {
                  var isPm;
                  if (meridiem2 == null) {
                    return hour;
                  }
                  if (locale2.meridiemHour != null) {
                    return locale2.meridiemHour(hour, meridiem2);
                  } else if (locale2.isPM != null) {
                    isPm = locale2.isPM(meridiem2);
                    if (isPm && hour < 12) {
                      hour += 12;
                    }
                    if (!isPm && hour === 12) {
                      hour = 0;
                    }
                    return hour;
                  } else {
                    return hour;
                  }
                }
                function configFromStringAndArray(config) {
                  var tempConfig, bestMoment, scoreToBeat, i, currentScore;
                  if (config._f.length === 0) {
                    getParsingFlags(config).invalidFormat = true;
                    config._d = new Date(NaN);
                    return;
                  }
                  for (i = 0; i < config._f.length; i++) {
                    currentScore = 0;
                    tempConfig = copyConfig({}, config);
                    if (config._useUTC != null) {
                      tempConfig._useUTC = config._useUTC;
                    }
                    tempConfig._f = config._f[i];
                    configFromStringAndFormat(tempConfig);
                    if (!isValid(tempConfig)) {
                      continue;
                    }
                    currentScore += getParsingFlags(tempConfig).charsLeftOver;
                    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
                    getParsingFlags(tempConfig).score = currentScore;
                    if (scoreToBeat == null || currentScore < scoreToBeat) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                    }
                  }
                  extend2(config, bestMoment || tempConfig);
                }
                function configFromObject(config) {
                  if (config._d) {
                    return;
                  }
                  var i = normalizeObjectUnits(config._i);
                  config._a = map2([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
                    return obj && parseInt(obj, 10);
                  });
                  configFromArray(config);
                }
                function createFromConfig(config) {
                  var res = new Moment(checkOverflow(prepareConfig(config)));
                  if (res._nextDay) {
                    res.add(1, "d");
                    res._nextDay = void 0;
                  }
                  return res;
                }
                function prepareConfig(config) {
                  var input = config._i, format2 = config._f;
                  config._locale = config._locale || getLocale(config._l);
                  if (input === null || format2 === void 0 && input === "") {
                    return createInvalid({ nullInput: true });
                  }
                  if (typeof input === "string") {
                    config._i = input = config._locale.preparse(input);
                  }
                  if (isMoment(input)) {
                    return new Moment(checkOverflow(input));
                  } else if (isDate(input)) {
                    config._d = input;
                  } else if (isArray(format2)) {
                    configFromStringAndArray(config);
                  } else if (format2) {
                    configFromStringAndFormat(config);
                  } else {
                    configFromInput(config);
                  }
                  if (!isValid(config)) {
                    config._d = null;
                  }
                  return config;
                }
                function configFromInput(config) {
                  var input = config._i;
                  if (isUndefined2(input)) {
                    config._d = new Date(hooks.now());
                  } else if (isDate(input)) {
                    config._d = new Date(input.valueOf());
                  } else if (typeof input === "string") {
                    configFromString(config);
                  } else if (isArray(input)) {
                    config._a = map2(input.slice(0), function(obj) {
                      return parseInt(obj, 10);
                    });
                    configFromArray(config);
                  } else if (isObject2(input)) {
                    configFromObject(config);
                  } else if (isNumber2(input)) {
                    config._d = new Date(input);
                  } else {
                    hooks.createFromInputFallback(config);
                  }
                }
                function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
                  var c = {};
                  if (locale2 === true || locale2 === false) {
                    strict = locale2;
                    locale2 = void 0;
                  }
                  if (isObject2(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
                    input = void 0;
                  }
                  c._isAMomentObject = true;
                  c._useUTC = c._isUTC = isUTC;
                  c._l = locale2;
                  c._i = input;
                  c._f = format2;
                  c._strict = strict;
                  return createFromConfig(c);
                }
                function createLocal(input, format2, locale2, strict) {
                  return createLocalOrUTC(input, format2, locale2, strict, false);
                }
                var prototypeMin = deprecate(
                  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
                  function() {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                      return other < this ? this : other;
                    } else {
                      return createInvalid();
                    }
                  }
                );
                var prototypeMax = deprecate(
                  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
                  function() {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                      return other > this ? this : other;
                    } else {
                      return createInvalid();
                    }
                  }
                );
                function pickBy(fn, moments) {
                  var res, i;
                  if (moments.length === 1 && isArray(moments[0])) {
                    moments = moments[0];
                  }
                  if (!moments.length) {
                    return createLocal();
                  }
                  res = moments[0];
                  for (i = 1; i < moments.length; ++i) {
                    if (!moments[i].isValid() || moments[i][fn](res)) {
                      res = moments[i];
                    }
                  }
                  return res;
                }
                function min() {
                  var args = [].slice.call(arguments, 0);
                  return pickBy("isBefore", args);
                }
                function max() {
                  var args = [].slice.call(arguments, 0);
                  return pickBy("isAfter", args);
                }
                var now = function() {
                  return Date.now ? Date.now() : +new Date();
                };
                var ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
                function isDurationValid(m) {
                  for (var key in m) {
                    if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                      return false;
                    }
                  }
                  var unitHasDecimal = false;
                  for (var i = 0; i < ordering.length; ++i) {
                    if (m[ordering[i]]) {
                      if (unitHasDecimal) {
                        return false;
                      }
                      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                        unitHasDecimal = true;
                      }
                    }
                  }
                  return true;
                }
                function isValid$1() {
                  return this._isValid;
                }
                function createInvalid$1() {
                  return createDuration(NaN);
                }
                function Duration(duration) {
                  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
                  this._isValid = isDurationValid(normalizedInput);
                  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
                  this._days = +days2 + weeks2 * 7;
                  this._months = +months2 + quarters * 3 + years2 * 12;
                  this._data = {};
                  this._locale = getLocale();
                  this._bubble();
                }
                function isDuration(obj) {
                  return obj instanceof Duration;
                }
                function absRound(number) {
                  if (number < 0) {
                    return Math.round(-1 * number) * -1;
                  } else {
                    return Math.round(number);
                  }
                }
                function offset(token2, separator) {
                  addFormatToken(token2, 0, 0, function() {
                    var offset2 = this.utcOffset();
                    var sign2 = "+";
                    if (offset2 < 0) {
                      offset2 = -offset2;
                      sign2 = "-";
                    }
                    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
                  });
                }
                offset("Z", ":");
                offset("ZZ", "");
                addRegexToken("Z", matchShortOffset);
                addRegexToken("ZZ", matchShortOffset);
                addParseToken(["Z", "ZZ"], function(input, array, config) {
                  config._useUTC = true;
                  config._tzm = offsetFromString(matchShortOffset, input);
                });
                var chunkOffset = /([\+\-]|\d\d)/gi;
                function offsetFromString(matcher, string) {
                  var matches = (string || "").match(matcher);
                  if (matches === null) {
                    return null;
                  }
                  var chunk = matches[matches.length - 1] || [];
                  var parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
                  var minutes2 = +(parts[1] * 60) + toInt(parts[2]);
                  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
                }
                function cloneWithOffset(input, model) {
                  var res, diff2;
                  if (model._isUTC) {
                    res = model.clone();
                    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
                    res._d.setTime(res._d.valueOf() + diff2);
                    hooks.updateOffset(res, false);
                    return res;
                  } else {
                    return createLocal(input).local();
                  }
                }
                function getDateOffset(m) {
                  return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
                }
                hooks.updateOffset = function() {
                };
                function getSetOffset(input, keepLocalTime, keepMinutes) {
                  var offset2 = this._offset || 0, localAdjust;
                  if (!this.isValid()) {
                    return input != null ? this : NaN;
                  }
                  if (input != null) {
                    if (typeof input === "string") {
                      input = offsetFromString(matchShortOffset, input);
                      if (input === null) {
                        return this;
                      }
                    } else if (Math.abs(input) < 16 && !keepMinutes) {
                      input = input * 60;
                    }
                    if (!this._isUTC && keepLocalTime) {
                      localAdjust = getDateOffset(this);
                    }
                    this._offset = input;
                    this._isUTC = true;
                    if (localAdjust != null) {
                      this.add(localAdjust, "m");
                    }
                    if (offset2 !== input) {
                      if (!keepLocalTime || this._changeInProgress) {
                        addSubtract(this, createDuration(input - offset2, "m"), 1, false);
                      } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        hooks.updateOffset(this, true);
                        this._changeInProgress = null;
                      }
                    }
                    return this;
                  } else {
                    return this._isUTC ? offset2 : getDateOffset(this);
                  }
                }
                function getSetZone(input, keepLocalTime) {
                  if (input != null) {
                    if (typeof input !== "string") {
                      input = -input;
                    }
                    this.utcOffset(input, keepLocalTime);
                    return this;
                  } else {
                    return -this.utcOffset();
                  }
                }
                function setOffsetToUTC(keepLocalTime) {
                  return this.utcOffset(0, keepLocalTime);
                }
                function setOffsetToLocal(keepLocalTime) {
                  if (this._isUTC) {
                    this.utcOffset(0, keepLocalTime);
                    this._isUTC = false;
                    if (keepLocalTime) {
                      this.subtract(getDateOffset(this), "m");
                    }
                  }
                  return this;
                }
                function setOffsetToParsedOffset() {
                  if (this._tzm != null) {
                    this.utcOffset(this._tzm, false, true);
                  } else if (typeof this._i === "string") {
                    var tZone = offsetFromString(matchOffset, this._i);
                    if (tZone != null) {
                      this.utcOffset(tZone);
                    } else {
                      this.utcOffset(0, true);
                    }
                  }
                  return this;
                }
                function hasAlignedHourOffset(input) {
                  if (!this.isValid()) {
                    return false;
                  }
                  input = input ? createLocal(input).utcOffset() : 0;
                  return (this.utcOffset() - input) % 60 === 0;
                }
                function isDaylightSavingTime() {
                  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
                }
                function isDaylightSavingTimeShifted() {
                  if (!isUndefined2(this._isDSTShifted)) {
                    return this._isDSTShifted;
                  }
                  var c = {};
                  copyConfig(c, this);
                  c = prepareConfig(c);
                  if (c._a) {
                    var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
                  } else {
                    this._isDSTShifted = false;
                  }
                  return this._isDSTShifted;
                }
                function isLocal() {
                  return this.isValid() ? !this._isUTC : false;
                }
                function isUtcOffset() {
                  return this.isValid() ? this._isUTC : false;
                }
                function isUtc() {
                  return this.isValid() ? this._isUTC && this._offset === 0 : false;
                }
                var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
                var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
                function createDuration(input, key) {
                  var duration = input, match = null, sign2, ret, diffRes;
                  if (isDuration(input)) {
                    duration = {
                      ms: input._milliseconds,
                      d: input._days,
                      M: input._months
                    };
                  } else if (isNumber2(input)) {
                    duration = {};
                    if (key) {
                      duration[key] = input;
                    } else {
                      duration.milliseconds = input;
                    }
                  } else if (!!(match = aspNetRegex.exec(input))) {
                    sign2 = match[1] === "-" ? -1 : 1;
                    duration = {
                      y: 0,
                      d: toInt(match[DATE]) * sign2,
                      h: toInt(match[HOUR]) * sign2,
                      m: toInt(match[MINUTE]) * sign2,
                      s: toInt(match[SECOND]) * sign2,
                      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
                    };
                  } else if (!!(match = isoRegex.exec(input))) {
                    sign2 = match[1] === "-" ? -1 : 1;
                    duration = {
                      y: parseIso(match[2], sign2),
                      M: parseIso(match[3], sign2),
                      w: parseIso(match[4], sign2),
                      d: parseIso(match[5], sign2),
                      h: parseIso(match[6], sign2),
                      m: parseIso(match[7], sign2),
                      s: parseIso(match[8], sign2)
                    };
                  } else if (duration == null) {
                    duration = {};
                  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
                    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
                    duration = {};
                    duration.ms = diffRes.milliseconds;
                    duration.M = diffRes.months;
                  }
                  ret = new Duration(duration);
                  if (isDuration(input) && hasOwnProp(input, "_locale")) {
                    ret._locale = input._locale;
                  }
                  return ret;
                }
                createDuration.fn = Duration.prototype;
                createDuration.invalid = createInvalid$1;
                function parseIso(inp, sign2) {
                  var res = inp && parseFloat(inp.replace(",", "."));
                  return (isNaN(res) ? 0 : res) * sign2;
                }
                function positiveMomentsDifference(base, other) {
                  var res = { milliseconds: 0, months: 0 };
                  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
                  if (base.clone().add(res.months, "M").isAfter(other)) {
                    --res.months;
                  }
                  res.milliseconds = +other - +base.clone().add(res.months, "M");
                  return res;
                }
                function momentsDifference(base, other) {
                  var res;
                  if (!(base.isValid() && other.isValid())) {
                    return { milliseconds: 0, months: 0 };
                  }
                  other = cloneWithOffset(other, base);
                  if (base.isBefore(other)) {
                    res = positiveMomentsDifference(base, other);
                  } else {
                    res = positiveMomentsDifference(other, base);
                    res.milliseconds = -res.milliseconds;
                    res.months = -res.months;
                  }
                  return res;
                }
                function createAdder(direction, name) {
                  return function(val, period) {
                    var dur, tmp;
                    if (period !== null && !isNaN(+period)) {
                      deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
                      tmp = val;
                      val = period;
                      period = tmp;
                    }
                    val = typeof val === "string" ? +val : val;
                    dur = createDuration(val, period);
                    addSubtract(this, dur, direction);
                    return this;
                  };
                }
                function addSubtract(mom, duration, isAdding, updateOffset) {
                  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
                  if (!mom.isValid()) {
                    return;
                  }
                  updateOffset = updateOffset == null ? true : updateOffset;
                  if (months2) {
                    setMonth(mom, get3(mom, "Month") + months2 * isAdding);
                  }
                  if (days2) {
                    set$1(mom, "Date", get3(mom, "Date") + days2 * isAdding);
                  }
                  if (milliseconds2) {
                    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
                  }
                  if (updateOffset) {
                    hooks.updateOffset(mom, days2 || months2);
                  }
                }
                var add2 = createAdder(1, "add");
                var subtract = createAdder(-1, "subtract");
                function getCalendarFormat(myMoment, now2) {
                  var diff2 = myMoment.diff(now2, "days", true);
                  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
                }
                function calendar$1(time, formats) {
                  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse";
                  var output = formats && (isFunction2(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
                  return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
                }
                function clone() {
                  return new Moment(this);
                }
                function isAfter(input, units) {
                  var localInput = isMoment(input) ? input : createLocal(input);
                  if (!(this.isValid() && localInput.isValid())) {
                    return false;
                  }
                  units = normalizeUnits(units) || "millisecond";
                  if (units === "millisecond") {
                    return this.valueOf() > localInput.valueOf();
                  } else {
                    return localInput.valueOf() < this.clone().startOf(units).valueOf();
                  }
                }
                function isBefore(input, units) {
                  var localInput = isMoment(input) ? input : createLocal(input);
                  if (!(this.isValid() && localInput.isValid())) {
                    return false;
                  }
                  units = normalizeUnits(units) || "millisecond";
                  if (units === "millisecond") {
                    return this.valueOf() < localInput.valueOf();
                  } else {
                    return this.clone().endOf(units).valueOf() < localInput.valueOf();
                  }
                }
                function isBetween(from2, to2, units, inclusivity) {
                  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
                  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                    return false;
                  }
                  inclusivity = inclusivity || "()";
                  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
                }
                function isSame(input, units) {
                  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
                  if (!(this.isValid() && localInput.isValid())) {
                    return false;
                  }
                  units = normalizeUnits(units) || "millisecond";
                  if (units === "millisecond") {
                    return this.valueOf() === localInput.valueOf();
                  } else {
                    inputMs = localInput.valueOf();
                    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
                  }
                }
                function isSameOrAfter(input, units) {
                  return this.isSame(input, units) || this.isAfter(input, units);
                }
                function isSameOrBefore(input, units) {
                  return this.isSame(input, units) || this.isBefore(input, units);
                }
                function diff(input, units, asFloat) {
                  var that, zoneDelta, output;
                  if (!this.isValid()) {
                    return NaN;
                  }
                  that = cloneWithOffset(input, this);
                  if (!that.isValid()) {
                    return NaN;
                  }
                  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
                  units = normalizeUnits(units);
                  switch (units) {
                    case "year":
                      output = monthDiff(this, that) / 12;
                      break;
                    case "month":
                      output = monthDiff(this, that);
                      break;
                    case "quarter":
                      output = monthDiff(this, that) / 3;
                      break;
                    case "second":
                      output = (this - that) / 1e3;
                      break;
                    case "minute":
                      output = (this - that) / 6e4;
                      break;
                    case "hour":
                      output = (this - that) / 36e5;
                      break;
                    case "day":
                      output = (this - that - zoneDelta) / 864e5;
                      break;
                    case "week":
                      output = (this - that - zoneDelta) / 6048e5;
                      break;
                    default:
                      output = this - that;
                  }
                  return asFloat ? output : absFloor(output);
                }
                function monthDiff(a, b) {
                  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
                  if (b - anchor < 0) {
                    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
                    adjust = (b - anchor) / (anchor - anchor2);
                  } else {
                    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
                    adjust = (b - anchor) / (anchor2 - anchor);
                  }
                  return -(wholeMonthDiff + adjust) || 0;
                }
                hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
                hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
                function toString() {
                  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
                }
                function toISOString(keepOffset) {
                  if (!this.isValid()) {
                    return null;
                  }
                  var utc = keepOffset !== true;
                  var m = utc ? this.clone().utc() : this;
                  if (m.year() < 0 || m.year() > 9999) {
                    return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
                  }
                  if (isFunction2(Date.prototype.toISOString)) {
                    if (utc) {
                      return this.toDate().toISOString();
                    } else {
                      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
                    }
                  }
                  return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
                }
                function inspect() {
                  if (!this.isValid()) {
                    return "moment.invalid(/* " + this._i + " */)";
                  }
                  var func = "moment";
                  var zone = "";
                  if (!this.isLocal()) {
                    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
                    zone = "Z";
                  }
                  var prefix = "[" + func + '("]';
                  var year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
                  var datetime = "-MM-DD[T]HH:mm:ss.SSS";
                  var suffix = zone + '[")]';
                  return this.format(prefix + year + datetime + suffix);
                }
                function format(inputString) {
                  if (!inputString) {
                    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
                  }
                  var output = formatMoment(this, inputString);
                  return this.localeData().postformat(output);
                }
                function from(time, withoutSuffix) {
                  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
                    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
                  } else {
                    return this.localeData().invalidDate();
                  }
                }
                function fromNow(withoutSuffix) {
                  return this.from(createLocal(), withoutSuffix);
                }
                function to(time, withoutSuffix) {
                  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
                    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
                  } else {
                    return this.localeData().invalidDate();
                  }
                }
                function toNow(withoutSuffix) {
                  return this.to(createLocal(), withoutSuffix);
                }
                function locale(key) {
                  var newLocaleData;
                  if (key === void 0) {
                    return this._locale._abbr;
                  } else {
                    newLocaleData = getLocale(key);
                    if (newLocaleData != null) {
                      this._locale = newLocaleData;
                    }
                    return this;
                  }
                }
                var lang = deprecate(
                  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
                  function(key) {
                    if (key === void 0) {
                      return this.localeData();
                    } else {
                      return this.locale(key);
                    }
                  }
                );
                function localeData() {
                  return this._locale;
                }
                function startOf(units) {
                  units = normalizeUnits(units);
                  switch (units) {
                    case "year":
                      this.month(0);
                    case "quarter":
                    case "month":
                      this.date(1);
                    case "week":
                    case "isoWeek":
                    case "day":
                    case "date":
                      this.hours(0);
                    case "hour":
                      this.minutes(0);
                    case "minute":
                      this.seconds(0);
                    case "second":
                      this.milliseconds(0);
                  }
                  if (units === "week") {
                    this.weekday(0);
                  }
                  if (units === "isoWeek") {
                    this.isoWeekday(1);
                  }
                  if (units === "quarter") {
                    this.month(Math.floor(this.month() / 3) * 3);
                  }
                  return this;
                }
                function endOf(units) {
                  units = normalizeUnits(units);
                  if (units === void 0 || units === "millisecond") {
                    return this;
                  }
                  if (units === "date") {
                    units = "day";
                  }
                  return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
                }
                function valueOf() {
                  return this._d.valueOf() - (this._offset || 0) * 6e4;
                }
                function unix() {
                  return Math.floor(this.valueOf() / 1e3);
                }
                function toDate() {
                  return new Date(this.valueOf());
                }
                function toArray2() {
                  var m = this;
                  return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
                }
                function toObject() {
                  var m = this;
                  return {
                    years: m.year(),
                    months: m.month(),
                    date: m.date(),
                    hours: m.hours(),
                    minutes: m.minutes(),
                    seconds: m.seconds(),
                    milliseconds: m.milliseconds()
                  };
                }
                function toJSON() {
                  return this.isValid() ? this.toISOString() : null;
                }
                function isValid$2() {
                  return isValid(this);
                }
                function parsingFlags() {
                  return extend2({}, getParsingFlags(this));
                }
                function invalidAt() {
                  return getParsingFlags(this).overflow;
                }
                function creationData() {
                  return {
                    input: this._i,
                    format: this._f,
                    locale: this._locale,
                    isUTC: this._isUTC,
                    strict: this._strict
                  };
                }
                addFormatToken(0, ["gg", 2], 0, function() {
                  return this.weekYear() % 100;
                });
                addFormatToken(0, ["GG", 2], 0, function() {
                  return this.isoWeekYear() % 100;
                });
                function addWeekYearFormatToken(token2, getter) {
                  addFormatToken(0, [token2, token2.length], 0, getter);
                }
                addWeekYearFormatToken("gggg", "weekYear");
                addWeekYearFormatToken("ggggg", "weekYear");
                addWeekYearFormatToken("GGGG", "isoWeekYear");
                addWeekYearFormatToken("GGGGG", "isoWeekYear");
                addUnitAlias("weekYear", "gg");
                addUnitAlias("isoWeekYear", "GG");
                addUnitPriority("weekYear", 1);
                addUnitPriority("isoWeekYear", 1);
                addRegexToken("G", matchSigned);
                addRegexToken("g", matchSigned);
                addRegexToken("GG", match1to2, match2);
                addRegexToken("gg", match1to2, match2);
                addRegexToken("GGGG", match1to4, match4);
                addRegexToken("gggg", match1to4, match4);
                addRegexToken("GGGGG", match1to6, match6);
                addRegexToken("ggggg", match1to6, match6);
                addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
                  week[token2.substr(0, 2)] = toInt(input);
                });
                addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
                  week[token2] = hooks.parseTwoDigitYear(input);
                });
                function getSetWeekYear(input) {
                  return getSetWeekYearHelper.call(
                    this,
                    input,
                    this.week(),
                    this.weekday(),
                    this.localeData()._week.dow,
                    this.localeData()._week.doy
                  );
                }
                function getSetISOWeekYear(input) {
                  return getSetWeekYearHelper.call(
                    this,
                    input,
                    this.isoWeek(),
                    this.isoWeekday(),
                    1,
                    4
                  );
                }
                function getISOWeeksInYear() {
                  return weeksInYear(this.year(), 1, 4);
                }
                function getWeeksInYear() {
                  var weekInfo = this.localeData()._week;
                  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
                }
                function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                  var weeksTarget;
                  if (input == null) {
                    return weekOfYear(this, dow, doy).year;
                  } else {
                    weeksTarget = weeksInYear(input, dow, doy);
                    if (week > weeksTarget) {
                      week = weeksTarget;
                    }
                    return setWeekAll.call(this, input, week, weekday, dow, doy);
                  }
                }
                function setWeekAll(weekYear, week, weekday, dow, doy) {
                  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
                  this.year(date.getUTCFullYear());
                  this.month(date.getUTCMonth());
                  this.date(date.getUTCDate());
                  return this;
                }
                addFormatToken("Q", 0, "Qo", "quarter");
                addUnitAlias("quarter", "Q");
                addUnitPriority("quarter", 7);
                addRegexToken("Q", match1);
                addParseToken("Q", function(input, array) {
                  array[MONTH] = (toInt(input) - 1) * 3;
                });
                function getSetQuarter(input) {
                  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
                }
                addFormatToken("D", ["DD", 2], "Do", "date");
                addUnitAlias("date", "D");
                addUnitPriority("date", 9);
                addRegexToken("D", match1to2);
                addRegexToken("DD", match1to2, match2);
                addRegexToken("Do", function(isStrict, locale2) {
                  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
                });
                addParseToken(["D", "DD"], DATE);
                addParseToken("Do", function(input, array) {
                  array[DATE] = toInt(input.match(match1to2)[0]);
                });
                var getSetDayOfMonth = makeGetSet("Date", true);
                addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
                addUnitAlias("dayOfYear", "DDD");
                addUnitPriority("dayOfYear", 4);
                addRegexToken("DDD", match1to3);
                addRegexToken("DDDD", match3);
                addParseToken(["DDD", "DDDD"], function(input, array, config) {
                  config._dayOfYear = toInt(input);
                });
                function getSetDayOfYear(input) {
                  var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
                  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
                }
                addFormatToken("m", ["mm", 2], 0, "minute");
                addUnitAlias("minute", "m");
                addUnitPriority("minute", 14);
                addRegexToken("m", match1to2);
                addRegexToken("mm", match1to2, match2);
                addParseToken(["m", "mm"], MINUTE);
                var getSetMinute = makeGetSet("Minutes", false);
                addFormatToken("s", ["ss", 2], 0, "second");
                addUnitAlias("second", "s");
                addUnitPriority("second", 15);
                addRegexToken("s", match1to2);
                addRegexToken("ss", match1to2, match2);
                addParseToken(["s", "ss"], SECOND);
                var getSetSecond = makeGetSet("Seconds", false);
                addFormatToken("S", 0, 0, function() {
                  return ~~(this.millisecond() / 100);
                });
                addFormatToken(0, ["SS", 2], 0, function() {
                  return ~~(this.millisecond() / 10);
                });
                addFormatToken(0, ["SSS", 3], 0, "millisecond");
                addFormatToken(0, ["SSSS", 4], 0, function() {
                  return this.millisecond() * 10;
                });
                addFormatToken(0, ["SSSSS", 5], 0, function() {
                  return this.millisecond() * 100;
                });
                addFormatToken(0, ["SSSSSS", 6], 0, function() {
                  return this.millisecond() * 1e3;
                });
                addFormatToken(0, ["SSSSSSS", 7], 0, function() {
                  return this.millisecond() * 1e4;
                });
                addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
                  return this.millisecond() * 1e5;
                });
                addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
                  return this.millisecond() * 1e6;
                });
                addUnitAlias("millisecond", "ms");
                addUnitPriority("millisecond", 16);
                addRegexToken("S", match1to3, match1);
                addRegexToken("SS", match1to3, match2);
                addRegexToken("SSS", match1to3, match3);
                var token;
                for (token = "SSSS"; token.length <= 9; token += "S") {
                  addRegexToken(token, matchUnsigned);
                }
                function parseMs(input, array) {
                  array[MILLISECOND] = toInt(("0." + input) * 1e3);
                }
                for (token = "S"; token.length <= 9; token += "S") {
                  addParseToken(token, parseMs);
                }
                var getSetMillisecond = makeGetSet("Milliseconds", false);
                addFormatToken("z", 0, 0, "zoneAbbr");
                addFormatToken("zz", 0, 0, "zoneName");
                function getZoneAbbr() {
                  return this._isUTC ? "UTC" : "";
                }
                function getZoneName() {
                  return this._isUTC ? "Coordinated Universal Time" : "";
                }
                var proto = Moment.prototype;
                proto.add = add2;
                proto.calendar = calendar$1;
                proto.clone = clone;
                proto.diff = diff;
                proto.endOf = endOf;
                proto.format = format;
                proto.from = from;
                proto.fromNow = fromNow;
                proto.to = to;
                proto.toNow = toNow;
                proto.get = stringGet;
                proto.invalidAt = invalidAt;
                proto.isAfter = isAfter;
                proto.isBefore = isBefore;
                proto.isBetween = isBetween;
                proto.isSame = isSame;
                proto.isSameOrAfter = isSameOrAfter;
                proto.isSameOrBefore = isSameOrBefore;
                proto.isValid = isValid$2;
                proto.lang = lang;
                proto.locale = locale;
                proto.localeData = localeData;
                proto.max = prototypeMax;
                proto.min = prototypeMin;
                proto.parsingFlags = parsingFlags;
                proto.set = stringSet;
                proto.startOf = startOf;
                proto.subtract = subtract;
                proto.toArray = toArray2;
                proto.toObject = toObject;
                proto.toDate = toDate;
                proto.toISOString = toISOString;
                proto.inspect = inspect;
                proto.toJSON = toJSON;
                proto.toString = toString;
                proto.unix = unix;
                proto.valueOf = valueOf;
                proto.creationData = creationData;
                proto.year = getSetYear;
                proto.isLeapYear = getIsLeapYear;
                proto.weekYear = getSetWeekYear;
                proto.isoWeekYear = getSetISOWeekYear;
                proto.quarter = proto.quarters = getSetQuarter;
                proto.month = getSetMonth;
                proto.daysInMonth = getDaysInMonth;
                proto.week = proto.weeks = getSetWeek;
                proto.isoWeek = proto.isoWeeks = getSetISOWeek;
                proto.weeksInYear = getWeeksInYear;
                proto.isoWeeksInYear = getISOWeeksInYear;
                proto.date = getSetDayOfMonth;
                proto.day = proto.days = getSetDayOfWeek;
                proto.weekday = getSetLocaleDayOfWeek;
                proto.isoWeekday = getSetISODayOfWeek;
                proto.dayOfYear = getSetDayOfYear;
                proto.hour = proto.hours = getSetHour;
                proto.minute = proto.minutes = getSetMinute;
                proto.second = proto.seconds = getSetSecond;
                proto.millisecond = proto.milliseconds = getSetMillisecond;
                proto.utcOffset = getSetOffset;
                proto.utc = setOffsetToUTC;
                proto.local = setOffsetToLocal;
                proto.parseZone = setOffsetToParsedOffset;
                proto.hasAlignedHourOffset = hasAlignedHourOffset;
                proto.isDST = isDaylightSavingTime;
                proto.isLocal = isLocal;
                proto.isUtcOffset = isUtcOffset;
                proto.isUtc = isUtc;
                proto.isUTC = isUtc;
                proto.zoneAbbr = getZoneAbbr;
                proto.zoneName = getZoneName;
                proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
                proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
                proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
                proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
                proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
                function createUnix(input) {
                  return createLocal(input * 1e3);
                }
                function createInZone() {
                  return createLocal.apply(null, arguments).parseZone();
                }
                function preParsePostFormat(string) {
                  return string;
                }
                var proto$1 = Locale.prototype;
                proto$1.calendar = calendar;
                proto$1.longDateFormat = longDateFormat;
                proto$1.invalidDate = invalidDate;
                proto$1.ordinal = ordinal;
                proto$1.preparse = preParsePostFormat;
                proto$1.postformat = preParsePostFormat;
                proto$1.relativeTime = relativeTime;
                proto$1.pastFuture = pastFuture;
                proto$1.set = set;
                proto$1.months = localeMonths;
                proto$1.monthsShort = localeMonthsShort;
                proto$1.monthsParse = localeMonthsParse;
                proto$1.monthsRegex = monthsRegex;
                proto$1.monthsShortRegex = monthsShortRegex;
                proto$1.week = localeWeek;
                proto$1.firstDayOfYear = localeFirstDayOfYear;
                proto$1.firstDayOfWeek = localeFirstDayOfWeek;
                proto$1.weekdays = localeWeekdays;
                proto$1.weekdaysMin = localeWeekdaysMin;
                proto$1.weekdaysShort = localeWeekdaysShort;
                proto$1.weekdaysParse = localeWeekdaysParse;
                proto$1.weekdaysRegex = weekdaysRegex;
                proto$1.weekdaysShortRegex = weekdaysShortRegex;
                proto$1.weekdaysMinRegex = weekdaysMinRegex;
                proto$1.isPM = localeIsPM;
                proto$1.meridiem = localeMeridiem;
                function get$1(format2, index, field, setter) {
                  var locale2 = getLocale();
                  var utc = createUTC().set(setter, index);
                  return locale2[field](utc, format2);
                }
                function listMonthsImpl(format2, index, field) {
                  if (isNumber2(format2)) {
                    index = format2;
                    format2 = void 0;
                  }
                  format2 = format2 || "";
                  if (index != null) {
                    return get$1(format2, index, field, "month");
                  }
                  var i;
                  var out = [];
                  for (i = 0; i < 12; i++) {
                    out[i] = get$1(format2, i, field, "month");
                  }
                  return out;
                }
                function listWeekdaysImpl(localeSorted, format2, index, field) {
                  if (typeof localeSorted === "boolean") {
                    if (isNumber2(format2)) {
                      index = format2;
                      format2 = void 0;
                    }
                    format2 = format2 || "";
                  } else {
                    format2 = localeSorted;
                    index = format2;
                    localeSorted = false;
                    if (isNumber2(format2)) {
                      index = format2;
                      format2 = void 0;
                    }
                    format2 = format2 || "";
                  }
                  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0;
                  if (index != null) {
                    return get$1(format2, (index + shift) % 7, field, "day");
                  }
                  var i;
                  var out = [];
                  for (i = 0; i < 7; i++) {
                    out[i] = get$1(format2, (i + shift) % 7, field, "day");
                  }
                  return out;
                }
                function listMonths(format2, index) {
                  return listMonthsImpl(format2, index, "months");
                }
                function listMonthsShort(format2, index) {
                  return listMonthsImpl(format2, index, "monthsShort");
                }
                function listWeekdays(localeSorted, format2, index) {
                  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
                }
                function listWeekdaysShort(localeSorted, format2, index) {
                  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
                }
                function listWeekdaysMin(localeSorted, format2, index) {
                  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
                }
                getSetGlobalLocale("en", {
                  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                  ordinal: function(number) {
                    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                    return number + output;
                  }
                });
                hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
                hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
                var mathAbs = Math.abs;
                function abs() {
                  var data = this._data;
                  this._milliseconds = mathAbs(this._milliseconds);
                  this._days = mathAbs(this._days);
                  this._months = mathAbs(this._months);
                  data.milliseconds = mathAbs(data.milliseconds);
                  data.seconds = mathAbs(data.seconds);
                  data.minutes = mathAbs(data.minutes);
                  data.hours = mathAbs(data.hours);
                  data.months = mathAbs(data.months);
                  data.years = mathAbs(data.years);
                  return this;
                }
                function addSubtract$1(duration, input, value, direction) {
                  var other = createDuration(input, value);
                  duration._milliseconds += direction * other._milliseconds;
                  duration._days += direction * other._days;
                  duration._months += direction * other._months;
                  return duration._bubble();
                }
                function add$1(input, value) {
                  return addSubtract$1(this, input, value, 1);
                }
                function subtract$1(input, value) {
                  return addSubtract$1(this, input, value, -1);
                }
                function absCeil(number) {
                  if (number < 0) {
                    return Math.floor(number);
                  } else {
                    return Math.ceil(number);
                  }
                }
                function bubble() {
                  var milliseconds2 = this._milliseconds;
                  var days2 = this._days;
                  var months2 = this._months;
                  var data = this._data;
                  var seconds2, minutes2, hours2, years2, monthsFromDays;
                  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
                    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
                    days2 = 0;
                    months2 = 0;
                  }
                  data.milliseconds = milliseconds2 % 1e3;
                  seconds2 = absFloor(milliseconds2 / 1e3);
                  data.seconds = seconds2 % 60;
                  minutes2 = absFloor(seconds2 / 60);
                  data.minutes = minutes2 % 60;
                  hours2 = absFloor(minutes2 / 60);
                  data.hours = hours2 % 24;
                  days2 += absFloor(hours2 / 24);
                  monthsFromDays = absFloor(daysToMonths(days2));
                  months2 += monthsFromDays;
                  days2 -= absCeil(monthsToDays(monthsFromDays));
                  years2 = absFloor(months2 / 12);
                  months2 %= 12;
                  data.days = days2;
                  data.months = months2;
                  data.years = years2;
                  return this;
                }
                function daysToMonths(days2) {
                  return days2 * 4800 / 146097;
                }
                function monthsToDays(months2) {
                  return months2 * 146097 / 4800;
                }
                function as(units) {
                  if (!this.isValid()) {
                    return NaN;
                  }
                  var days2;
                  var months2;
                  var milliseconds2 = this._milliseconds;
                  units = normalizeUnits(units);
                  if (units === "month" || units === "year") {
                    days2 = this._days + milliseconds2 / 864e5;
                    months2 = this._months + daysToMonths(days2);
                    return units === "month" ? months2 : months2 / 12;
                  } else {
                    days2 = this._days + Math.round(monthsToDays(this._months));
                    switch (units) {
                      case "week":
                        return days2 / 7 + milliseconds2 / 6048e5;
                      case "day":
                        return days2 + milliseconds2 / 864e5;
                      case "hour":
                        return days2 * 24 + milliseconds2 / 36e5;
                      case "minute":
                        return days2 * 1440 + milliseconds2 / 6e4;
                      case "second":
                        return days2 * 86400 + milliseconds2 / 1e3;
                      case "millisecond":
                        return Math.floor(days2 * 864e5) + milliseconds2;
                      default:
                        throw new Error("Unknown unit " + units);
                    }
                  }
                }
                function valueOf$1() {
                  if (!this.isValid()) {
                    return NaN;
                  }
                  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
                }
                function makeAs(alias) {
                  return function() {
                    return this.as(alias);
                  };
                }
                var asMilliseconds = makeAs("ms");
                var asSeconds = makeAs("s");
                var asMinutes = makeAs("m");
                var asHours = makeAs("h");
                var asDays = makeAs("d");
                var asWeeks = makeAs("w");
                var asMonths = makeAs("M");
                var asYears = makeAs("y");
                function clone$1() {
                  return createDuration(this);
                }
                function get$2(units) {
                  units = normalizeUnits(units);
                  return this.isValid() ? this[units + "s"]() : NaN;
                }
                function makeGetter(name) {
                  return function() {
                    return this.isValid() ? this._data[name] : NaN;
                  };
                }
                var milliseconds = makeGetter("milliseconds");
                var seconds = makeGetter("seconds");
                var minutes = makeGetter("minutes");
                var hours = makeGetter("hours");
                var days = makeGetter("days");
                var months = makeGetter("months");
                var years = makeGetter("years");
                function weeks() {
                  return absFloor(this.days() / 7);
                }
                var round = Math.round;
                var thresholds = {
                  ss: 44,
                  s: 45,
                  m: 45,
                  h: 22,
                  d: 26,
                  M: 11
                };
                function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
                  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
                }
                function relativeTime$1(posNegDuration, withoutSuffix, locale2) {
                  var duration = createDuration(posNegDuration).abs();
                  var seconds2 = round(duration.as("s"));
                  var minutes2 = round(duration.as("m"));
                  var hours2 = round(duration.as("h"));
                  var days2 = round(duration.as("d"));
                  var months2 = round(duration.as("M"));
                  var years2 = round(duration.as("y"));
                  var a = seconds2 <= thresholds.ss && ["s", seconds2] || seconds2 < thresholds.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds.d && ["dd", days2] || months2 <= 1 && ["M"] || months2 < thresholds.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
                  a[2] = withoutSuffix;
                  a[3] = +posNegDuration > 0;
                  a[4] = locale2;
                  return substituteTimeAgo.apply(null, a);
                }
                function getSetRelativeTimeRounding(roundingFunction) {
                  if (roundingFunction === void 0) {
                    return round;
                  }
                  if (typeof roundingFunction === "function") {
                    round = roundingFunction;
                    return true;
                  }
                  return false;
                }
                function getSetRelativeTimeThreshold(threshold, limit) {
                  if (thresholds[threshold] === void 0) {
                    return false;
                  }
                  if (limit === void 0) {
                    return thresholds[threshold];
                  }
                  thresholds[threshold] = limit;
                  if (threshold === "s") {
                    thresholds.ss = limit - 1;
                  }
                  return true;
                }
                function humanize(withSuffix) {
                  if (!this.isValid()) {
                    return this.localeData().invalidDate();
                  }
                  var locale2 = this.localeData();
                  var output = relativeTime$1(this, !withSuffix, locale2);
                  if (withSuffix) {
                    output = locale2.pastFuture(+this, output);
                  }
                  return locale2.postformat(output);
                }
                var abs$1 = Math.abs;
                function sign(x) {
                  return (x > 0) - (x < 0) || +x;
                }
                function toISOString$1() {
                  if (!this.isValid()) {
                    return this.localeData().invalidDate();
                  }
                  var seconds2 = abs$1(this._milliseconds) / 1e3;
                  var days2 = abs$1(this._days);
                  var months2 = abs$1(this._months);
                  var minutes2, hours2, years2;
                  minutes2 = absFloor(seconds2 / 60);
                  hours2 = absFloor(minutes2 / 60);
                  seconds2 %= 60;
                  minutes2 %= 60;
                  years2 = absFloor(months2 / 12);
                  months2 %= 12;
                  var Y = years2;
                  var M = months2;
                  var D = days2;
                  var h = hours2;
                  var m = minutes2;
                  var s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
                  var total = this.asSeconds();
                  if (!total) {
                    return "P0D";
                  }
                  var totalSign = total < 0 ? "-" : "";
                  var ymSign = sign(this._months) !== sign(total) ? "-" : "";
                  var daysSign = sign(this._days) !== sign(total) ? "-" : "";
                  var hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
                  return totalSign + "P" + (Y ? ymSign + Y + "Y" : "") + (M ? ymSign + M + "M" : "") + (D ? daysSign + D + "D" : "") + (h || m || s ? "T" : "") + (h ? hmsSign + h + "H" : "") + (m ? hmsSign + m + "M" : "") + (s ? hmsSign + s + "S" : "");
                }
                var proto$2 = Duration.prototype;
                proto$2.isValid = isValid$1;
                proto$2.abs = abs;
                proto$2.add = add$1;
                proto$2.subtract = subtract$1;
                proto$2.as = as;
                proto$2.asMilliseconds = asMilliseconds;
                proto$2.asSeconds = asSeconds;
                proto$2.asMinutes = asMinutes;
                proto$2.asHours = asHours;
                proto$2.asDays = asDays;
                proto$2.asWeeks = asWeeks;
                proto$2.asMonths = asMonths;
                proto$2.asYears = asYears;
                proto$2.valueOf = valueOf$1;
                proto$2._bubble = bubble;
                proto$2.clone = clone$1;
                proto$2.get = get$2;
                proto$2.milliseconds = milliseconds;
                proto$2.seconds = seconds;
                proto$2.minutes = minutes;
                proto$2.hours = hours;
                proto$2.days = days;
                proto$2.weeks = weeks;
                proto$2.months = months;
                proto$2.years = years;
                proto$2.humanize = humanize;
                proto$2.toISOString = toISOString$1;
                proto$2.toString = toISOString$1;
                proto$2.toJSON = toISOString$1;
                proto$2.locale = locale;
                proto$2.localeData = localeData;
                proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
                proto$2.lang = lang;
                addFormatToken("X", 0, 0, "unix");
                addFormatToken("x", 0, 0, "valueOf");
                addRegexToken("x", matchSigned);
                addRegexToken("X", matchTimestamp);
                addParseToken("X", function(input, array, config) {
                  config._d = new Date(parseFloat(input, 10) * 1e3);
                });
                addParseToken("x", function(input, array, config) {
                  config._d = new Date(toInt(input));
                });
                hooks.version = "2.23.0";
                setHookCallback(createLocal);
                hooks.fn = proto;
                hooks.min = min;
                hooks.max = max;
                hooks.now = now;
                hooks.utc = createUTC;
                hooks.unix = createUnix;
                hooks.months = listMonths;
                hooks.isDate = isDate;
                hooks.locale = getSetGlobalLocale;
                hooks.invalid = createInvalid;
                hooks.duration = createDuration;
                hooks.isMoment = isMoment;
                hooks.weekdays = listWeekdays;
                hooks.parseZone = createInZone;
                hooks.localeData = getLocale;
                hooks.isDuration = isDuration;
                hooks.monthsShort = listMonthsShort;
                hooks.weekdaysMin = listWeekdaysMin;
                hooks.defineLocale = defineLocale;
                hooks.updateLocale = updateLocale;
                hooks.locales = listLocales;
                hooks.weekdaysShort = listWeekdaysShort;
                hooks.normalizeUnits = normalizeUnits;
                hooks.relativeTimeRounding = getSetRelativeTimeRounding;
                hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
                hooks.calendarFormat = getCalendarFormat;
                hooks.prototype = proto;
                hooks.HTML5_FMT = {
                  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
                  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
                  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
                  DATE: "YYYY-MM-DD",
                  TIME: "HH:mm",
                  TIME_SECONDS: "HH:mm:ss",
                  TIME_MS: "HH:mm:ss.SSS",
                  WEEK: "GGGG-[W]WW",
                  MONTH: "YYYY-MM"
                };
                return hooks;
              });
            }).call(exports2, __webpack_require__(117)(module2));
          },
          function(module2, exports2) {
            module2.exports = function(module3) {
              if (!module3.webpackPolyfill) {
                module3.deprecate = function() {
                };
                module3.paths = [];
                if (!module3.children)
                  module3.children = [];
                Object.defineProperty(module3, "loaded", {
                  enumerable: true,
                  get: function() {
                    return module3.l;
                  }
                });
                Object.defineProperty(module3, "id", {
                  enumerable: true,
                  get: function() {
                    return module3.i;
                  }
                });
                module3.webpackPolyfill = 1;
              }
              return module3;
            };
          },
          function(module2, exports2) {
            function webpackEmptyContext(req) {
              throw new Error("Cannot find module '" + req + "'.");
            }
            webpackEmptyContext.keys = function() {
              return [];
            };
            webpackEmptyContext.resolve = webpackEmptyContext;
            module2.exports = webpackEmptyContext;
            webpackEmptyContext.id = 118;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(global) {
              var _rng;
              var globalVar = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : null;
              if (globalVar && globalVar.crypto && crypto.getRandomValues) {
                var _rnds8 = new Uint8Array(16);
                _rng = function whatwgRNG() {
                  crypto.getRandomValues(_rnds8);
                  return _rnds8;
                };
              }
              if (!_rng) {
                var _rnds = new Array(16);
                _rng = function _rng2() {
                  for (var i2 = 0, r; i2 < 16; i2++) {
                    if ((i2 & 3) === 0)
                      r = Math.random() * 4294967296;
                    _rnds[i2] = r >>> ((i2 & 3) << 3) & 255;
                  }
                  return _rnds;
                };
              }
              var _byteToHex = [];
              var _hexToByte = {};
              for (var i = 0; i < 256; i++) {
                _byteToHex[i] = (i + 256).toString(16).substr(1);
                _hexToByte[_byteToHex[i]] = i;
              }
              function parse(s, buf, offset) {
                var i2 = buf && offset || 0, ii = 0;
                buf = buf || [];
                s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
                  if (ii < 16) {
                    buf[i2 + ii++] = _hexToByte[oct];
                  }
                });
                while (ii < 16) {
                  buf[i2 + ii++] = 0;
                }
                return buf;
              }
              function unparse(buf, offset) {
                var i2 = offset || 0, bth = _byteToHex;
                return bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]];
              }
              var _seedBytes = _rng();
              var _nodeId = [_seedBytes[0] | 1, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];
              var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 16383;
              var _lastMSecs = 0, _lastNSecs = 0;
              function v1(options, buf, offset) {
                var i2 = buf && offset || 0;
                var b = buf || [];
                options = options || {};
                var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
                var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
                var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
                var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
                if (dt < 0 && options.clockseq === void 0) {
                  clockseq = clockseq + 1 & 16383;
                }
                if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
                  nsecs = 0;
                }
                if (nsecs >= 1e4) {
                  throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                }
                _lastMSecs = msecs;
                _lastNSecs = nsecs;
                _clockseq = clockseq;
                msecs += 122192928e5;
                var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
                b[i2++] = tl >>> 24 & 255;
                b[i2++] = tl >>> 16 & 255;
                b[i2++] = tl >>> 8 & 255;
                b[i2++] = tl & 255;
                var tmh = msecs / 4294967296 * 1e4 & 268435455;
                b[i2++] = tmh >>> 8 & 255;
                b[i2++] = tmh & 255;
                b[i2++] = tmh >>> 24 & 15 | 16;
                b[i2++] = tmh >>> 16 & 255;
                b[i2++] = clockseq >>> 8 | 128;
                b[i2++] = clockseq & 255;
                var node = options.node || _nodeId;
                for (var n = 0; n < 6; n++) {
                  b[i2 + n] = node[n];
                }
                return buf ? buf : unparse(b);
              }
              function v4(options, buf, offset) {
                var i2 = buf && offset || 0;
                if (typeof options == "string") {
                  buf = options == "binary" ? new Array(16) : null;
                  options = null;
                }
                options = options || {};
                var rnds = options.random || (options.rng || _rng)();
                rnds[6] = rnds[6] & 15 | 64;
                rnds[8] = rnds[8] & 63 | 128;
                if (buf) {
                  for (var ii = 0; ii < 16; ii++) {
                    buf[i2 + ii] = rnds[ii];
                  }
                }
                return buf || unparse(rnds);
              }
              var uuid = v4;
              uuid.v1 = v1;
              uuid.v4 = v4;
              uuid.parse = parse;
              uuid.unparse = unparse;
              module2.exports = uuid;
            }).call(exports2, __webpack_require__(120));
          },
          function(module2, exports2) {
            var g;
            g = function() {
              return this;
            }();
            try {
              g = g || Function("return this")() || (1, eval)("this");
            } catch (e) {
              if (typeof window === "object")
                g = window;
            }
            module2.exports = g;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.util = __webpack_require__(2);
            exports2.DOMutil = __webpack_require__(122);
            exports2.DataSet = __webpack_require__(33);
            exports2.DataView = __webpack_require__(51);
            exports2.Queue = __webpack_require__(72);
            exports2.Network = __webpack_require__(124);
            exports2.network = {
              Images: __webpack_require__(76),
              dotparser: __webpack_require__(74),
              gephiParser: __webpack_require__(75),
              allOptions: __webpack_require__(84)
            };
            exports2.network.convertDot = function(input) {
              return exports2.network.dotparser.DOTToGraph(input);
            };
            exports2.network.convertGephi = function(input, options) {
              return exports2.network.gephiParser.parseGephi(input, options);
            };
            exports2.moment = __webpack_require__(71);
            exports2.Hammer = __webpack_require__(24);
            exports2.keycharm = __webpack_require__(52);
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.prepareElements = function(JSONcontainer) {
              for (var elementType in JSONcontainer) {
                if (JSONcontainer.hasOwnProperty(elementType)) {
                  JSONcontainer[elementType].redundant = JSONcontainer[elementType].used;
                  JSONcontainer[elementType].used = [];
                }
              }
            };
            exports2.cleanupElements = function(JSONcontainer) {
              for (var elementType in JSONcontainer) {
                if (JSONcontainer.hasOwnProperty(elementType)) {
                  if (JSONcontainer[elementType].redundant) {
                    for (var i = 0; i < JSONcontainer[elementType].redundant.length; i++) {
                      JSONcontainer[elementType].redundant[i].parentNode.removeChild(JSONcontainer[elementType].redundant[i]);
                    }
                    JSONcontainer[elementType].redundant = [];
                  }
                }
              }
            };
            exports2.resetElements = function(JSONcontainer) {
              exports2.prepareElements(JSONcontainer);
              exports2.cleanupElements(JSONcontainer);
              exports2.prepareElements(JSONcontainer);
            };
            exports2.getSVGElement = function(elementType, JSONcontainer, svgContainer) {
              var element;
              if (JSONcontainer.hasOwnProperty(elementType)) {
                if (JSONcontainer[elementType].redundant.length > 0) {
                  element = JSONcontainer[elementType].redundant[0];
                  JSONcontainer[elementType].redundant.shift();
                } else {
                  element = document.createElementNS("http://www.w3.org/2000/svg", elementType);
                  svgContainer.appendChild(element);
                }
              } else {
                element = document.createElementNS("http://www.w3.org/2000/svg", elementType);
                JSONcontainer[elementType] = { used: [], redundant: [] };
                svgContainer.appendChild(element);
              }
              JSONcontainer[elementType].used.push(element);
              return element;
            };
            exports2.getDOMElement = function(elementType, JSONcontainer, DOMContainer, insertBefore) {
              var element;
              if (JSONcontainer.hasOwnProperty(elementType)) {
                if (JSONcontainer[elementType].redundant.length > 0) {
                  element = JSONcontainer[elementType].redundant[0];
                  JSONcontainer[elementType].redundant.shift();
                } else {
                  element = document.createElement(elementType);
                  if (insertBefore !== void 0) {
                    DOMContainer.insertBefore(element, insertBefore);
                  } else {
                    DOMContainer.appendChild(element);
                  }
                }
              } else {
                element = document.createElement(elementType);
                JSONcontainer[elementType] = { used: [], redundant: [] };
                if (insertBefore !== void 0) {
                  DOMContainer.insertBefore(element, insertBefore);
                } else {
                  DOMContainer.appendChild(element);
                }
              }
              JSONcontainer[elementType].used.push(element);
              return element;
            };
            exports2.drawPoint = function(x, y, groupTemplate, JSONcontainer, svgContainer, labelObj) {
              var point;
              if (groupTemplate.style == "circle") {
                point = exports2.getSVGElement("circle", JSONcontainer, svgContainer);
                point.setAttributeNS(null, "cx", x);
                point.setAttributeNS(null, "cy", y);
                point.setAttributeNS(null, "r", 0.5 * groupTemplate.size);
              } else {
                point = exports2.getSVGElement("rect", JSONcontainer, svgContainer);
                point.setAttributeNS(null, "x", x - 0.5 * groupTemplate.size);
                point.setAttributeNS(null, "y", y - 0.5 * groupTemplate.size);
                point.setAttributeNS(null, "width", groupTemplate.size);
                point.setAttributeNS(null, "height", groupTemplate.size);
              }
              if (groupTemplate.styles !== void 0) {
                point.setAttributeNS(null, "style", groupTemplate.styles);
              }
              point.setAttributeNS(null, "class", groupTemplate.className + " vis-point");
              if (labelObj) {
                var label = exports2.getSVGElement("text", JSONcontainer, svgContainer);
                if (labelObj.xOffset) {
                  x = x + labelObj.xOffset;
                }
                if (labelObj.yOffset) {
                  y = y + labelObj.yOffset;
                }
                if (labelObj.content) {
                  label.textContent = labelObj.content;
                }
                if (labelObj.className) {
                  label.setAttributeNS(null, "class", labelObj.className + " vis-label");
                }
                label.setAttributeNS(null, "x", x);
                label.setAttributeNS(null, "y", y);
              }
              return point;
            };
            exports2.drawBar = function(x, y, width, height, className, JSONcontainer, svgContainer, style) {
              if (height != 0) {
                if (height < 0) {
                  height *= -1;
                  y -= height;
                }
                var rect = exports2.getSVGElement("rect", JSONcontainer, svgContainer);
                rect.setAttributeNS(null, "x", x - 0.5 * width);
                rect.setAttributeNS(null, "y", y);
                rect.setAttributeNS(null, "width", width);
                rect.setAttributeNS(null, "height", height);
                rect.setAttributeNS(null, "class", className);
                if (style) {
                  rect.setAttributeNS(null, "style", style);
                }
              }
            };
          },
          function(module2, exports2, __webpack_require__) {
            var core = __webpack_require__(6);
            var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
            module2.exports = function stringify(it) {
              return $JSON.stringify.apply($JSON, arguments);
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            __webpack_require__(125);
            var Emitter = __webpack_require__(73);
            var util = __webpack_require__(2);
            var dotparser = __webpack_require__(74);
            var gephiParser = __webpack_require__(75);
            var Activator = __webpack_require__(126);
            var locales = __webpack_require__(129);
            var Images = __webpack_require__(76)["default"];
            var Groups = __webpack_require__(134)["default"];
            var NodesHandler = __webpack_require__(135)["default"];
            var EdgesHandler = __webpack_require__(165)["default"];
            var PhysicsEngine = __webpack_require__(171)["default"];
            var ClusterEngine = __webpack_require__(178)["default"];
            var CanvasRenderer = __webpack_require__(180)["default"];
            var Canvas = __webpack_require__(181)["default"];
            var View = __webpack_require__(182)["default"];
            var InteractionHandler = __webpack_require__(183)["default"];
            var SelectionHandler = __webpack_require__(186)["default"];
            var LayoutEngine = __webpack_require__(187)["default"];
            var ManipulationSystem = __webpack_require__(190)["default"];
            var Configurator = __webpack_require__(191)["default"];
            var Validator = __webpack_require__(54)["default"];
            var _require = __webpack_require__(54), printStyle = _require.printStyle;
            var _require2 = __webpack_require__(84), allOptions = _require2.allOptions, configureOptions = _require2.configureOptions;
            var KamadaKawai = __webpack_require__(193)["default"];
            function Network2(container, data, options) {
              var _this = this;
              if (!(this instanceof Network2)) {
                throw new SyntaxError("Constructor must be called with the new operator");
              }
              this.options = {};
              this.defaultOptions = {
                locale: "en",
                locales,
                clickToUse: false
              };
              util.extend(this.options, this.defaultOptions);
              this.body = {
                container,
                nodes: {},
                nodeIndices: [],
                edges: {},
                edgeIndices: [],
                emitter: {
                  on: this.on.bind(this),
                  off: this.off.bind(this),
                  emit: this.emit.bind(this),
                  once: this.once.bind(this)
                },
                eventListeners: {
                  onTap: function onTap() {
                  },
                  onTouch: function onTouch() {
                  },
                  onDoubleTap: function onDoubleTap() {
                  },
                  onHold: function onHold() {
                  },
                  onDragStart: function onDragStart() {
                  },
                  onDrag: function onDrag() {
                  },
                  onDragEnd: function onDragEnd() {
                  },
                  onMouseWheel: function onMouseWheel() {
                  },
                  onPinch: function onPinch() {
                  },
                  onMouseMove: function onMouseMove() {
                  },
                  onRelease: function onRelease() {
                  },
                  onContext: function onContext() {
                  }
                },
                data: {
                  nodes: null,
                  edges: null
                },
                functions: {
                  createNode: function createNode() {
                  },
                  createEdge: function createEdge() {
                  },
                  getPointer: function getPointer() {
                  }
                },
                modules: {},
                view: {
                  scale: 1,
                  translation: { x: 0, y: 0 }
                }
              };
              this.bindEventListeners();
              this.images = new Images(function() {
                return _this.body.emitter.emit("_requestRedraw");
              });
              this.groups = new Groups();
              this.canvas = new Canvas(this.body);
              this.selectionHandler = new SelectionHandler(this.body, this.canvas);
              this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler);
              this.view = new View(this.body, this.canvas);
              this.renderer = new CanvasRenderer(this.body, this.canvas);
              this.physics = new PhysicsEngine(this.body);
              this.layoutEngine = new LayoutEngine(this.body);
              this.clustering = new ClusterEngine(this.body);
              this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler);
              this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine);
              this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups);
              this.body.modules["kamadaKawai"] = new KamadaKawai(this.body, 150, 0.05);
              this.body.modules["clustering"] = this.clustering;
              this.canvas._create();
              this.setOptions(options);
              this.setData(data);
            }
            Emitter(Network2.prototype);
            Network2.prototype.setOptions = function(options) {
              var _this2 = this;
              if (options === null) {
                options = void 0;
              }
              if (options !== void 0) {
                var errorFound = Validator.validate(options, allOptions);
                if (errorFound === true) {
                  console.log("%cErrors have been found in the supplied options object.", printStyle);
                }
                var fields = ["locale", "locales", "clickToUse"];
                util.selectiveDeepExtend(fields, this.options, options);
                options = this.layoutEngine.setOptions(options.layout, options);
                this.canvas.setOptions(options);
                this.groups.setOptions(options.groups);
                this.nodesHandler.setOptions(options.nodes);
                this.edgesHandler.setOptions(options.edges);
                this.physics.setOptions(options.physics);
                this.manipulation.setOptions(options.manipulation, options, this.options);
                this.interactionHandler.setOptions(options.interaction);
                this.renderer.setOptions(options.interaction);
                this.selectionHandler.setOptions(options.interaction);
                if (options.groups !== void 0) {
                  this.body.emitter.emit("refreshNodes");
                }
                if ("configure" in options) {
                  if (!this.configurator) {
                    this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio);
                  }
                  this.configurator.setOptions(options.configure);
                }
                if (this.configurator && this.configurator.options.enabled === true) {
                  var networkOptions = {
                    nodes: {},
                    edges: {},
                    layout: {},
                    interaction: {},
                    manipulation: {},
                    physics: {},
                    global: {}
                  };
                  util.deepExtend(networkOptions.nodes, this.nodesHandler.options);
                  util.deepExtend(networkOptions.edges, this.edgesHandler.options);
                  util.deepExtend(networkOptions.layout, this.layoutEngine.options);
                  util.deepExtend(networkOptions.interaction, this.selectionHandler.options);
                  util.deepExtend(networkOptions.interaction, this.renderer.options);
                  util.deepExtend(networkOptions.interaction, this.interactionHandler.options);
                  util.deepExtend(networkOptions.manipulation, this.manipulation.options);
                  util.deepExtend(networkOptions.physics, this.physics.options);
                  util.deepExtend(networkOptions.global, this.canvas.options);
                  util.deepExtend(networkOptions.global, this.options);
                  this.configurator.setModuleOptions(networkOptions);
                }
                if (options.clickToUse !== void 0) {
                  if (options.clickToUse === true) {
                    if (this.activator === void 0) {
                      this.activator = new Activator(this.canvas.frame);
                      this.activator.on("change", function() {
                        _this2.body.emitter.emit("activate");
                      });
                    }
                  } else {
                    if (this.activator !== void 0) {
                      this.activator.destroy();
                      delete this.activator;
                    }
                    this.body.emitter.emit("activate");
                  }
                } else {
                  this.body.emitter.emit("activate");
                }
                this.canvas.setSize();
                this.body.emitter.emit("startSimulation");
              }
            };
            Network2.prototype._updateVisibleIndices = function() {
              var nodes2 = this.body.nodes;
              var edges2 = this.body.edges;
              this.body.nodeIndices = [];
              this.body.edgeIndices = [];
              for (var nodeId in nodes2) {
                if (nodes2.hasOwnProperty(nodeId)) {
                  if (!this.clustering._isClusteredNode(nodeId) && nodes2[nodeId].options.hidden === false) {
                    this.body.nodeIndices.push(nodes2[nodeId].id);
                  }
                }
              }
              for (var edgeId in edges2) {
                if (edges2.hasOwnProperty(edgeId)) {
                  var edge = edges2[edgeId];
                  var fromNode = nodes2[edge.fromId];
                  var toNode = nodes2[edge.toId];
                  var edgeNodesPresent = fromNode !== void 0 && toNode !== void 0;
                  var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && toNode.options.hidden === false;
                  if (isVisible) {
                    this.body.edgeIndices.push(edge.id);
                  }
                }
              }
            };
            Network2.prototype.bindEventListeners = function() {
              var _this3 = this;
              this.body.emitter.on("_dataChanged", function() {
                _this3.edgesHandler._updateState();
                _this3.body.emitter.emit("_dataUpdated");
              });
              this.body.emitter.on("_dataUpdated", function() {
                _this3.clustering._updateState();
                _this3._updateVisibleIndices();
                _this3._updateValueRange(_this3.body.nodes);
                _this3._updateValueRange(_this3.body.edges);
                _this3.body.emitter.emit("startSimulation");
                _this3.body.emitter.emit("_requestRedraw");
              });
            };
            Network2.prototype.setData = function(data) {
              this.body.emitter.emit("resetPhysics");
              this.body.emitter.emit("_resetData");
              this.selectionHandler.unselectAll();
              if (data && data.dot && (data.nodes || data.edges)) {
                throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.');
              }
              this.setOptions(data && data.options);
              if (data && data.dot) {
                console.log("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");
                var dotData = dotparser.DOTToGraph(data.dot);
                this.setData(dotData);
                return;
              } else if (data && data.gephi) {
                console.log("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");
                var gephiData = gephiParser.parseGephi(data.gephi);
                this.setData(gephiData);
                return;
              } else {
                this.nodesHandler.setData(data && data.nodes, true);
                this.edgesHandler.setData(data && data.edges, true);
              }
              this.body.emitter.emit("_dataChanged");
              this.body.emitter.emit("_dataLoaded");
              this.body.emitter.emit("initPhysics");
            };
            Network2.prototype.destroy = function() {
              this.body.emitter.emit("destroy");
              this.body.emitter.off();
              this.off();
              delete this.groups;
              delete this.canvas;
              delete this.selectionHandler;
              delete this.interactionHandler;
              delete this.view;
              delete this.renderer;
              delete this.physics;
              delete this.layoutEngine;
              delete this.clustering;
              delete this.manipulation;
              delete this.nodesHandler;
              delete this.edgesHandler;
              delete this.configurator;
              delete this.images;
              for (var nodeId in this.body.nodes) {
                if (!this.body.nodes.hasOwnProperty(nodeId))
                  continue;
                delete this.body.nodes[nodeId];
              }
              for (var edgeId in this.body.edges) {
                if (!this.body.edges.hasOwnProperty(edgeId))
                  continue;
                delete this.body.edges[edgeId];
              }
              util.recursiveDOMDelete(this.body.container);
            };
            Network2.prototype._updateValueRange = function(obj) {
              var id2;
              var valueMin = void 0;
              var valueMax = void 0;
              var valueTotal = 0;
              for (id2 in obj) {
                if (obj.hasOwnProperty(id2)) {
                  var value = obj[id2].getValue();
                  if (value !== void 0) {
                    valueMin = valueMin === void 0 ? value : Math.min(value, valueMin);
                    valueMax = valueMax === void 0 ? value : Math.max(value, valueMax);
                    valueTotal += value;
                  }
                }
              }
              if (valueMin !== void 0 && valueMax !== void 0) {
                for (id2 in obj) {
                  if (obj.hasOwnProperty(id2)) {
                    obj[id2].setValueRange(valueMin, valueMax, valueTotal);
                  }
                }
              }
            };
            Network2.prototype.isActive = function() {
              return !this.activator || this.activator.active;
            };
            Network2.prototype.setSize = function() {
              return this.canvas.setSize.apply(this.canvas, arguments);
            };
            Network2.prototype.canvasToDOM = function() {
              return this.canvas.canvasToDOM.apply(this.canvas, arguments);
            };
            Network2.prototype.DOMtoCanvas = function() {
              return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
            };
            Network2.prototype.findNode = function() {
              return this.clustering.findNode.apply(this.clustering, arguments);
            };
            Network2.prototype.isCluster = function() {
              return this.clustering.isCluster.apply(this.clustering, arguments);
            };
            Network2.prototype.openCluster = function() {
              return this.clustering.openCluster.apply(this.clustering, arguments);
            };
            Network2.prototype.cluster = function() {
              return this.clustering.cluster.apply(this.clustering, arguments);
            };
            Network2.prototype.getNodesInCluster = function() {
              return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
            };
            Network2.prototype.clusterByConnection = function() {
              return this.clustering.clusterByConnection.apply(this.clustering, arguments);
            };
            Network2.prototype.clusterByHubsize = function() {
              return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
            };
            Network2.prototype.clusterOutliers = function() {
              return this.clustering.clusterOutliers.apply(this.clustering, arguments);
            };
            Network2.prototype.getSeed = function() {
              return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
            };
            Network2.prototype.enableEditMode = function() {
              return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
            };
            Network2.prototype.disableEditMode = function() {
              return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
            };
            Network2.prototype.addNodeMode = function() {
              return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
            };
            Network2.prototype.editNode = function() {
              return this.manipulation.editNode.apply(this.manipulation, arguments);
            };
            Network2.prototype.editNodeMode = function() {
              console.log("Deprecated: Please use editNode instead of editNodeMode.");
              return this.manipulation.editNode.apply(this.manipulation, arguments);
            };
            Network2.prototype.addEdgeMode = function() {
              return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
            };
            Network2.prototype.editEdgeMode = function() {
              return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
            };
            Network2.prototype.deleteSelected = function() {
              return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
            };
            Network2.prototype.getPositions = function() {
              return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
            };
            Network2.prototype.storePositions = function() {
              return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
            };
            Network2.prototype.moveNode = function() {
              return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
            };
            Network2.prototype.getBoundingBox = function() {
              return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
            };
            Network2.prototype.getConnectedNodes = function(objectId) {
              if (this.body.nodes[objectId] !== void 0) {
                return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
              } else {
                return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
              }
            };
            Network2.prototype.getConnectedEdges = function() {
              return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
            };
            Network2.prototype.startSimulation = function() {
              return this.physics.startSimulation.apply(this.physics, arguments);
            };
            Network2.prototype.stopSimulation = function() {
              return this.physics.stopSimulation.apply(this.physics, arguments);
            };
            Network2.prototype.stabilize = function() {
              return this.physics.stabilize.apply(this.physics, arguments);
            };
            Network2.prototype.getSelection = function() {
              return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
            };
            Network2.prototype.setSelection = function() {
              return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
            };
            Network2.prototype.getSelectedNodes = function() {
              return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);
            };
            Network2.prototype.getSelectedEdges = function() {
              return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);
            };
            Network2.prototype.getNodeAt = function() {
              var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
              if (node !== void 0 && node.id !== void 0) {
                return node.id;
              }
              return node;
            };
            Network2.prototype.getEdgeAt = function() {
              var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
              if (edge !== void 0 && edge.id !== void 0) {
                return edge.id;
              }
              return edge;
            };
            Network2.prototype.selectNodes = function() {
              return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
            };
            Network2.prototype.selectEdges = function() {
              return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
            };
            Network2.prototype.unselectAll = function() {
              this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
              this.redraw();
            };
            Network2.prototype.redraw = function() {
              return this.renderer.redraw.apply(this.renderer, arguments);
            };
            Network2.prototype.getScale = function() {
              return this.view.getScale.apply(this.view, arguments);
            };
            Network2.prototype.getViewPosition = function() {
              return this.view.getViewPosition.apply(this.view, arguments);
            };
            Network2.prototype.fit = function() {
              return this.view.fit.apply(this.view, arguments);
            };
            Network2.prototype.moveTo = function() {
              return this.view.moveTo.apply(this.view, arguments);
            };
            Network2.prototype.focus = function() {
              return this.view.focus.apply(this.view, arguments);
            };
            Network2.prototype.releaseNode = function() {
              return this.view.releaseNode.apply(this.view, arguments);
            };
            Network2.prototype.getOptionsFromConfigurator = function() {
              var options = {};
              if (this.configurator) {
                options = this.configurator.getOptions.apply(this.configurator);
              }
              return options;
            };
            module2.exports = Network2;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            if (typeof CanvasRenderingContext2D !== "undefined") {
              CanvasRenderingContext2D.prototype.circle = function(x, y, r) {
                this.beginPath();
                this.arc(x, y, r, 0, 2 * Math.PI, false);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.square = function(x, y, r) {
                this.beginPath();
                this.rect(x - r, y - r, r * 2, r * 2);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.triangle = function(x, y, r) {
                this.beginPath();
                r *= 1.15;
                y += 0.275 * r;
                var s = r * 2;
                var s2 = s / 2;
                var ir = Math.sqrt(3) / 6 * s;
                var h = Math.sqrt(s * s - s2 * s2);
                this.moveTo(x, y - (h - ir));
                this.lineTo(x + s2, y + ir);
                this.lineTo(x - s2, y + ir);
                this.lineTo(x, y - (h - ir));
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.triangleDown = function(x, y, r) {
                this.beginPath();
                r *= 1.15;
                y -= 0.275 * r;
                var s = r * 2;
                var s2 = s / 2;
                var ir = Math.sqrt(3) / 6 * s;
                var h = Math.sqrt(s * s - s2 * s2);
                this.moveTo(x, y + (h - ir));
                this.lineTo(x + s2, y - ir);
                this.lineTo(x - s2, y - ir);
                this.lineTo(x, y + (h - ir));
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.star = function(x, y, r) {
                this.beginPath();
                r *= 0.82;
                y += 0.1 * r;
                for (var n = 0; n < 10; n++) {
                  var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
                  this.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
                }
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.diamond = function(x, y, r) {
                this.beginPath();
                this.lineTo(x, y + r);
                this.lineTo(x + r, y);
                this.lineTo(x, y - r);
                this.lineTo(x - r, y);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                var r2d = Math.PI / 180;
                if (w - 2 * r < 0) {
                  r = w / 2;
                }
                if (h - 2 * r < 0) {
                  r = h / 2;
                }
                this.beginPath();
                this.moveTo(x + r, y);
                this.lineTo(x + w - r, y);
                this.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
                this.lineTo(x + w, y + h - r);
                this.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
                this.lineTo(x + r, y + h);
                this.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
                this.lineTo(x, y + r);
                this.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.ellipse_vis = function(x, y, w, h) {
                var kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                this.beginPath();
                this.moveTo(x, ym);
                this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.database = function(x, y, w, h) {
                var f = 1 / 3;
                var wEllipse = w;
                var hEllipse = h * f;
                var kappa = 0.5522848, ox = wEllipse / 2 * kappa, oy = hEllipse / 2 * kappa, xe = x + wEllipse, ye = y + hEllipse, xm = x + wEllipse / 2, ym = y + hEllipse / 2, ymb = y + (h - hEllipse / 2), yeb = y + h;
                this.beginPath();
                this.moveTo(xe, ym);
                this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                this.lineTo(xe, ymb);
                this.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
                this.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);
                this.lineTo(x, ym);
              };
              CanvasRenderingContext2D.prototype.dashedLine = function(x, y, x2, y2, pattern) {
                this.beginPath();
                this.moveTo(x, y);
                var patternLength = pattern.length;
                var dx = x2 - x;
                var dy = y2 - y;
                var slope = dy / dx;
                var distRemaining = Math.sqrt(dx * dx + dy * dy);
                var patternIndex = 0;
                var draw = true;
                var xStep = 0;
                var dashLength = pattern[0];
                while (distRemaining >= 0.1) {
                  dashLength = pattern[patternIndex++ % patternLength];
                  if (dashLength > distRemaining) {
                    dashLength = distRemaining;
                  }
                  xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
                  xStep = dx < 0 ? -xStep : xStep;
                  x += xStep;
                  y += slope * xStep;
                  if (draw === true) {
                    this.lineTo(x, y);
                  } else {
                    this.moveTo(x, y);
                  }
                  distRemaining -= dashLength;
                  draw = !draw;
                }
              };
              CanvasRenderingContext2D.prototype.hexagon = function(x, y, r) {
                this.beginPath();
                var sides = 6;
                var a = Math.PI * 2 / sides;
                this.moveTo(x + r, y);
                for (var i = 1; i < sides; i++) {
                  this.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));
                }
                this.closePath();
              };
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var keycharm = __webpack_require__(52);
            var Emitter = __webpack_require__(73);
            var Hammer = __webpack_require__(24);
            var util = __webpack_require__(2);
            function Activator(container) {
              this.active = false;
              this.dom = {
                container
              };
              this.dom.overlay = document.createElement("div");
              this.dom.overlay.className = "vis-overlay";
              this.dom.container.appendChild(this.dom.overlay);
              this.hammer = Hammer(this.dom.overlay);
              this.hammer.on("tap", this._onTapOverlay.bind(this));
              var me = this;
              var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];
              events.forEach(function(event) {
                me.hammer.on(event, function(event2) {
                  event2.stopPropagation();
                });
              });
              if (document && document.body) {
                this.onClick = function(event) {
                  if (!_hasParent(event.target, container)) {
                    me.deactivate();
                  }
                };
                document.body.addEventListener("click", this.onClick);
              }
              if (this.keycharm !== void 0) {
                this.keycharm.destroy();
              }
              this.keycharm = keycharm();
              this.escListener = this.deactivate.bind(this);
            }
            Emitter(Activator.prototype);
            Activator.current = null;
            Activator.prototype.destroy = function() {
              this.deactivate();
              this.dom.overlay.parentNode.removeChild(this.dom.overlay);
              if (this.onClick) {
                document.body.removeEventListener("click", this.onClick);
              }
              if (this.keycharm !== void 0) {
                this.keycharm.destroy();
              }
              this.keycharm = null;
              this.hammer.destroy();
              this.hammer = null;
            };
            Activator.prototype.activate = function() {
              if (Activator.current) {
                Activator.current.deactivate();
              }
              Activator.current = this;
              this.active = true;
              this.dom.overlay.style.display = "none";
              util.addClassName(this.dom.container, "vis-active");
              this.emit("change");
              this.emit("activate");
              this.keycharm.bind("esc", this.escListener);
            };
            Activator.prototype.deactivate = function() {
              this.active = false;
              this.dom.overlay.style.display = "";
              util.removeClassName(this.dom.container, "vis-active");
              this.keycharm.unbind("esc", this.escListener);
              this.emit("change");
              this.emit("deactivate");
            };
            Activator.prototype._onTapOverlay = function(event) {
              this.activate();
              event.stopPropagation();
            };
            function _hasParent(element, parent) {
              while (element) {
                if (element === parent) {
                  return true;
                }
                element = element.parentNode;
              }
              return false;
            }
            module2.exports = Activator;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(factory) {
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof exports2 === "object") {
                module2.exports = factory();
              } else {
                window.propagating = factory();
              }
            })(function() {
              var _firstTarget = null;
              return function propagating(hammer, options) {
                var _options = options || {
                  preventDefault: false
                };
                if (hammer.Manager) {
                  var Hammer = hammer;
                  var PropagatingHammer = function(element2, options2) {
                    var o = Object.create(_options);
                    if (options2)
                      Hammer.assign(o, options2);
                    return propagating(new Hammer(element2, o), o);
                  };
                  Hammer.assign(PropagatingHammer, Hammer);
                  PropagatingHammer.Manager = function(element2, options2) {
                    var o = Object.create(_options);
                    if (options2)
                      Hammer.assign(o, options2);
                    return propagating(new Hammer.Manager(element2, o), o);
                  };
                  return PropagatingHammer;
                }
                var wrapper = Object.create(hammer);
                var element = hammer.element;
                if (!element.hammer)
                  element.hammer = [];
                element.hammer.push(wrapper);
                hammer.on("hammer.input", function(event) {
                  if (_options.preventDefault === true || _options.preventDefault === event.pointerType) {
                    event.preventDefault();
                  }
                  if (event.isFirst) {
                    _firstTarget = event.target;
                  }
                });
                wrapper._handlers = {};
                wrapper.on = function(events, handler) {
                  split(events).forEach(function(event) {
                    var _handlers = wrapper._handlers[event];
                    if (!_handlers) {
                      wrapper._handlers[event] = _handlers = [];
                      hammer.on(event, propagatedHandler);
                    }
                    _handlers.push(handler);
                  });
                  return wrapper;
                };
                wrapper.off = function(events, handler) {
                  split(events).forEach(function(event) {
                    var _handlers = wrapper._handlers[event];
                    if (_handlers) {
                      _handlers = handler ? _handlers.filter(function(h) {
                        return h !== handler;
                      }) : [];
                      if (_handlers.length > 0) {
                        wrapper._handlers[event] = _handlers;
                      } else {
                        hammer.off(event, propagatedHandler);
                        delete wrapper._handlers[event];
                      }
                    }
                  });
                  return wrapper;
                };
                wrapper.emit = function(eventType, event) {
                  _firstTarget = event.target;
                  hammer.emit(eventType, event);
                };
                wrapper.destroy = function() {
                  var hammers = hammer.element.hammer;
                  var idx = hammers.indexOf(wrapper);
                  if (idx !== -1)
                    hammers.splice(idx, 1);
                  if (!hammers.length)
                    delete hammer.element.hammer;
                  wrapper._handlers = {};
                  hammer.destroy();
                };
                function split(events) {
                  return events.match(/[^ ]+/g);
                }
                function propagatedHandler(event) {
                  if (event.type !== "hammer.input") {
                    if (!event.srcEvent._handled) {
                      event.srcEvent._handled = {};
                    }
                    if (event.srcEvent._handled[event.type]) {
                      return;
                    } else {
                      event.srcEvent._handled[event.type] = true;
                    }
                  }
                  var stopped = false;
                  event.stopPropagation = function() {
                    stopped = true;
                  };
                  var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
                  if (typeof srcStop == "function") {
                    event.srcEvent.stopPropagation = function() {
                      srcStop();
                      event.stopPropagation();
                    };
                  }
                  event.firstTarget = _firstTarget;
                  var elem = _firstTarget;
                  while (elem && !stopped) {
                    var elemHammer = elem.hammer;
                    if (elemHammer) {
                      var _handlers;
                      for (var k = 0; k < elemHammer.length; k++) {
                        _handlers = elemHammer[k]._handlers[event.type];
                        if (_handlers)
                          for (var i = 0; i < _handlers.length && !stopped; i++) {
                            _handlers[i](event);
                          }
                      }
                    }
                    elem = elem.parentNode;
                  }
                }
                return wrapper;
              };
            });
          },
          function(module2, exports2, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            (function(window2, document2, exportName, undefined2) {
              "use strict";
              var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
              var TEST_ELEMENT = document2.createElement("div");
              var TYPE_FUNCTION = "function";
              var round = Math.round;
              var abs = Math.abs;
              var now = Date.now;
              function setTimeoutContext(fn, timeout, context) {
                return setTimeout(bindFn(fn, context), timeout);
              }
              function invokeArrayArg(arg, fn, context) {
                if (Array.isArray(arg)) {
                  each2(arg, context[fn], context);
                  return true;
                }
                return false;
              }
              function each2(obj, iterator, context) {
                var i;
                if (!obj) {
                  return;
                }
                if (obj.forEach) {
                  obj.forEach(iterator, context);
                } else if (obj.length !== undefined2) {
                  i = 0;
                  while (i < obj.length) {
                    iterator.call(context, obj[i], i, obj);
                    i++;
                  }
                } else {
                  for (i in obj) {
                    obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
                  }
                }
              }
              function deprecate(method, name, message) {
                var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
                return function() {
                  var e = new Error("get-stack-trace");
                  var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
                  var log = window2.console && (window2.console.warn || window2.console.log);
                  if (log) {
                    log.call(window2.console, deprecationMessage, stack);
                  }
                  return method.apply(this, arguments);
                };
              }
              var assign;
              if (typeof Object.assign !== "function") {
                assign = function assign2(target) {
                  if (target === undefined2 || target === null) {
                    throw new TypeError("Cannot convert undefined or null to object");
                  }
                  var output = Object(target);
                  for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source !== undefined2 && source !== null) {
                      for (var nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                          output[nextKey] = source[nextKey];
                        }
                      }
                    }
                  }
                  return output;
                };
              } else {
                assign = Object.assign;
              }
              var extend2 = deprecate(function extend3(dest, src, merge2) {
                var keys = Object.keys(src);
                var i = 0;
                while (i < keys.length) {
                  if (!merge2 || merge2 && dest[keys[i]] === undefined2) {
                    dest[keys[i]] = src[keys[i]];
                  }
                  i++;
                }
                return dest;
              }, "extend", "Use `assign`.");
              var merge = deprecate(function merge2(dest, src) {
                return extend2(dest, src, true);
              }, "merge", "Use `assign`.");
              function inherit(child, base, properties) {
                var baseP = base.prototype, childP;
                childP = child.prototype = Object.create(baseP);
                childP.constructor = child;
                childP._super = baseP;
                if (properties) {
                  assign(childP, properties);
                }
              }
              function bindFn(fn, context) {
                return function boundFn() {
                  return fn.apply(context, arguments);
                };
              }
              function boolOrFn(val, args) {
                if (typeof val == TYPE_FUNCTION) {
                  return val.apply(args ? args[0] || undefined2 : undefined2, args);
                }
                return val;
              }
              function ifUndefined(val1, val2) {
                return val1 === undefined2 ? val2 : val1;
              }
              function addEventListeners(target, types, handler) {
                each2(splitStr(types), function(type) {
                  target.addEventListener(type, handler, false);
                });
              }
              function removeEventListeners(target, types, handler) {
                each2(splitStr(types), function(type) {
                  target.removeEventListener(type, handler, false);
                });
              }
              function hasParent(node, parent) {
                while (node) {
                  if (node == parent) {
                    return true;
                  }
                  node = node.parentNode;
                }
                return false;
              }
              function inStr(str, find) {
                return str.indexOf(find) > -1;
              }
              function splitStr(str) {
                return str.trim().split(/\s+/g);
              }
              function inArray(src, find, findByKey) {
                if (src.indexOf && !findByKey) {
                  return src.indexOf(find);
                } else {
                  var i = 0;
                  while (i < src.length) {
                    if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                      return i;
                    }
                    i++;
                  }
                  return -1;
                }
              }
              function toArray2(obj) {
                return Array.prototype.slice.call(obj, 0);
              }
              function uniqueArray(src, key, sort) {
                var results = [];
                var values = [];
                var i = 0;
                while (i < src.length) {
                  var val = key ? src[i][key] : src[i];
                  if (inArray(values, val) < 0) {
                    results.push(src[i]);
                  }
                  values[i] = val;
                  i++;
                }
                if (sort) {
                  if (!key) {
                    results = results.sort();
                  } else {
                    results = results.sort(function sortUniqueArray(a, b) {
                      return a[key] > b[key];
                    });
                  }
                }
                return results;
              }
              function prefixed(obj, property) {
                var prefix, prop;
                var camelProp = property[0].toUpperCase() + property.slice(1);
                var i = 0;
                while (i < VENDOR_PREFIXES.length) {
                  prefix = VENDOR_PREFIXES[i];
                  prop = prefix ? prefix + camelProp : property;
                  if (prop in obj) {
                    return prop;
                  }
                  i++;
                }
                return undefined2;
              }
              var _uniqueId = 1;
              function uniqueId() {
                return _uniqueId++;
              }
              function getWindowForElement(element) {
                var doc = element.ownerDocument || element;
                return doc.defaultView || doc.parentWindow || window2;
              }
              var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
              var SUPPORT_TOUCH = "ontouchstart" in window2;
              var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
              var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
              var INPUT_TYPE_TOUCH = "touch";
              var INPUT_TYPE_PEN = "pen";
              var INPUT_TYPE_MOUSE = "mouse";
              var INPUT_TYPE_KINECT = "kinect";
              var COMPUTE_INTERVAL = 25;
              var INPUT_START = 1;
              var INPUT_MOVE = 2;
              var INPUT_END = 4;
              var INPUT_CANCEL = 8;
              var DIRECTION_NONE = 1;
              var DIRECTION_LEFT = 2;
              var DIRECTION_RIGHT = 4;
              var DIRECTION_UP = 8;
              var DIRECTION_DOWN = 16;
              var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
              var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
              var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
              var PROPS_XY = ["x", "y"];
              var PROPS_CLIENT_XY = ["clientX", "clientY"];
              function Input(manager, callback) {
                var self2 = this;
                this.manager = manager;
                this.callback = callback;
                this.element = manager.element;
                this.target = manager.options.inputTarget;
                this.domHandler = function(ev) {
                  if (boolOrFn(manager.options.enable, [manager])) {
                    self2.handler(ev);
                  }
                };
                this.init();
              }
              Input.prototype = {
                handler: function() {
                },
                init: function() {
                  this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                  this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                  this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },
                destroy: function() {
                  this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                  this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                  this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
              };
              function createInputInstance(manager) {
                var Type;
                var inputClass = manager.options.inputClass;
                if (inputClass) {
                  Type = inputClass;
                } else if (SUPPORT_POINTER_EVENTS) {
                  Type = PointerEventInput;
                } else if (SUPPORT_ONLY_TOUCH) {
                  Type = TouchInput;
                } else if (!SUPPORT_TOUCH) {
                  Type = MouseInput;
                } else {
                  Type = TouchMouseInput;
                }
                return new Type(manager, inputHandler);
              }
              function inputHandler(manager, eventType, input) {
                var pointersLen = input.pointers.length;
                var changedPointersLen = input.changedPointers.length;
                var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
                var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
                input.isFirst = !!isFirst;
                input.isFinal = !!isFinal;
                if (isFirst) {
                  manager.session = {};
                }
                input.eventType = eventType;
                computeInputData(manager, input);
                manager.emit("hammer.input", input);
                manager.recognize(input);
                manager.session.prevInput = input;
              }
              function computeInputData(manager, input) {
                var session = manager.session;
                var pointers = input.pointers;
                var pointersLength = pointers.length;
                if (!session.firstInput) {
                  session.firstInput = simpleCloneInputData(input);
                }
                if (pointersLength > 1 && !session.firstMultiple) {
                  session.firstMultiple = simpleCloneInputData(input);
                } else if (pointersLength === 1) {
                  session.firstMultiple = false;
                }
                var firstInput = session.firstInput;
                var firstMultiple = session.firstMultiple;
                var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
                var center = input.center = getCenter(pointers);
                input.timeStamp = now();
                input.deltaTime = input.timeStamp - firstInput.timeStamp;
                input.angle = getAngle(offsetCenter, center);
                input.distance = getDistance(offsetCenter, center);
                computeDeltaXY(session, input);
                input.offsetDirection = getDirection(input.deltaX, input.deltaY);
                var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
                input.overallVelocityX = overallVelocity.x;
                input.overallVelocityY = overallVelocity.y;
                input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
                input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
                input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
                input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
                computeIntervalInputData(session, input);
                var target = manager.element;
                if (hasParent(input.srcEvent.target, target)) {
                  target = input.srcEvent.target;
                }
                input.target = target;
              }
              function computeDeltaXY(session, input) {
                var center = input.center;
                var offset = session.offsetDelta || {};
                var prevDelta = session.prevDelta || {};
                var prevInput = session.prevInput || {};
                if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
                  prevDelta = session.prevDelta = {
                    x: prevInput.deltaX || 0,
                    y: prevInput.deltaY || 0
                  };
                  offset = session.offsetDelta = {
                    x: center.x,
                    y: center.y
                  };
                }
                input.deltaX = prevDelta.x + (center.x - offset.x);
                input.deltaY = prevDelta.y + (center.y - offset.y);
              }
              function computeIntervalInputData(session, input) {
                var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
                if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
                  var deltaX = input.deltaX - last.deltaX;
                  var deltaY = input.deltaY - last.deltaY;
                  var v = getVelocity(deltaTime, deltaX, deltaY);
                  velocityX = v.x;
                  velocityY = v.y;
                  velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
                  direction = getDirection(deltaX, deltaY);
                  session.lastInterval = input;
                } else {
                  velocity = last.velocity;
                  velocityX = last.velocityX;
                  velocityY = last.velocityY;
                  direction = last.direction;
                }
                input.velocity = velocity;
                input.velocityX = velocityX;
                input.velocityY = velocityY;
                input.direction = direction;
              }
              function simpleCloneInputData(input) {
                var pointers = [];
                var i = 0;
                while (i < input.pointers.length) {
                  pointers[i] = {
                    clientX: round(input.pointers[i].clientX),
                    clientY: round(input.pointers[i].clientY)
                  };
                  i++;
                }
                return {
                  timeStamp: now(),
                  pointers,
                  center: getCenter(pointers),
                  deltaX: input.deltaX,
                  deltaY: input.deltaY
                };
              }
              function getCenter(pointers) {
                var pointersLength = pointers.length;
                if (pointersLength === 1) {
                  return {
                    x: round(pointers[0].clientX),
                    y: round(pointers[0].clientY)
                  };
                }
                var x = 0, y = 0, i = 0;
                while (i < pointersLength) {
                  x += pointers[i].clientX;
                  y += pointers[i].clientY;
                  i++;
                }
                return {
                  x: round(x / pointersLength),
                  y: round(y / pointersLength)
                };
              }
              function getVelocity(deltaTime, x, y) {
                return {
                  x: x / deltaTime || 0,
                  y: y / deltaTime || 0
                };
              }
              function getDirection(x, y) {
                if (x === y) {
                  return DIRECTION_NONE;
                }
                if (abs(x) >= abs(y)) {
                  return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                }
                return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              }
              function getDistance(p1, p2, props) {
                if (!props) {
                  props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
                return Math.sqrt(x * x + y * y);
              }
              function getAngle(p1, p2, props) {
                if (!props) {
                  props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
                return Math.atan2(y, x) * 180 / Math.PI;
              }
              function getRotation(start, end) {
                return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
              }
              function getScale(start, end) {
                return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
              }
              var MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
              };
              var MOUSE_ELEMENT_EVENTS = "mousedown";
              var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
              function MouseInput() {
                this.evEl = MOUSE_ELEMENT_EVENTS;
                this.evWin = MOUSE_WINDOW_EVENTS;
                this.pressed = false;
                Input.apply(this, arguments);
              }
              inherit(MouseInput, Input, {
                handler: function MEhandler(ev) {
                  var eventType = MOUSE_INPUT_MAP[ev.type];
                  if (eventType & INPUT_START && ev.button === 0) {
                    this.pressed = true;
                  }
                  if (eventType & INPUT_MOVE && ev.which !== 1) {
                    eventType = INPUT_END;
                  }
                  if (!this.pressed) {
                    return;
                  }
                  if (eventType & INPUT_END) {
                    this.pressed = false;
                  }
                  this.callback(this.manager, eventType, {
                    pointers: [ev],
                    changedPointers: [ev],
                    pointerType: INPUT_TYPE_MOUSE,
                    srcEvent: ev
                  });
                }
              });
              var POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
              };
              var IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT
              };
              var POINTER_ELEMENT_EVENTS = "pointerdown";
              var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
              if (window2.MSPointerEvent && !window2.PointerEvent) {
                POINTER_ELEMENT_EVENTS = "MSPointerDown";
                POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
              }
              function PointerEventInput() {
                this.evEl = POINTER_ELEMENT_EVENTS;
                this.evWin = POINTER_WINDOW_EVENTS;
                Input.apply(this, arguments);
                this.store = this.manager.session.pointerEvents = [];
              }
              inherit(PointerEventInput, Input, {
                handler: function PEhandler(ev) {
                  var store = this.store;
                  var removePointer = false;
                  var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
                  var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                  var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
                  var isTouch = pointerType == INPUT_TYPE_TOUCH;
                  var storeIndex = inArray(store, ev.pointerId, "pointerId");
                  if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                    if (storeIndex < 0) {
                      store.push(ev);
                      storeIndex = store.length - 1;
                    }
                  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                    removePointer = true;
                  }
                  if (storeIndex < 0) {
                    return;
                  }
                  store[storeIndex] = ev;
                  this.callback(this.manager, eventType, {
                    pointers: store,
                    changedPointers: [ev],
                    pointerType,
                    srcEvent: ev
                  });
                  if (removePointer) {
                    store.splice(storeIndex, 1);
                  }
                }
              });
              var SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
              };
              var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
              var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
              function SingleTouchInput() {
                this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
                this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
                this.started = false;
                Input.apply(this, arguments);
              }
              inherit(SingleTouchInput, Input, {
                handler: function TEhandler(ev) {
                  var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                  if (type === INPUT_START) {
                    this.started = true;
                  }
                  if (!this.started) {
                    return;
                  }
                  var touches = normalizeSingleTouches.call(this, ev, type);
                  if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                    this.started = false;
                  }
                  this.callback(this.manager, type, {
                    pointers: touches[0],
                    changedPointers: touches[1],
                    pointerType: INPUT_TYPE_TOUCH,
                    srcEvent: ev
                  });
                }
              });
              function normalizeSingleTouches(ev, type) {
                var all = toArray2(ev.touches);
                var changed = toArray2(ev.changedTouches);
                if (type & (INPUT_END | INPUT_CANCEL)) {
                  all = uniqueArray(all.concat(changed), "identifier", true);
                }
                return [all, changed];
              }
              var TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
              };
              var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
              function TouchInput() {
                this.evTarget = TOUCH_TARGET_EVENTS;
                this.targetIds = {};
                Input.apply(this, arguments);
              }
              inherit(TouchInput, Input, {
                handler: function MTEhandler(ev) {
                  var type = TOUCH_INPUT_MAP[ev.type];
                  var touches = getTouches.call(this, ev, type);
                  if (!touches) {
                    return;
                  }
                  this.callback(this.manager, type, {
                    pointers: touches[0],
                    changedPointers: touches[1],
                    pointerType: INPUT_TYPE_TOUCH,
                    srcEvent: ev
                  });
                }
              });
              function getTouches(ev, type) {
                var allTouches = toArray2(ev.touches);
                var targetIds = this.targetIds;
                if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
                  targetIds[allTouches[0].identifier] = true;
                  return [allTouches, allTouches];
                }
                var i, targetTouches, changedTouches = toArray2(ev.changedTouches), changedTargetTouches = [], target = this.target;
                targetTouches = allTouches.filter(function(touch) {
                  return hasParent(touch.target, target);
                });
                if (type === INPUT_START) {
                  i = 0;
                  while (i < targetTouches.length) {
                    targetIds[targetTouches[i].identifier] = true;
                    i++;
                  }
                }
                i = 0;
                while (i < changedTouches.length) {
                  if (targetIds[changedTouches[i].identifier]) {
                    changedTargetTouches.push(changedTouches[i]);
                  }
                  if (type & (INPUT_END | INPUT_CANCEL)) {
                    delete targetIds[changedTouches[i].identifier];
                  }
                  i++;
                }
                if (!changedTargetTouches.length) {
                  return;
                }
                return [
                  uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
                  changedTargetTouches
                ];
              }
              var DEDUP_TIMEOUT = 2500;
              var DEDUP_DISTANCE = 25;
              function TouchMouseInput() {
                Input.apply(this, arguments);
                var handler = bindFn(this.handler, this);
                this.touch = new TouchInput(this.manager, handler);
                this.mouse = new MouseInput(this.manager, handler);
                this.primaryTouch = null;
                this.lastTouches = [];
              }
              inherit(TouchMouseInput, Input, {
                handler: function TMEhandler(manager, inputEvent, inputData) {
                  var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                  if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                    return;
                  }
                  if (isTouch) {
                    recordTouches.call(this, inputEvent, inputData);
                  } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                    return;
                  }
                  this.callback(manager, inputEvent, inputData);
                },
                destroy: function destroy2() {
                  this.touch.destroy();
                  this.mouse.destroy();
                }
              });
              function recordTouches(eventType, eventData) {
                if (eventType & INPUT_START) {
                  this.primaryTouch = eventData.changedPointers[0].identifier;
                  setLastTouch.call(this, eventData);
                } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                  setLastTouch.call(this, eventData);
                }
              }
              function setLastTouch(eventData) {
                var touch = eventData.changedPointers[0];
                if (touch.identifier === this.primaryTouch) {
                  var lastTouch = { x: touch.clientX, y: touch.clientY };
                  this.lastTouches.push(lastTouch);
                  var lts = this.lastTouches;
                  var removeLastTouch = function() {
                    var i = lts.indexOf(lastTouch);
                    if (i > -1) {
                      lts.splice(i, 1);
                    }
                  };
                  setTimeout(removeLastTouch, DEDUP_TIMEOUT);
                }
              }
              function isSyntheticEvent(eventData) {
                var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
                for (var i = 0; i < this.lastTouches.length; i++) {
                  var t = this.lastTouches[i];
                  var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
                  if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                    return true;
                  }
                }
                return false;
              }
              var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
              var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
              var TOUCH_ACTION_COMPUTE = "compute";
              var TOUCH_ACTION_AUTO = "auto";
              var TOUCH_ACTION_MANIPULATION = "manipulation";
              var TOUCH_ACTION_NONE = "none";
              var TOUCH_ACTION_PAN_X = "pan-x";
              var TOUCH_ACTION_PAN_Y = "pan-y";
              var TOUCH_ACTION_MAP = getTouchActionProps();
              function TouchAction(manager, value) {
                this.manager = manager;
                this.set(value);
              }
              TouchAction.prototype = {
                set: function(value) {
                  if (value == TOUCH_ACTION_COMPUTE) {
                    value = this.compute();
                  }
                  if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                    this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                  }
                  this.actions = value.toLowerCase().trim();
                },
                update: function() {
                  this.set(this.manager.options.touchAction);
                },
                compute: function() {
                  var actions = [];
                  each2(this.manager.recognizers, function(recognizer) {
                    if (boolOrFn(recognizer.options.enable, [recognizer])) {
                      actions = actions.concat(recognizer.getTouchAction());
                    }
                  });
                  return cleanTouchActions(actions.join(" "));
                },
                preventDefaults: function(input) {
                  var srcEvent = input.srcEvent;
                  var direction = input.offsetDirection;
                  if (this.manager.session.prevented) {
                    srcEvent.preventDefault();
                    return;
                  }
                  var actions = this.actions;
                  var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
                  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
                  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
                  if (hasNone) {
                    var isTapPointer = input.pointers.length === 1;
                    var isTapMovement = input.distance < 2;
                    var isTapTouchTime = input.deltaTime < 250;
                    if (isTapPointer && isTapMovement && isTapTouchTime) {
                      return;
                    }
                  }
                  if (hasPanX && hasPanY) {
                    return;
                  }
                  if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                    return this.preventSrc(srcEvent);
                  }
                },
                preventSrc: function(srcEvent) {
                  this.manager.session.prevented = true;
                  srcEvent.preventDefault();
                }
              };
              function cleanTouchActions(actions) {
                if (inStr(actions, TOUCH_ACTION_NONE)) {
                  return TOUCH_ACTION_NONE;
                }
                var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
                if (hasPanX && hasPanY) {
                  return TOUCH_ACTION_NONE;
                }
                if (hasPanX || hasPanY) {
                  return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
                }
                if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
                  return TOUCH_ACTION_MANIPULATION;
                }
                return TOUCH_ACTION_AUTO;
              }
              function getTouchActionProps() {
                if (!NATIVE_TOUCH_ACTION) {
                  return false;
                }
                var touchMap = {};
                var cssSupports = window2.CSS && window2.CSS.supports;
                ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
                  touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
                });
                return touchMap;
              }
              var STATE_POSSIBLE = 1;
              var STATE_BEGAN = 2;
              var STATE_CHANGED = 4;
              var STATE_ENDED = 8;
              var STATE_RECOGNIZED = STATE_ENDED;
              var STATE_CANCELLED = 16;
              var STATE_FAILED = 32;
              function Recognizer(options) {
                this.options = assign({}, this.defaults, options || {});
                this.id = uniqueId();
                this.manager = null;
                this.options.enable = ifUndefined(this.options.enable, true);
                this.state = STATE_POSSIBLE;
                this.simultaneous = {};
                this.requireFail = [];
              }
              Recognizer.prototype = {
                defaults: {},
                set: function(options) {
                  assign(this.options, options);
                  this.manager && this.manager.touchAction.update();
                  return this;
                },
                recognizeWith: function(otherRecognizer) {
                  if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
                    return this;
                  }
                  var simultaneous = this.simultaneous;
                  otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                  if (!simultaneous[otherRecognizer.id]) {
                    simultaneous[otherRecognizer.id] = otherRecognizer;
                    otherRecognizer.recognizeWith(this);
                  }
                  return this;
                },
                dropRecognizeWith: function(otherRecognizer) {
                  if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
                    return this;
                  }
                  otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                  delete this.simultaneous[otherRecognizer.id];
                  return this;
                },
                requireFailure: function(otherRecognizer) {
                  if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
                    return this;
                  }
                  var requireFail = this.requireFail;
                  otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                  if (inArray(requireFail, otherRecognizer) === -1) {
                    requireFail.push(otherRecognizer);
                    otherRecognizer.requireFailure(this);
                  }
                  return this;
                },
                dropRequireFailure: function(otherRecognizer) {
                  if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
                    return this;
                  }
                  otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                  var index = inArray(this.requireFail, otherRecognizer);
                  if (index > -1) {
                    this.requireFail.splice(index, 1);
                  }
                  return this;
                },
                hasRequireFailures: function() {
                  return this.requireFail.length > 0;
                },
                canRecognizeWith: function(otherRecognizer) {
                  return !!this.simultaneous[otherRecognizer.id];
                },
                emit: function(input) {
                  var self2 = this;
                  var state = this.state;
                  function emit(event) {
                    self2.manager.emit(event, input);
                  }
                  if (state < STATE_ENDED) {
                    emit(self2.options.event + stateStr(state));
                  }
                  emit(self2.options.event);
                  if (input.additionalEvent) {
                    emit(input.additionalEvent);
                  }
                  if (state >= STATE_ENDED) {
                    emit(self2.options.event + stateStr(state));
                  }
                },
                tryEmit: function(input) {
                  if (this.canEmit()) {
                    return this.emit(input);
                  }
                  this.state = STATE_FAILED;
                },
                canEmit: function() {
                  var i = 0;
                  while (i < this.requireFail.length) {
                    if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                      return false;
                    }
                    i++;
                  }
                  return true;
                },
                recognize: function(inputData) {
                  var inputDataClone = assign({}, inputData);
                  if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                    this.reset();
                    this.state = STATE_FAILED;
                    return;
                  }
                  if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                    this.state = STATE_POSSIBLE;
                  }
                  this.state = this.process(inputDataClone);
                  if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                    this.tryEmit(inputDataClone);
                  }
                },
                process: function(inputData) {
                },
                getTouchAction: function() {
                },
                reset: function() {
                }
              };
              function stateStr(state) {
                if (state & STATE_CANCELLED) {
                  return "cancel";
                } else if (state & STATE_ENDED) {
                  return "end";
                } else if (state & STATE_CHANGED) {
                  return "move";
                } else if (state & STATE_BEGAN) {
                  return "start";
                }
                return "";
              }
              function directionStr(direction) {
                if (direction == DIRECTION_DOWN) {
                  return "down";
                } else if (direction == DIRECTION_UP) {
                  return "up";
                } else if (direction == DIRECTION_LEFT) {
                  return "left";
                } else if (direction == DIRECTION_RIGHT) {
                  return "right";
                }
                return "";
              }
              function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
                var manager = recognizer.manager;
                if (manager) {
                  return manager.get(otherRecognizer);
                }
                return otherRecognizer;
              }
              function AttrRecognizer() {
                Recognizer.apply(this, arguments);
              }
              inherit(AttrRecognizer, Recognizer, {
                defaults: {
                  pointers: 1
                },
                attrTest: function(input) {
                  var optionPointers = this.options.pointers;
                  return optionPointers === 0 || input.pointers.length === optionPointers;
                },
                process: function(input) {
                  var state = this.state;
                  var eventType = input.eventType;
                  var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                  var isValid = this.attrTest(input);
                  if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                    return state | STATE_CANCELLED;
                  } else if (isRecognized || isValid) {
                    if (eventType & INPUT_END) {
                      return state | STATE_ENDED;
                    } else if (!(state & STATE_BEGAN)) {
                      return STATE_BEGAN;
                    }
                    return state | STATE_CHANGED;
                  }
                  return STATE_FAILED;
                }
              });
              function PanRecognizer() {
                AttrRecognizer.apply(this, arguments);
                this.pX = null;
                this.pY = null;
              }
              inherit(PanRecognizer, AttrRecognizer, {
                defaults: {
                  event: "pan",
                  threshold: 10,
                  pointers: 1,
                  direction: DIRECTION_ALL
                },
                getTouchAction: function() {
                  var direction = this.options.direction;
                  var actions = [];
                  if (direction & DIRECTION_HORIZONTAL) {
                    actions.push(TOUCH_ACTION_PAN_Y);
                  }
                  if (direction & DIRECTION_VERTICAL) {
                    actions.push(TOUCH_ACTION_PAN_X);
                  }
                  return actions;
                },
                directionTest: function(input) {
                  var options = this.options;
                  var hasMoved = true;
                  var distance = input.distance;
                  var direction = input.direction;
                  var x = input.deltaX;
                  var y = input.deltaY;
                  if (!(direction & options.direction)) {
                    if (options.direction & DIRECTION_HORIZONTAL) {
                      direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                      hasMoved = x != this.pX;
                      distance = Math.abs(input.deltaX);
                    } else {
                      direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                      hasMoved = y != this.pY;
                      distance = Math.abs(input.deltaY);
                    }
                  }
                  input.direction = direction;
                  return hasMoved && distance > options.threshold && direction & options.direction;
                },
                attrTest: function(input) {
                  return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
                },
                emit: function(input) {
                  this.pX = input.deltaX;
                  this.pY = input.deltaY;
                  var direction = directionStr(input.direction);
                  if (direction) {
                    input.additionalEvent = this.options.event + direction;
                  }
                  this._super.emit.call(this, input);
                }
              });
              function PinchRecognizer() {
                AttrRecognizer.apply(this, arguments);
              }
              inherit(PinchRecognizer, AttrRecognizer, {
                defaults: {
                  event: "pinch",
                  threshold: 0,
                  pointers: 2
                },
                getTouchAction: function() {
                  return [TOUCH_ACTION_NONE];
                },
                attrTest: function(input) {
                  return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },
                emit: function(input) {
                  if (input.scale !== 1) {
                    var inOut = input.scale < 1 ? "in" : "out";
                    input.additionalEvent = this.options.event + inOut;
                  }
                  this._super.emit.call(this, input);
                }
              });
              function PressRecognizer() {
                Recognizer.apply(this, arguments);
                this._timer = null;
                this._input = null;
              }
              inherit(PressRecognizer, Recognizer, {
                defaults: {
                  event: "press",
                  pointers: 1,
                  time: 251,
                  threshold: 9
                },
                getTouchAction: function() {
                  return [TOUCH_ACTION_AUTO];
                },
                process: function(input) {
                  var options = this.options;
                  var validPointers = input.pointers.length === options.pointers;
                  var validMovement = input.distance < options.threshold;
                  var validTime = input.deltaTime > options.time;
                  this._input = input;
                  if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                    this.reset();
                  } else if (input.eventType & INPUT_START) {
                    this.reset();
                    this._timer = setTimeoutContext(function() {
                      this.state = STATE_RECOGNIZED;
                      this.tryEmit();
                    }, options.time, this);
                  } else if (input.eventType & INPUT_END) {
                    return STATE_RECOGNIZED;
                  }
                  return STATE_FAILED;
                },
                reset: function() {
                  clearTimeout(this._timer);
                },
                emit: function(input) {
                  if (this.state !== STATE_RECOGNIZED) {
                    return;
                  }
                  if (input && input.eventType & INPUT_END) {
                    this.manager.emit(this.options.event + "up", input);
                  } else {
                    this._input.timeStamp = now();
                    this.manager.emit(this.options.event, this._input);
                  }
                }
              });
              function RotateRecognizer() {
                AttrRecognizer.apply(this, arguments);
              }
              inherit(RotateRecognizer, AttrRecognizer, {
                defaults: {
                  event: "rotate",
                  threshold: 0,
                  pointers: 2
                },
                getTouchAction: function() {
                  return [TOUCH_ACTION_NONE];
                },
                attrTest: function(input) {
                  return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
              });
              function SwipeRecognizer() {
                AttrRecognizer.apply(this, arguments);
              }
              inherit(SwipeRecognizer, AttrRecognizer, {
                defaults: {
                  event: "swipe",
                  threshold: 10,
                  velocity: 0.3,
                  direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                  pointers: 1
                },
                getTouchAction: function() {
                  return PanRecognizer.prototype.getTouchAction.call(this);
                },
                attrTest: function(input) {
                  var direction = this.options.direction;
                  var velocity;
                  if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                    velocity = input.overallVelocity;
                  } else if (direction & DIRECTION_HORIZONTAL) {
                    velocity = input.overallVelocityX;
                  } else if (direction & DIRECTION_VERTICAL) {
                    velocity = input.overallVelocityY;
                  }
                  return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },
                emit: function(input) {
                  var direction = directionStr(input.offsetDirection);
                  if (direction) {
                    this.manager.emit(this.options.event + direction, input);
                  }
                  this.manager.emit(this.options.event, input);
                }
              });
              function TapRecognizer() {
                Recognizer.apply(this, arguments);
                this.pTime = false;
                this.pCenter = false;
                this._timer = null;
                this._input = null;
                this.count = 0;
              }
              inherit(TapRecognizer, Recognizer, {
                defaults: {
                  event: "tap",
                  pointers: 1,
                  taps: 1,
                  interval: 300,
                  time: 250,
                  threshold: 9,
                  posThreshold: 10
                },
                getTouchAction: function() {
                  return [TOUCH_ACTION_MANIPULATION];
                },
                process: function(input) {
                  var options = this.options;
                  var validPointers = input.pointers.length === options.pointers;
                  var validMovement = input.distance < options.threshold;
                  var validTouchTime = input.deltaTime < options.time;
                  this.reset();
                  if (input.eventType & INPUT_START && this.count === 0) {
                    return this.failTimeout();
                  }
                  if (validMovement && validTouchTime && validPointers) {
                    if (input.eventType != INPUT_END) {
                      return this.failTimeout();
                    }
                    var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                    var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                    this.pTime = input.timeStamp;
                    this.pCenter = input.center;
                    if (!validMultiTap || !validInterval) {
                      this.count = 1;
                    } else {
                      this.count += 1;
                    }
                    this._input = input;
                    var tapCount = this.count % options.taps;
                    if (tapCount === 0) {
                      if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                      } else {
                        this._timer = setTimeoutContext(function() {
                          this.state = STATE_RECOGNIZED;
                          this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                      }
                    }
                  }
                  return STATE_FAILED;
                },
                failTimeout: function() {
                  this._timer = setTimeoutContext(function() {
                    this.state = STATE_FAILED;
                  }, this.options.interval, this);
                  return STATE_FAILED;
                },
                reset: function() {
                  clearTimeout(this._timer);
                },
                emit: function() {
                  if (this.state == STATE_RECOGNIZED) {
                    this._input.tapCount = this.count;
                    this.manager.emit(this.options.event, this._input);
                  }
                }
              });
              function Hammer(element, options) {
                options = options || {};
                options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
                return new Manager(element, options);
              }
              Hammer.VERSION = "2.0.7";
              Hammer.defaults = {
                domEvents: false,
                touchAction: TOUCH_ACTION_COMPUTE,
                enable: true,
                inputTarget: null,
                inputClass: null,
                preset: [
                  [RotateRecognizer, { enable: false }],
                  [PinchRecognizer, { enable: false }, ["rotate"]],
                  [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
                  [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
                  [TapRecognizer],
                  [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
                  [PressRecognizer]
                ],
                cssProps: {
                  userSelect: "none",
                  touchSelect: "none",
                  touchCallout: "none",
                  contentZooming: "none",
                  userDrag: "none",
                  tapHighlightColor: "rgba(0,0,0,0)"
                }
              };
              var STOP = 1;
              var FORCED_STOP = 2;
              function Manager(element, options) {
                this.options = assign({}, Hammer.defaults, options || {});
                this.options.inputTarget = this.options.inputTarget || element;
                this.handlers = {};
                this.session = {};
                this.recognizers = [];
                this.oldCssProps = {};
                this.element = element;
                this.input = createInputInstance(this);
                this.touchAction = new TouchAction(this, this.options.touchAction);
                toggleCssProps(this, true);
                each2(this.options.recognizers, function(item) {
                  var recognizer = this.add(new item[0](item[1]));
                  item[2] && recognizer.recognizeWith(item[2]);
                  item[3] && recognizer.requireFailure(item[3]);
                }, this);
              }
              Manager.prototype = {
                set: function(options) {
                  assign(this.options, options);
                  if (options.touchAction) {
                    this.touchAction.update();
                  }
                  if (options.inputTarget) {
                    this.input.destroy();
                    this.input.target = options.inputTarget;
                    this.input.init();
                  }
                  return this;
                },
                stop: function(force) {
                  this.session.stopped = force ? FORCED_STOP : STOP;
                },
                recognize: function(inputData) {
                  var session = this.session;
                  if (session.stopped) {
                    return;
                  }
                  this.touchAction.preventDefaults(inputData);
                  var recognizer;
                  var recognizers = this.recognizers;
                  var curRecognizer = session.curRecognizer;
                  if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                    curRecognizer = session.curRecognizer = null;
                  }
                  var i = 0;
                  while (i < recognizers.length) {
                    recognizer = recognizers[i];
                    if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                      recognizer.recognize(inputData);
                    } else {
                      recognizer.reset();
                    }
                    if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                      curRecognizer = session.curRecognizer = recognizer;
                    }
                    i++;
                  }
                },
                get: function(recognizer) {
                  if (recognizer instanceof Recognizer) {
                    return recognizer;
                  }
                  var recognizers = this.recognizers;
                  for (var i = 0; i < recognizers.length; i++) {
                    if (recognizers[i].options.event == recognizer) {
                      return recognizers[i];
                    }
                  }
                  return null;
                },
                add: function(recognizer) {
                  if (invokeArrayArg(recognizer, "add", this)) {
                    return this;
                  }
                  var existing = this.get(recognizer.options.event);
                  if (existing) {
                    this.remove(existing);
                  }
                  this.recognizers.push(recognizer);
                  recognizer.manager = this;
                  this.touchAction.update();
                  return recognizer;
                },
                remove: function(recognizer) {
                  if (invokeArrayArg(recognizer, "remove", this)) {
                    return this;
                  }
                  recognizer = this.get(recognizer);
                  if (recognizer) {
                    var recognizers = this.recognizers;
                    var index = inArray(recognizers, recognizer);
                    if (index !== -1) {
                      recognizers.splice(index, 1);
                      this.touchAction.update();
                    }
                  }
                  return this;
                },
                on: function(events, handler) {
                  if (events === undefined2) {
                    return;
                  }
                  if (handler === undefined2) {
                    return;
                  }
                  var handlers = this.handlers;
                  each2(splitStr(events), function(event) {
                    handlers[event] = handlers[event] || [];
                    handlers[event].push(handler);
                  });
                  return this;
                },
                off: function(events, handler) {
                  if (events === undefined2) {
                    return;
                  }
                  var handlers = this.handlers;
                  each2(splitStr(events), function(event) {
                    if (!handler) {
                      delete handlers[event];
                    } else {
                      handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                    }
                  });
                  return this;
                },
                emit: function(event, data) {
                  if (this.options.domEvents) {
                    triggerDomEvent(event, data);
                  }
                  var handlers = this.handlers[event] && this.handlers[event].slice();
                  if (!handlers || !handlers.length) {
                    return;
                  }
                  data.type = event;
                  data.preventDefault = function() {
                    data.srcEvent.preventDefault();
                  };
                  var i = 0;
                  while (i < handlers.length) {
                    handlers[i](data);
                    i++;
                  }
                },
                destroy: function() {
                  this.element && toggleCssProps(this, false);
                  this.handlers = {};
                  this.session = {};
                  this.input.destroy();
                  this.element = null;
                }
              };
              function toggleCssProps(manager, add2) {
                var element = manager.element;
                if (!element.style) {
                  return;
                }
                var prop;
                each2(manager.options.cssProps, function(value, name) {
                  prop = prefixed(element.style, name);
                  if (add2) {
                    manager.oldCssProps[prop] = element.style[prop];
                    element.style[prop] = value;
                  } else {
                    element.style[prop] = manager.oldCssProps[prop] || "";
                  }
                });
                if (!add2) {
                  manager.oldCssProps = {};
                }
              }
              function triggerDomEvent(event, data) {
                var gestureEvent = document2.createEvent("Event");
                gestureEvent.initEvent(event, true, true);
                gestureEvent.gesture = data;
                data.target.dispatchEvent(gestureEvent);
              }
              assign(Hammer, {
                INPUT_START,
                INPUT_MOVE,
                INPUT_END,
                INPUT_CANCEL,
                STATE_POSSIBLE,
                STATE_BEGAN,
                STATE_CHANGED,
                STATE_ENDED,
                STATE_RECOGNIZED,
                STATE_CANCELLED,
                STATE_FAILED,
                DIRECTION_NONE,
                DIRECTION_LEFT,
                DIRECTION_RIGHT,
                DIRECTION_UP,
                DIRECTION_DOWN,
                DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL,
                DIRECTION_ALL,
                Manager,
                Input,
                TouchAction,
                TouchInput,
                MouseInput,
                PointerEventInput,
                TouchMouseInput,
                SingleTouchInput,
                Recognizer,
                AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,
                on: addEventListeners,
                off: removeEventListeners,
                each: each2,
                merge,
                extend: extend2,
                assign,
                inherit,
                bindFn,
                prefixed
              });
              var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
              freeGlobal.Hammer = Hammer;
              if (true) {
                !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                  return Hammer;
                }.call(exports2, __webpack_require__, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined2 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof module2 != "undefined" && module2.exports) {
                module2.exports = Hammer;
              } else {
                window2[exportName] = Hammer;
              }
            })(window, document, "Hammer");
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2["en"] = {
              edit: "Edit",
              del: "Delete selected",
              back: "Back",
              addNode: "Add Node",
              addEdge: "Add Edge",
              editNode: "Edit Node",
              editEdge: "Edit Edge",
              addDescription: "Click in an empty space to place a new node.",
              edgeDescription: "Click on a node and drag the edge to another node to connect them.",
              editEdgeDescription: "Click on the control points and drag them to a node to connect to it.",
              createEdgeError: "Cannot link edges to a cluster.",
              deleteClusterError: "Clusters cannot be deleted.",
              editClusterError: "Clusters cannot be edited."
            };
            exports2["en_EN"] = exports2["en"];
            exports2["en_US"] = exports2["en"];
            exports2["de"] = {
              edit: "Editieren",
              del: "L\xF6sche Auswahl",
              back: "Zur\xFCck",
              addNode: "Knoten hinzuf\xFCgen",
              addEdge: "Kante hinzuf\xFCgen",
              editNode: "Knoten editieren",
              editEdge: "Kante editieren",
              addDescription: "Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",
              edgeDescription: "Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",
              editEdgeDescription: "Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",
              createEdgeError: "Es ist nicht m\xF6glich, Kanten mit Clustern zu verbinden.",
              deleteClusterError: "Cluster k\xF6nnen nicht gel\xF6scht werden.",
              editClusterError: "Cluster k\xF6nnen nicht editiert werden."
            };
            exports2["de_DE"] = exports2["de"];
            exports2["es"] = {
              edit: "Editar",
              del: "Eliminar selecci\xF3n",
              back: "\xC1tras",
              addNode: "A\xF1adir nodo",
              addEdge: "A\xF1adir arista",
              editNode: "Editar nodo",
              editEdge: "Editar arista",
              addDescription: "Haga clic en un lugar vac\xEDo para colocar un nuevo nodo.",
              edgeDescription: "Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",
              editEdgeDescription: "Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",
              createEdgeError: "No se puede conectar una arista a un grupo.",
              deleteClusterError: "No es posible eliminar grupos.",
              editClusterError: "No es posible editar grupos."
            };
            exports2["es_ES"] = exports2["es"];
            exports2["it"] = {
              edit: "Modifica",
              del: "Cancella la selezione",
              back: "Indietro",
              addNode: "Aggiungi un nodo",
              addEdge: "Aggiungi un vertice",
              editNode: "Modifica il nodo",
              editEdge: "Modifica il vertice",
              addDescription: "Clicca per aggiungere un nuovo nodo",
              edgeDescription: "Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",
              editEdgeDescription: "Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",
              createEdgeError: "Non si possono collegare vertici ad un cluster",
              deleteClusterError: "I cluster non possono essere cancellati",
              editClusterError: "I clusters non possono essere modificati."
            };
            exports2["it_IT"] = exports2["it"];
            exports2["nl"] = {
              edit: "Wijzigen",
              del: "Selectie verwijderen",
              back: "Terug",
              addNode: "Node toevoegen",
              addEdge: "Link toevoegen",
              editNode: "Node wijzigen",
              editEdge: "Link wijzigen",
              addDescription: "Klik op een leeg gebied om een nieuwe node te maken.",
              edgeDescription: "Klik op een node en sleep de link naar een andere node om ze te verbinden.",
              editEdgeDescription: "Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",
              createEdgeError: "Kan geen link maken naar een cluster.",
              deleteClusterError: "Clusters kunnen niet worden verwijderd.",
              editClusterError: "Clusters kunnen niet worden aangepast."
            };
            exports2["nl_NL"] = exports2["nl"];
            exports2["nl_BE"] = exports2["nl"];
            exports2["pt-br"] = {
              edit: "Editar",
              del: "Remover selecionado",
              back: "Voltar",
              addNode: "Adicionar n\xF3",
              addEdge: "Adicionar aresta",
              editNode: "Editar n\xF3",
              editEdge: "Editar aresta",
              addDescription: "Clique em um espa\xE7o em branco para adicionar um novo n\xF3",
              edgeDescription: "Clique em um n\xF3 e arraste a aresta at\xE9 outro n\xF3 para conect\xE1-los",
              editEdgeDescription: "Clique nos pontos de controle e os arraste para um n\xF3 para conect\xE1-los",
              createEdgeError: "N\xE3o foi poss\xEDvel linkar arestas a um cluster.",
              deleteClusterError: "Clusters n\xE3o puderam ser removidos.",
              editClusterError: "Clusters n\xE3o puderam ser editados."
            };
            exports2["pt-BR"] = exports2["pt-br"];
            exports2["pt_BR"] = exports2["pt-br"];
            exports2["pt_br"] = exports2["pt-br"];
            exports2["ru"] = {
              edit: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C",
              del: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u043E\u0435",
              back: "\u041D\u0430\u0437\u0430\u0434",
              addNode: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0443\u0437\u0435\u043B",
              addEdge: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0440\u0435\u0431\u0440\u043E",
              editNode: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0443\u0437\u0435\u043B",
              editEdge: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0440\u0435\u0431\u0440\u043E",
              addDescription: "\u041A\u043B\u0438\u043A\u043D\u0438\u0442\u0435 \u0432 \u0441\u0432\u043E\u0431\u043E\u0434\u043D\u043E\u0435 \u043C\u0435\u0441\u0442\u043E, \u0447\u0442\u043E\u0431\u044B \u0434\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043D\u043E\u0432\u044B\u0439 \u0443\u0437\u0435\u043B.",
              edgeDescription: "\u041A\u043B\u0438\u043A\u043D\u0438\u0442\u0435 \u043D\u0430 \u0443\u0437\u0435\u043B \u0438 \u043F\u0440\u043E\u0442\u044F\u043D\u0438\u0442\u0435 \u0440\u0435\u0431\u0440\u043E \u043A \u0434\u0440\u0443\u0433\u043E\u043C\u0443 \u0443\u0437\u043B\u0443, \u0447\u0442\u043E\u0431\u044B \u0441\u043E\u0435\u0434\u0438\u043D\u0438\u0442\u044C \u0438\u0445.",
              editEdgeDescription: "\u041A\u043B\u0438\u043A\u043D\u0438\u0442\u0435 \u043D\u0430 \u043A\u043E\u043D\u0442\u0440\u043E\u043B\u044C\u043D\u044B\u0435 \u0442\u043E\u0447\u043A\u0438 \u0438 \u043F\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 \u0438\u0445 \u0432 \u0443\u0437\u0435\u043B, \u0447\u0442\u043E\u0431\u044B \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u043A \u043D\u0435\u043C\u0443.",
              createEdgeError: "\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u0441\u043E\u0435\u0434\u0438\u043D\u0438\u0442\u044C \u0440\u0435\u0431\u0440\u0430 \u0432 \u043A\u043B\u0430\u0441\u0442\u0435\u0440.",
              deleteClusterError: "\u041A\u043B\u0430\u0441\u0442\u0435\u0440\u044B \u043D\u0435 \u043C\u043E\u0433\u0443\u0442 \u0431\u044B\u0442\u044C \u0443\u0434\u0430\u043B\u0435\u043D\u044B",
              editClusterError: "\u041A\u043B\u0430\u0441\u0442\u0435\u0440\u044B \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0434\u043B\u044F \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F."
            };
            exports2["ru_RU"] = exports2["ru"];
            exports2["cn"] = {
              edit: "\u7F16\u8F91",
              del: "\u5220\u9664\u9009\u5B9A",
              back: "\u8FD4\u56DE",
              addNode: "\u6DFB\u52A0\u8282\u70B9",
              addEdge: "\u6DFB\u52A0\u8FDE\u63A5\u7EBF",
              editNode: "\u7F16\u8F91\u8282\u70B9",
              editEdge: "\u7F16\u8F91\u8FDE\u63A5\u7EBF",
              addDescription: "\u5355\u51FB\u7A7A\u767D\u5904\u653E\u7F6E\u65B0\u8282\u70B9\u3002",
              edgeDescription: "\u5355\u51FB\u67D0\u4E2A\u8282\u70B9\u5E76\u5C06\u8BE5\u8FDE\u63A5\u7EBF\u62D6\u52A8\u5230\u53E6\u4E00\u4E2A\u8282\u70B9\u4EE5\u8FDE\u63A5\u5B83\u4EEC\u3002",
              editEdgeDescription: "\u5355\u51FB\u63A7\u5236\u8282\u70B9\u5E76\u5C06\u5B83\u4EEC\u62D6\u5230\u8282\u70B9\u4E0A\u8FDE\u63A5\u3002",
              createEdgeError: "\u65E0\u6CD5\u5C06\u8FDE\u63A5\u7EBF\u8FDE\u63A5\u5230\u7FA4\u96C6\u3002",
              deleteClusterError: "\u65E0\u6CD5\u5220\u9664\u7FA4\u96C6\u3002",
              editClusterError: "\u65E0\u6CD5\u7F16\u8F91\u7FA4\u96C6\u3002"
            };
            exports2["zh_CN"] = exports2["cn"];
            exports2["uk"] = {
              edit: "\u0420\u0435\u0434\u0430\u0433\u0443\u0432\u0430\u0442\u0438",
              del: "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u043E\u0431\u0440\u0430\u043D\u0435",
              back: "\u041D\u0430\u0437\u0430\u0434",
              addNode: "\u0414\u043E\u0434\u0430\u0442\u0438 \u0432\u0443\u0437\u043E\u043B",
              addEdge: "\u0414\u043E\u0434\u0430\u0442\u0438 \u043A\u0440\u0430\u0439",
              editNode: "\u0420\u0435\u0434\u0430\u0433\u0443\u0432\u0430\u0442\u0438 \u0432\u0443\u0437\u043E\u043B",
              editEdge: "\u0420\u0435\u0434\u0430\u0433\u0443\u0432\u0430\u0442\u0438 \u043A\u0440\u0430\u0439",
              addDescription: "K\u043B\u0456\u043A\u043D\u0456\u0442\u044C \u043D\u0430 \u0432\u0456\u043B\u044C\u043D\u0435 \u043C\u0456\u0441\u0446\u0435, \u0449\u043E\u0431 \u0434\u043E\u0434\u0430\u0442\u0438 \u043D\u043E\u0432\u0438\u0439 \u0432\u0443\u0437\u043E\u043B.",
              edgeDescription: "\u041A\u043B\u0456\u043A\u043D\u0456\u0442\u044C \u043D\u0430 \u0432\u0443\u0437\u043E\u043B \u0456 \u043F\u0435\u0440\u0435\u0442\u044F\u0433\u043D\u0456\u0442\u044C \u043A\u0440\u0430\u0439 \u0434\u043E \u0456\u043D\u0448\u043E\u0433\u043E \u0432\u0443\u0437\u043B\u0430, \u0449\u043E\u0431 \u0457\u0445 \u0437'\u0454\u0434\u043D\u0430\u0442\u0438.",
              editEdgeDescription: "\u041A\u043B\u0456\u043A\u043D\u0456\u0442\u044C \u043D\u0430 \u043A\u043E\u043D\u0442\u0440\u043E\u043B\u044C\u043D\u0456 \u0442\u043E\u0447\u043A\u0438 \u0456 \u043F\u0435\u0440\u0435\u0442\u044F\u0433\u043D\u0456\u0442\u044C \u0457\u0445 \u0443 \u0432\u0443\u0437\u043E\u043B, \u0449\u043E\u0431 \u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u0438\u0441\u044F \u0434\u043E \u043D\u044C\u043E\u0433\u043E.",
              createEdgeError: "\u041D\u0435 \u043C\u043E\u0436\u043B\u0438\u0432\u043E \u043E\u0431'\u0454\u0434\u043D\u0430\u0442\u0438 \u043A\u0440\u0430\u0457 \u0432 \u0433\u0440\u0443\u043F\u0443.",
              deleteClusterError: "\u0413\u0440\u0443\u043F\u0438 \u043D\u0435 \u043C\u043E\u0436\u0443\u0442\u044C \u0431\u0443\u0442\u0438 \u0432\u0438\u0434\u0430\u043B\u0435\u043D\u0456.",
              editClusterError: "\u0413\u0440\u0443\u043F\u0438 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0456 \u0434\u043B\u044F \u0440\u0435\u0434\u0430\u0433\u0443\u0432\u0430\u043D\u043D\u044F."
            };
            exports2["uk_UA"] = exports2["uk"];
            exports2["fr"] = {
              edit: "Editer",
              del: "Effacer la selection",
              back: "Retour",
              addNode: "Ajouter un noeud",
              addEdge: "Ajouter un lien",
              editNode: "Editer le noeud",
              editEdge: "Editer le lien",
              addDescription: "Cliquez dans un endroit vide pour placer un noeud.",
              edgeDescription: "Cliquez sur un noeud et glissez le lien vers un autre noeud pour les connecter.",
              editEdgeDescription: "Cliquez sur les points de contr\xF4le et glissez-les pour connecter un noeud.",
              createEdgeError: "Impossible de cr\xE9er un lien vers un cluster.",
              deleteClusterError: "Les clusters ne peuvent pas \xEAtre \xE9ffac\xE9s.",
              editClusterError: "Les clusters ne peuvent pas \xEAtre \xE9dites."
            };
            exports2["fr_FR"] = exports2["fr"];
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(131), __esModule: true };
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(132);
            var $Object = __webpack_require__(6).Object;
            module2.exports = function defineProperty(it, key, desc) {
              return $Object.defineProperty(it, key, desc);
            };
          },
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(11);
            $export($export.S + $export.F * !__webpack_require__(13), "Object", { defineProperty: __webpack_require__(12).f });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CachedImage = function() {
              function CachedImage2() {
                (0, _classCallCheck3["default"])(this, CachedImage2);
                this.NUM_ITERATIONS = 4;
                this.image = new Image();
                this.canvas = document.createElement("canvas");
              }
              (0, _createClass3["default"])(CachedImage2, [{
                key: "init",
                value: function init() {
                  if (this.initialized())
                    return;
                  this.src = this.image.src;
                  var w = this.image.width;
                  var h = this.image.height;
                  this.width = w;
                  this.height = h;
                  var h2 = Math.floor(h / 2);
                  var h4 = Math.floor(h / 4);
                  var h8 = Math.floor(h / 8);
                  var h16 = Math.floor(h / 16);
                  var w2 = Math.floor(w / 2);
                  var w4 = Math.floor(w / 4);
                  var w8 = Math.floor(w / 8);
                  var w16 = Math.floor(w / 16);
                  this.canvas.width = 3 * w4;
                  this.canvas.height = h2;
                  this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];
                  this._fillMipMap();
                }
              }, {
                key: "initialized",
                value: function initialized() {
                  return this.coordinates !== void 0;
                }
              }, {
                key: "_fillMipMap",
                value: function _fillMipMap() {
                  var ctx = this.canvas.getContext("2d");
                  var to = this.coordinates[0];
                  ctx.drawImage(this.image, to[0], to[1], to[2], to[3]);
                  for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {
                    var from = this.coordinates[iterations - 1];
                    var _to = this.coordinates[iterations];
                    ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);
                  }
                }
              }, {
                key: "drawImageAtPosition",
                value: function drawImageAtPosition(ctx, factor, left, top, width, height) {
                  if (!this.initialized())
                    return;
                  if (factor > 2) {
                    factor *= 0.5;
                    var iterations = 0;
                    while (factor > 2 && iterations < this.NUM_ITERATIONS) {
                      factor *= 0.5;
                      iterations += 1;
                    }
                    if (iterations >= this.NUM_ITERATIONS) {
                      iterations = this.NUM_ITERATIONS - 1;
                    }
                    var from = this.coordinates[iterations];
                    ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);
                  } else {
                    ctx.drawImage(this.image, left, top, width, height);
                  }
                }
              }]);
              return CachedImage2;
            }();
            exports2["default"] = CachedImage;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Groups = function() {
              function Groups2() {
                (0, _classCallCheck3["default"])(this, Groups2);
                this.clear();
                this.defaultIndex = 0;
                this.groupsArray = [];
                this.groupIndex = 0;
                this.defaultGroups = [
                  {
                    border: "#2B7CE9",
                    background: "#97C2FC",
                    highlight: { border: "#2B7CE9", background: "#D2E5FF" },
                    hover: { border: "#2B7CE9", background: "#D2E5FF" }
                  },
                  {
                    border: "#FFA500",
                    background: "#FFFF00",
                    highlight: { border: "#FFA500", background: "#FFFFA3" },
                    hover: { border: "#FFA500", background: "#FFFFA3" }
                  },
                  {
                    border: "#FA0A10",
                    background: "#FB7E81",
                    highlight: { border: "#FA0A10", background: "#FFAFB1" },
                    hover: { border: "#FA0A10", background: "#FFAFB1" }
                  },
                  {
                    border: "#41A906",
                    background: "#7BE141",
                    highlight: { border: "#41A906", background: "#A1EC76" },
                    hover: { border: "#41A906", background: "#A1EC76" }
                  },
                  {
                    border: "#E129F0",
                    background: "#EB7DF4",
                    highlight: { border: "#E129F0", background: "#F0B3F5" },
                    hover: { border: "#E129F0", background: "#F0B3F5" }
                  },
                  {
                    border: "#7C29F0",
                    background: "#AD85E4",
                    highlight: { border: "#7C29F0", background: "#D3BDF0" },
                    hover: { border: "#7C29F0", background: "#D3BDF0" }
                  },
                  {
                    border: "#C37F00",
                    background: "#FFA807",
                    highlight: { border: "#C37F00", background: "#FFCA66" },
                    hover: { border: "#C37F00", background: "#FFCA66" }
                  },
                  {
                    border: "#4220FB",
                    background: "#6E6EFD",
                    highlight: { border: "#4220FB", background: "#9B9BFD" },
                    hover: { border: "#4220FB", background: "#9B9BFD" }
                  },
                  {
                    border: "#FD5A77",
                    background: "#FFC0CB",
                    highlight: { border: "#FD5A77", background: "#FFD1D9" },
                    hover: { border: "#FD5A77", background: "#FFD1D9" }
                  },
                  {
                    border: "#4AD63A",
                    background: "#C2FABC",
                    highlight: { border: "#4AD63A", background: "#E6FFE3" },
                    hover: { border: "#4AD63A", background: "#E6FFE3" }
                  },
                  {
                    border: "#990000",
                    background: "#EE0000",
                    highlight: { border: "#BB0000", background: "#FF3333" },
                    hover: { border: "#BB0000", background: "#FF3333" }
                  },
                  {
                    border: "#FF6000",
                    background: "#FF6000",
                    highlight: { border: "#FF6000", background: "#FF6000" },
                    hover: { border: "#FF6000", background: "#FF6000" }
                  },
                  {
                    border: "#97C2FC",
                    background: "#2B7CE9",
                    highlight: { border: "#D2E5FF", background: "#2B7CE9" },
                    hover: { border: "#D2E5FF", background: "#2B7CE9" }
                  },
                  {
                    border: "#399605",
                    background: "#255C03",
                    highlight: { border: "#399605", background: "#255C03" },
                    hover: { border: "#399605", background: "#255C03" }
                  },
                  {
                    border: "#B70054",
                    background: "#FF007E",
                    highlight: { border: "#B70054", background: "#FF007E" },
                    hover: { border: "#B70054", background: "#FF007E" }
                  },
                  {
                    border: "#AD85E4",
                    background: "#7C29F0",
                    highlight: { border: "#D3BDF0", background: "#7C29F0" },
                    hover: { border: "#D3BDF0", background: "#7C29F0" }
                  },
                  {
                    border: "#4557FA",
                    background: "#000EA1",
                    highlight: { border: "#6E6EFD", background: "#000EA1" },
                    hover: { border: "#6E6EFD", background: "#000EA1" }
                  },
                  {
                    border: "#FFC0CB",
                    background: "#FD5A77",
                    highlight: { border: "#FFD1D9", background: "#FD5A77" },
                    hover: { border: "#FFD1D9", background: "#FD5A77" }
                  },
                  {
                    border: "#C2FABC",
                    background: "#74D66A",
                    highlight: { border: "#E6FFE3", background: "#74D66A" },
                    hover: { border: "#E6FFE3", background: "#74D66A" }
                  },
                  {
                    border: "#EE0000",
                    background: "#990000",
                    highlight: { border: "#FF3333", background: "#BB0000" },
                    hover: { border: "#FF3333", background: "#BB0000" }
                  }
                ];
                this.options = {};
                this.defaultOptions = {
                  useDefaultGroups: true
                };
                util.extend(this.options, this.defaultOptions);
              }
              (0, _createClass3["default"])(Groups2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  var optionFields = ["useDefaultGroups"];
                  if (options !== void 0) {
                    for (var groupName in options) {
                      if (options.hasOwnProperty(groupName)) {
                        if (optionFields.indexOf(groupName) === -1) {
                          var group = options[groupName];
                          this.add(groupName, group);
                        }
                      }
                    }
                  }
                }
              }, {
                key: "clear",
                value: function clear() {
                  this.groups = {};
                  this.groupsArray = [];
                }
              }, {
                key: "get",
                value: function get3(groupname) {
                  var shouldCreate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  var group = this.groups[groupname];
                  if (group === void 0 && shouldCreate) {
                    if (this.options.useDefaultGroups === false && this.groupsArray.length > 0) {
                      var index = this.groupIndex % this.groupsArray.length;
                      this.groupIndex++;
                      group = {};
                      group.color = this.groups[this.groupsArray[index]];
                      this.groups[groupname] = group;
                    } else {
                      var _index = this.defaultIndex % this.defaultGroups.length;
                      this.defaultIndex++;
                      group = {};
                      group.color = this.defaultGroups[_index];
                      this.groups[groupname] = group;
                    }
                  }
                  return group;
                }
              }, {
                key: "add",
                value: function add2(groupName, style) {
                  this.groups[groupName] = style;
                  this.groupsArray.push(groupName);
                  return style;
                }
              }]);
              return Groups2;
            }();
            exports2["default"] = Groups;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var DataSet2 = __webpack_require__(33);
            var DataView = __webpack_require__(51);
            var Node = __webpack_require__(34)["default"];
            var NodesHandler = function() {
              function NodesHandler2(body, images, groups, layoutEngine) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, NodesHandler2);
                this.body = body;
                this.images = images;
                this.groups = groups;
                this.layoutEngine = layoutEngine;
                this.body.functions.createNode = this.create.bind(this);
                this.nodesListeners = {
                  add: function add2(event, params) {
                    _this.add(params.items);
                  },
                  update: function update(event, params) {
                    _this.update(params.items, params.data, params.oldData);
                  },
                  remove: function remove2(event, params) {
                    _this.remove(params.items);
                  }
                };
                this.defaultOptions = {
                  borderWidth: 1,
                  borderWidthSelected: 2,
                  brokenImage: void 0,
                  color: {
                    border: "#2B7CE9",
                    background: "#97C2FC",
                    highlight: {
                      border: "#2B7CE9",
                      background: "#D2E5FF"
                    },
                    hover: {
                      border: "#2B7CE9",
                      background: "#D2E5FF"
                    }
                  },
                  fixed: {
                    x: false,
                    y: false
                  },
                  font: {
                    color: "#343434",
                    size: 14,
                    face: "arial",
                    background: "none",
                    strokeWidth: 0,
                    strokeColor: "#ffffff",
                    align: "center",
                    vadjust: 0,
                    multi: false,
                    bold: {
                      mod: "bold"
                    },
                    boldital: {
                      mod: "bold italic"
                    },
                    ital: {
                      mod: "italic"
                    },
                    mono: {
                      mod: "",
                      size: 15,
                      face: "monospace",
                      vadjust: 2
                    }
                  },
                  group: void 0,
                  hidden: false,
                  icon: {
                    face: "FontAwesome",
                    code: void 0,
                    size: 50,
                    color: "#2B7CE9"
                  },
                  image: void 0,
                  label: void 0,
                  labelHighlightBold: true,
                  level: void 0,
                  margin: {
                    top: 5,
                    right: 5,
                    bottom: 5,
                    left: 5
                  },
                  mass: 1,
                  physics: true,
                  scaling: {
                    min: 10,
                    max: 30,
                    label: {
                      enabled: false,
                      min: 14,
                      max: 30,
                      maxVisible: 30,
                      drawThreshold: 5
                    },
                    customScalingFunction: function customScalingFunction(min, max, total, value) {
                      if (max === min) {
                        return 0.5;
                      } else {
                        var scale = 1 / (max - min);
                        return Math.max(0, (value - min) * scale);
                      }
                    }
                  },
                  shadow: {
                    enabled: false,
                    color: "rgba(0,0,0,0.5)",
                    size: 10,
                    x: 5,
                    y: 5
                  },
                  shape: "ellipse",
                  shapeProperties: {
                    borderDashes: false,
                    borderRadius: 6,
                    interpolation: true,
                    useImageSize: false,
                    useBorderWithImage: false
                  },
                  size: 25,
                  title: void 0,
                  value: void 0,
                  x: void 0,
                  y: void 0
                };
                if (this.defaultOptions.mass <= 0) {
                  throw "Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";
                }
                this.options = util.bridgeObject(this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(NodesHandler2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this2 = this;
                  this.body.emitter.on("refreshNodes", this.refresh.bind(this));
                  this.body.emitter.on("refresh", this.refresh.bind(this));
                  this.body.emitter.on("destroy", function() {
                    util.forEach(_this2.nodesListeners, function(callback, event) {
                      if (_this2.body.data.nodes)
                        _this2.body.data.nodes.off(event, callback);
                    });
                    delete _this2.body.functions.createNode;
                    delete _this2.nodesListeners.add;
                    delete _this2.nodesListeners.update;
                    delete _this2.nodesListeners.remove;
                    delete _this2.nodesListeners;
                  });
                }
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    Node.parseOptions(this.options, options);
                    if (options.shape !== void 0) {
                      for (var nodeId in this.body.nodes) {
                        if (this.body.nodes.hasOwnProperty(nodeId)) {
                          this.body.nodes[nodeId].updateShape();
                        }
                      }
                    }
                    if (options.font !== void 0) {
                      for (var _nodeId in this.body.nodes) {
                        if (this.body.nodes.hasOwnProperty(_nodeId)) {
                          this.body.nodes[_nodeId].updateLabelModule();
                          this.body.nodes[_nodeId].needsRefresh();
                        }
                      }
                    }
                    if (options.size !== void 0) {
                      for (var _nodeId2 in this.body.nodes) {
                        if (this.body.nodes.hasOwnProperty(_nodeId2)) {
                          this.body.nodes[_nodeId2].needsRefresh();
                        }
                      }
                    }
                    if (options.hidden !== void 0 || options.physics !== void 0) {
                      this.body.emitter.emit("_dataChanged");
                    }
                  }
                }
              }, {
                key: "setData",
                value: function setData(nodes2) {
                  var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var oldNodesData = this.body.data.nodes;
                  if (nodes2 instanceof DataSet2 || nodes2 instanceof DataView) {
                    this.body.data.nodes = nodes2;
                  } else if (Array.isArray(nodes2)) {
                    this.body.data.nodes = new DataSet2();
                    this.body.data.nodes.add(nodes2);
                  } else if (!nodes2) {
                    this.body.data.nodes = new DataSet2();
                  } else {
                    throw new TypeError("Array or DataSet expected");
                  }
                  if (oldNodesData) {
                    util.forEach(this.nodesListeners, function(callback, event) {
                      oldNodesData.off(event, callback);
                    });
                  }
                  this.body.nodes = {};
                  if (this.body.data.nodes) {
                    var me = this;
                    util.forEach(this.nodesListeners, function(callback, event) {
                      me.body.data.nodes.on(event, callback);
                    });
                    var ids = this.body.data.nodes.getIds();
                    this.add(ids, true);
                  }
                  if (doNotEmit === false) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
              }, {
                key: "add",
                value: function add2(ids) {
                  var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var id2 = void 0;
                  var newNodes = [];
                  for (var i = 0; i < ids.length; i++) {
                    id2 = ids[i];
                    var properties = this.body.data.nodes.get(id2);
                    var node = this.create(properties);
                    newNodes.push(node);
                    this.body.nodes[id2] = node;
                  }
                  this.layoutEngine.positionInitially(newNodes);
                  if (doNotEmit === false) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
              }, {
                key: "update",
                value: function update(ids, changedData, oldData) {
                  var nodes2 = this.body.nodes;
                  var dataChanged = false;
                  for (var i = 0; i < ids.length; i++) {
                    var id2 = ids[i];
                    var node = nodes2[id2];
                    var data = changedData[i];
                    if (node !== void 0) {
                      if (node.setOptions(data)) {
                        dataChanged = true;
                      }
                    } else {
                      dataChanged = true;
                      node = this.create(data);
                      nodes2[id2] = node;
                    }
                  }
                  if (!dataChanged && oldData !== void 0) {
                    dataChanged = changedData.some(function(newValue, index) {
                      var oldValue = oldData[index];
                      return oldValue && oldValue.level !== newValue.level;
                    });
                  }
                  if (dataChanged === true) {
                    this.body.emitter.emit("_dataChanged");
                  } else {
                    this.body.emitter.emit("_dataUpdated");
                  }
                }
              }, {
                key: "remove",
                value: function remove2(ids) {
                  var nodes2 = this.body.nodes;
                  for (var i = 0; i < ids.length; i++) {
                    var id2 = ids[i];
                    delete nodes2[id2];
                  }
                  this.body.emitter.emit("_dataChanged");
                }
              }, {
                key: "create",
                value: function create(properties) {
                  var constructorClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Node;
                  return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);
                }
              }, {
                key: "refresh",
                value: function refresh() {
                  var _this3 = this;
                  var clearPositions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  util.forEach(this.body.nodes, function(node, nodeId) {
                    var data = _this3.body.data.nodes.get(nodeId);
                    if (data !== void 0) {
                      if (clearPositions === true) {
                        node.setOptions({ x: null, y: null });
                      }
                      node.setOptions({ fixed: false });
                      node.setOptions(data);
                    }
                  });
                }
              }, {
                key: "getPositions",
                value: function getPositions(ids) {
                  var dataArray = {};
                  if (ids !== void 0) {
                    if (Array.isArray(ids) === true) {
                      for (var i = 0; i < ids.length; i++) {
                        if (this.body.nodes[ids[i]] !== void 0) {
                          var node = this.body.nodes[ids[i]];
                          dataArray[ids[i]] = { x: Math.round(node.x), y: Math.round(node.y) };
                        }
                      }
                    } else {
                      if (this.body.nodes[ids] !== void 0) {
                        var _node = this.body.nodes[ids];
                        dataArray[ids] = { x: Math.round(_node.x), y: Math.round(_node.y) };
                      }
                    }
                  } else {
                    for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {
                      var _node2 = this.body.nodes[this.body.nodeIndices[_i]];
                      dataArray[this.body.nodeIndices[_i]] = {
                        x: Math.round(_node2.x),
                        y: Math.round(_node2.y)
                      };
                    }
                  }
                  return dataArray;
                }
              }, {
                key: "storePositions",
                value: function storePositions() {
                  var dataArray = [];
                  var dataset = this.body.data.nodes.getDataSet();
                  for (var nodeId in dataset._data) {
                    if (dataset._data.hasOwnProperty(nodeId)) {
                      var node = this.body.nodes[nodeId];
                      if (dataset._data[nodeId].x != Math.round(node.x) || dataset._data[nodeId].y != Math.round(node.y)) {
                        dataArray.push({
                          id: node.id,
                          x: Math.round(node.x),
                          y: Math.round(node.y)
                        });
                      }
                    }
                  }
                  dataset.update(dataArray);
                }
              }, {
                key: "getBoundingBox",
                value: function getBoundingBox(nodeId) {
                  if (this.body.nodes[nodeId] !== void 0) {
                    return this.body.nodes[nodeId].shape.boundingBox;
                  }
                }
              }, {
                key: "getConnectedNodes",
                value: function getConnectedNodes(nodeId, direction) {
                  var nodeList = [];
                  if (this.body.nodes[nodeId] !== void 0) {
                    var node = this.body.nodes[nodeId];
                    var nodeObj = {};
                    for (var i = 0; i < node.edges.length; i++) {
                      var edge = node.edges[i];
                      if (direction !== "to" && edge.toId == node.id) {
                        if (nodeObj[edge.fromId] === void 0) {
                          nodeList.push(edge.fromId);
                          nodeObj[edge.fromId] = true;
                        }
                      } else if (direction !== "from" && edge.fromId == node.id) {
                        if (nodeObj[edge.toId] === void 0) {
                          nodeList.push(edge.toId);
                          nodeObj[edge.toId] = true;
                        }
                      }
                    }
                  }
                  return nodeList;
                }
              }, {
                key: "getConnectedEdges",
                value: function getConnectedEdges(nodeId) {
                  var edgeList = [];
                  if (this.body.nodes[nodeId] !== void 0) {
                    var node = this.body.nodes[nodeId];
                    for (var i = 0; i < node.edges.length; i++) {
                      edgeList.push(node.edges[i].id);
                    }
                  } else {
                    console.log("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
                  }
                  return edgeList;
                }
              }, {
                key: "moveNode",
                value: function moveNode(nodeId, x, y) {
                  var _this4 = this;
                  if (this.body.nodes[nodeId] !== void 0) {
                    this.body.nodes[nodeId].x = Number(x);
                    this.body.nodes[nodeId].y = Number(y);
                    setTimeout(function() {
                      _this4.body.emitter.emit("startSimulation");
                    }, 0);
                  } else {
                    console.log("Node id supplied to moveNode does not exist. Provided: ", nodeId);
                  }
                }
              }]);
              return NodesHandler2;
            }();
            exports2["default"] = NodesHandler;
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(137), __esModule: true };
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(37);
            __webpack_require__(47);
            module2.exports = __webpack_require__(138);
          },
          function(module2, exports2, __webpack_require__) {
            var classof = __webpack_require__(67);
            var ITERATOR = __webpack_require__(8)("iterator");
            var Iterators = __webpack_require__(25);
            module2.exports = __webpack_require__(6).isIterable = function(it) {
              var O = Object(it);
              return O[ITERATOR] !== void 0 || "@@iterator" in O || Iterators.hasOwnProperty(classof(O));
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(15);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var LabelAccumulator = __webpack_require__(140)["default"];
            var ComponentUtil = __webpack_require__(35)["default"];
            var tagPattern = {
              "<b>": /<b>/,
              "<i>": /<i>/,
              "<code>": /<code>/,
              "</b>": /<\/b>/,
              "</i>": /<\/i>/,
              "</code>": /<\/code>/,
              "*": /\*/,
              _: /\_/,
              "`": /`/,
              afterBold: /[^\*]/,
              afterItal: /[^_]/,
              afterMono: /[^`]/
            };
            var MarkupAccumulator = function() {
              function MarkupAccumulator2(text) {
                (0, _classCallCheck3["default"])(this, MarkupAccumulator2);
                this.text = text;
                this.bold = false;
                this.ital = false;
                this.mono = false;
                this.spacing = false;
                this.position = 0;
                this.buffer = "";
                this.modStack = [];
                this.blocks = [];
              }
              (0, _createClass3["default"])(MarkupAccumulator2, [{
                key: "mod",
                value: function mod() {
                  return this.modStack.length === 0 ? "normal" : this.modStack[0];
                }
              }, {
                key: "modName",
                value: function modName() {
                  if (this.modStack.length === 0)
                    return "normal";
                  else if (this.modStack[0] === "mono")
                    return "mono";
                  else {
                    if (this.bold && this.ital) {
                      return "boldital";
                    } else if (this.bold) {
                      return "bold";
                    } else if (this.ital) {
                      return "ital";
                    }
                  }
                }
              }, {
                key: "emitBlock",
                value: function emitBlock() {
                  if (this.spacing) {
                    this.add(" ");
                    this.spacing = false;
                  }
                  if (this.buffer.length > 0) {
                    this.blocks.push({ text: this.buffer, mod: this.modName() });
                    this.buffer = "";
                  }
                }
              }, {
                key: "add",
                value: function add2(text) {
                  if (text === " ") {
                    this.spacing = true;
                  }
                  if (this.spacing) {
                    this.buffer += " ";
                    this.spacing = false;
                  }
                  if (text != " ") {
                    this.buffer += text;
                  }
                }
              }, {
                key: "parseWS",
                value: function parseWS(ch) {
                  if (/[ \t]/.test(ch)) {
                    if (!this.mono) {
                      this.spacing = true;
                    } else {
                      this.add(ch);
                    }
                    return true;
                  }
                  return false;
                }
              }, {
                key: "setTag",
                value: function setTag(tagName) {
                  this.emitBlock();
                  this[tagName] = true;
                  this.modStack.unshift(tagName);
                }
              }, {
                key: "unsetTag",
                value: function unsetTag(tagName) {
                  this.emitBlock();
                  this[tagName] = false;
                  this.modStack.shift();
                }
              }, {
                key: "parseStartTag",
                value: function parseStartTag(tagName, tag) {
                  if (!this.mono && !this[tagName] && this.match(tag)) {
                    this.setTag(tagName);
                    return true;
                  }
                  return false;
                }
              }, {
                key: "match",
                value: function match(tag) {
                  var advance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  var _prepareRegExp = this.prepareRegExp(tag), _prepareRegExp2 = (0, _slicedToArray3["default"])(_prepareRegExp, 2), regExp = _prepareRegExp2[0], length2 = _prepareRegExp2[1];
                  var matched = regExp.test(this.text.substr(this.position, length2));
                  if (matched && advance) {
                    this.position += length2 - 1;
                  }
                  return matched;
                }
              }, {
                key: "parseEndTag",
                value: function parseEndTag(tagName, tag, nextTag) {
                  var checkTag = this.mod() === tagName;
                  if (tagName === "mono") {
                    checkTag = checkTag && this.mono;
                  } else {
                    checkTag = checkTag && !this.mono;
                  }
                  if (checkTag && this.match(tag)) {
                    if (nextTag !== void 0) {
                      if (this.position === this.text.length - 1 || this.match(nextTag, false)) {
                        this.unsetTag(tagName);
                      }
                    } else {
                      this.unsetTag(tagName);
                    }
                    return true;
                  }
                  return false;
                }
              }, {
                key: "replace",
                value: function replace(tag, value) {
                  if (this.match(tag)) {
                    this.add(value);
                    this.position += length - 1;
                    return true;
                  }
                  return false;
                }
              }, {
                key: "prepareRegExp",
                value: function prepareRegExp(tag) {
                  var length2 = void 0;
                  var regExp = void 0;
                  if (tag instanceof RegExp) {
                    regExp = tag;
                    length2 = 1;
                  } else {
                    var prepared = tagPattern[tag];
                    if (prepared !== void 0) {
                      regExp = prepared;
                    } else {
                      regExp = new RegExp(tag);
                    }
                    length2 = tag.length;
                  }
                  return [regExp, length2];
                }
              }]);
              return MarkupAccumulator2;
            }();
            var LabelSplitter = function() {
              function LabelSplitter2(ctx, parent, selected, hover) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, LabelSplitter2);
                this.ctx = ctx;
                this.parent = parent;
                this.selected = selected;
                this.hover = hover;
                var textWidth = function textWidth2(text, mod) {
                  if (text === void 0)
                    return 0;
                  var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);
                  var width = 0;
                  if (text !== "") {
                    var measure = _this.ctx.measureText(text);
                    width = measure.width;
                  }
                  return { width, values };
                };
                this.lines = new LabelAccumulator(textWidth);
              }
              (0, _createClass3["default"])(LabelSplitter2, [{
                key: "process",
                value: function process(text) {
                  if (!ComponentUtil.isValidLabel(text)) {
                    return this.lines.finalize();
                  }
                  var font = this.parent.fontOptions;
                  text = text.replace(/\r\n/g, "\n");
                  text = text.replace(/\r/g, "\n");
                  var nlLines = String(text).split("\n");
                  var lineCount = nlLines.length;
                  if (font.multi) {
                    for (var i = 0; i < lineCount; i++) {
                      var blocks = this.splitBlocks(nlLines[i], font.multi);
                      if (blocks === void 0)
                        continue;
                      if (blocks.length === 0) {
                        this.lines.newLine("");
                        continue;
                      }
                      if (font.maxWdt > 0) {
                        for (var j = 0; j < blocks.length; j++) {
                          var mod = blocks[j].mod;
                          var _text = blocks[j].text;
                          this.splitStringIntoLines(_text, mod, true);
                        }
                      } else {
                        for (var _j = 0; _j < blocks.length; _j++) {
                          var _mod = blocks[_j].mod;
                          var _text2 = blocks[_j].text;
                          this.lines.append(_text2, _mod);
                        }
                      }
                      this.lines.newLine();
                    }
                  } else {
                    if (font.maxWdt > 0) {
                      for (var _i = 0; _i < lineCount; _i++) {
                        this.splitStringIntoLines(nlLines[_i]);
                      }
                    } else {
                      for (var _i2 = 0; _i2 < lineCount; _i2++) {
                        this.lines.newLine(nlLines[_i2]);
                      }
                    }
                  }
                  return this.lines.finalize();
                }
              }, {
                key: "decodeMarkupSystem",
                value: function decodeMarkupSystem(markupSystem) {
                  var system = "none";
                  if (markupSystem === "markdown" || markupSystem === "md") {
                    system = "markdown";
                  } else if (markupSystem === true || markupSystem === "html") {
                    system = "html";
                  }
                  return system;
                }
              }, {
                key: "splitHtmlBlocks",
                value: function splitHtmlBlocks(text) {
                  var s = new MarkupAccumulator(text);
                  var parseEntities = function parseEntities2(ch2) {
                    if (/&/.test(ch2)) {
                      var parsed2 = s.replace(s.text, "&lt;", "<") || s.replace(s.text, "&amp;", "&");
                      if (!parsed2) {
                        s.add("&");
                      }
                      return true;
                    }
                    return false;
                  };
                  while (s.position < s.text.length) {
                    var ch = s.text.charAt(s.position);
                    var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag("bold", "<b>") || s.parseStartTag("ital", "<i>") || s.parseStartTag("mono", "<code>") || s.parseEndTag("bold", "</b>") || s.parseEndTag("ital", "</i>") || s.parseEndTag("mono", "</code>")) || parseEntities(ch);
                    if (!parsed) {
                      s.add(ch);
                    }
                    s.position++;
                  }
                  s.emitBlock();
                  return s.blocks;
                }
              }, {
                key: "splitMarkdownBlocks",
                value: function splitMarkdownBlocks(text) {
                  var _this2 = this;
                  var s = new MarkupAccumulator(text);
                  var beginable = true;
                  var parseOverride = function parseOverride2(ch2) {
                    if (/\\/.test(ch2)) {
                      if (s.position < _this2.text.length + 1) {
                        s.position++;
                        ch2 = _this2.text.charAt(s.position);
                        if (/ \t/.test(ch2)) {
                          s.spacing = true;
                        } else {
                          s.add(ch2);
                          beginable = false;
                        }
                      }
                      return true;
                    }
                    return false;
                  };
                  while (s.position < s.text.length) {
                    var ch = s.text.charAt(s.position);
                    var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag("bold", "*") || s.parseStartTag("ital", "_") || s.parseStartTag("mono", "`")) || s.parseEndTag("bold", "*", "afterBold") || s.parseEndTag("ital", "_", "afterItal") || s.parseEndTag("mono", "`", "afterMono");
                    if (!parsed) {
                      s.add(ch);
                      beginable = false;
                    }
                    s.position++;
                  }
                  s.emitBlock();
                  return s.blocks;
                }
              }, {
                key: "splitBlocks",
                value: function splitBlocks(text, markupSystem) {
                  var system = this.decodeMarkupSystem(markupSystem);
                  if (system === "none") {
                    return [{
                      text,
                      mod: "normal"
                    }];
                  } else if (system === "markdown") {
                    return this.splitMarkdownBlocks(text);
                  } else if (system === "html") {
                    return this.splitHtmlBlocks(text);
                  }
                }
              }, {
                key: "overMaxWidth",
                value: function overMaxWidth(text) {
                  var width = this.ctx.measureText(text).width;
                  return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;
                }
              }, {
                key: "getLongestFit",
                value: function getLongestFit(words) {
                  var text = "";
                  var w = 0;
                  while (w < words.length) {
                    var pre = text === "" ? "" : " ";
                    var newText = text + pre + words[w];
                    if (this.overMaxWidth(newText))
                      break;
                    text = newText;
                    w++;
                  }
                  return w;
                }
              }, {
                key: "getLongestFitWord",
                value: function getLongestFitWord(words) {
                  var w = 0;
                  while (w < words.length) {
                    if (this.overMaxWidth(words.slice(0, w)))
                      break;
                    w++;
                  }
                  return w;
                }
              }, {
                key: "splitStringIntoLines",
                value: function splitStringIntoLines(str) {
                  var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
                  var appendLast = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod);
                  str = str.replace(/^( +)/g, "$1\r");
                  str = str.replace(/([^\r][^ ]*)( +)/g, "$1\r$2\r");
                  var words = str.split("\r");
                  while (words.length > 0) {
                    var w = this.getLongestFit(words);
                    if (w === 0) {
                      var word = words[0];
                      var x = this.getLongestFitWord(word);
                      this.lines.newLine(word.slice(0, x), mod);
                      words[0] = word.slice(x);
                    } else {
                      var newW = w;
                      if (words[w - 1] === " ") {
                        w--;
                      } else if (words[newW] === " ") {
                        newW++;
                      }
                      var text = words.slice(0, w).join("");
                      if (w == words.length && appendLast) {
                        this.lines.append(text, mod);
                      } else {
                        this.lines.newLine(text, mod);
                      }
                      words = words.slice(newW);
                    }
                  }
                }
              }]);
              return LabelSplitter2;
            }();
            exports2["default"] = LabelSplitter;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _assign = __webpack_require__(78);
            var _assign2 = _interopRequireDefault(_assign);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var LabelAccumulator = function() {
              function LabelAccumulator2(measureText) {
                (0, _classCallCheck3["default"])(this, LabelAccumulator2);
                this.measureText = measureText;
                this.current = 0;
                this.width = 0;
                this.height = 0;
                this.lines = [];
              }
              (0, _createClass3["default"])(LabelAccumulator2, [{
                key: "_add",
                value: function _add2(l, text) {
                  var mod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "normal";
                  if (this.lines[l] === void 0) {
                    this.lines[l] = {
                      width: 0,
                      height: 0,
                      blocks: []
                    };
                  }
                  var tmpText = text;
                  if (text === void 0 || text === "")
                    tmpText = " ";
                  var result2 = this.measureText(tmpText, mod);
                  var block = (0, _assign2["default"])({}, result2.values);
                  block.text = text;
                  block.width = result2.width;
                  block.mod = mod;
                  if (text === void 0 || text === "") {
                    block.width = 0;
                  }
                  this.lines[l].blocks.push(block);
                  this.lines[l].width += block.width;
                }
              }, {
                key: "curWidth",
                value: function curWidth() {
                  var line = this.lines[this.current];
                  if (line === void 0)
                    return 0;
                  return line.width;
                }
              }, {
                key: "append",
                value: function append(text) {
                  var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
                  this._add(this.current, text, mod);
                }
              }, {
                key: "newLine",
                value: function newLine(text) {
                  var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
                  this._add(this.current, text, mod);
                  this.current++;
                }
              }, {
                key: "determineLineHeights",
                value: function determineLineHeights() {
                  for (var k = 0; k < this.lines.length; k++) {
                    var line = this.lines[k];
                    var height = 0;
                    if (line.blocks !== void 0) {
                      for (var l = 0; l < line.blocks.length; l++) {
                        var block = line.blocks[l];
                        if (height < block.height) {
                          height = block.height;
                        }
                      }
                    }
                    line.height = height;
                  }
                }
              }, {
                key: "determineLabelSize",
                value: function determineLabelSize() {
                  var width = 0;
                  var height = 0;
                  for (var k = 0; k < this.lines.length; k++) {
                    var line = this.lines[k];
                    if (line.width > width) {
                      width = line.width;
                    }
                    height += line.height;
                  }
                  this.width = width;
                  this.height = height;
                }
              }, {
                key: "removeEmptyBlocks",
                value: function removeEmptyBlocks() {
                  var tmpLines = [];
                  for (var k = 0; k < this.lines.length; k++) {
                    var line = this.lines[k];
                    if (line.blocks.length === 0)
                      continue;
                    if (k === this.lines.length - 1) {
                      if (line.width === 0)
                        continue;
                    }
                    var tmpLine = {};
                    (0, _assign2["default"])(tmpLine, line);
                    tmpLine.blocks = [];
                    var firstEmptyBlock = void 0;
                    var tmpBlocks = [];
                    for (var l = 0; l < line.blocks.length; l++) {
                      var block = line.blocks[l];
                      if (block.width !== 0) {
                        tmpBlocks.push(block);
                      } else {
                        if (firstEmptyBlock === void 0) {
                          firstEmptyBlock = block;
                        }
                      }
                    }
                    if (tmpBlocks.length === 0 && firstEmptyBlock !== void 0) {
                      tmpBlocks.push(firstEmptyBlock);
                    }
                    tmpLine.blocks = tmpBlocks;
                    tmpLines.push(tmpLine);
                  }
                  return tmpLines;
                }
              }, {
                key: "finalize",
                value: function finalize() {
                  this.determineLineHeights();
                  this.determineLabelSize();
                  var tmpLines = this.removeEmptyBlocks();
                  return {
                    width: this.width,
                    height: this.height,
                    lines: tmpLines
                  };
                }
              }]);
              return LabelAccumulator2;
            }();
            exports2["default"] = LabelAccumulator;
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(142);
            module2.exports = __webpack_require__(6).Object.assign;
          },
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(11);
            $export($export.S + $export.F, "Object", { assign: __webpack_require__(143) });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var getKeys = __webpack_require__(26);
            var gOPS = __webpack_require__(50);
            var pIE = __webpack_require__(32);
            var toObject = __webpack_require__(30);
            var IObject = __webpack_require__(59);
            var $assign = Object.assign;
            module2.exports = !$assign || __webpack_require__(22)(function() {
              var A = {};
              var B = {};
              var S = Symbol();
              var K = "abcdefghijklmnopqrst";
              A[S] = 7;
              K.split("").forEach(function(k) {
                B[k] = k;
              });
              return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
            }) ? function assign(target, source) {
              var T = toObject(target);
              var aLen = arguments.length;
              var index = 1;
              var getSymbols = gOPS.f;
              var isEnum = pIE.f;
              while (aLen > index) {
                var S = IObject(arguments[index++]);
                var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
                var length2 = keys.length;
                var j = 0;
                var key;
                while (length2 > j)
                  if (isEnum.call(S, key = keys[j++]))
                    T[key] = S[key];
              }
              return T;
            } : $assign;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(16);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Box = function(_NodeBase) {
              (0, _inherits3["default"])(Box2, _NodeBase);
              function Box2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Box2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Box2.__proto__ || (0, _getPrototypeOf2["default"])(Box2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Box2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  if (this.needsRefresh(selected, hover)) {
                    var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
                    this.width = dimensions.width + this.margin.right + this.margin.left;
                    this.height = dimensions.height + this.margin.top + this.margin.bottom;
                    this.radius = this.width / 2;
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.initContextForDraw(ctx, values);
                  ctx.roundRect(this.left, this.top, this.width, this.height, values.borderRadius);
                  this.performFill(ctx, values);
                  this.updateBoundingBox(x, y, ctx, selected, hover);
                  this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
                }
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y, ctx, selected, hover) {
                  this._updateBoundingBox(x, y, ctx, selected, hover);
                  var borderRadius = this.options.shapeProperties.borderRadius;
                  this._addBoundingBoxMargin(borderRadius);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  var borderWidth = this.options.borderWidth;
                  return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
                }
              }]);
              return Box2;
            }(_NodeBase3["default"]);
            exports2["default"] = Box;
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(146);
            module2.exports = __webpack_require__(6).Object.getPrototypeOf;
          },
          function(module2, exports2, __webpack_require__) {
            var toObject = __webpack_require__(30);
            var $getPrototypeOf = __webpack_require__(66);
            __webpack_require__(68)("getPrototypeOf", function() {
              return function getPrototypeOf(it) {
                return $getPrototypeOf(toObject(it));
              };
            });
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(148), __esModule: true };
          },
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(149);
            module2.exports = __webpack_require__(6).Object.setPrototypeOf;
          },
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(11);
            $export($export.S, "Object", { setPrototypeOf: __webpack_require__(150).set });
          },
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__(21);
            var anObject = __webpack_require__(20);
            var check = function(O, proto) {
              anObject(O);
              if (!isObject2(proto) && proto !== null)
                throw TypeError(proto + ": can't set as prototype!");
            };
            module2.exports = {
              set: Object.setPrototypeOf || ("__proto__" in {} ? function(test, buggy, set) {
                try {
                  set = __webpack_require__(61)(Function.call, __webpack_require__(70).f(Object.prototype, "__proto__").set, 2);
                  set(test, []);
                  buggy = !(test instanceof Array);
                } catch (e) {
                  buggy = true;
                }
                return function setPrototypeOf(O, proto) {
                  check(O, proto);
                  if (buggy)
                    O.__proto__ = proto;
                  else
                    set(O, proto);
                  return O;
                };
              }({}, false) : void 0),
              check
            };
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CircleImageBase2 = __webpack_require__(53);
            var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Circle = function(_CircleImageBase) {
              (0, _inherits3["default"])(Circle2, _CircleImageBase);
              function Circle2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Circle2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Circle2.__proto__ || (0, _getPrototypeOf2["default"])(Circle2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Circle2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  if (this.needsRefresh(selected, hover)) {
                    var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
                    var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);
                    this.options.size = diameter / 2;
                    this.width = diameter;
                    this.height = diameter;
                    this.radius = this.width / 2;
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this._drawRawCircle(ctx, x, y, values);
                  this.updateBoundingBox(x, y);
                  this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);
                }
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.boundingBox.top = y - this.options.size;
                  this.boundingBox.left = x - this.options.size;
                  this.boundingBox.right = x + this.options.size;
                  this.boundingBox.bottom = y + this.options.size;
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  return this.width * 0.5;
                }
              }]);
              return Circle2;
            }(_CircleImageBase3["default"]);
            exports2["default"] = Circle;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CircleImageBase2 = __webpack_require__(53);
            var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CircularImage = function(_CircleImageBase) {
              (0, _inherits3["default"])(CircularImage2, _CircleImageBase);
              function CircularImage2(options, body, labelModule, imageObj, imageObjAlt) {
                (0, _classCallCheck3["default"])(this, CircularImage2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (CircularImage2.__proto__ || (0, _getPrototypeOf2["default"])(CircularImage2)).call(this, options, body, labelModule));
                _this.setImages(imageObj, imageObjAlt);
                return _this;
              }
              (0, _createClass3["default"])(CircularImage2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;
                  if (imageAbsent) {
                    var diameter = this.options.size * 2;
                    this.width = diameter;
                    this.height = diameter;
                    this.radius = 0.5 * this.width;
                    return;
                  }
                  if (this.needsRefresh(selected, hover)) {
                    this._resizeImage();
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.switchImages(selected);
                  this.resize();
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this._drawRawCircle(ctx, x, y, values);
                  ctx.save();
                  ctx.clip();
                  this._drawImageAtPosition(ctx, values);
                  ctx.restore();
                  this._drawImageLabel(ctx, x, y, selected, hover);
                  this.updateBoundingBox(x, y);
                }
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.boundingBox.top = y - this.options.size;
                  this.boundingBox.left = x - this.options.size;
                  this.boundingBox.right = x + this.options.size;
                  this.boundingBox.bottom = y + this.options.size;
                  this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
                  this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
                  this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  return this.width * 0.5;
                }
              }]);
              return CircularImage2;
            }(_CircleImageBase3["default"]);
            exports2["default"] = CircularImage;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(16);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Database = function(_NodeBase) {
              (0, _inherits3["default"])(Database2, _NodeBase);
              function Database2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Database2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Database2.__proto__ || (0, _getPrototypeOf2["default"])(Database2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Database2, [{
                key: "resize",
                value: function resize(ctx, selected, hover) {
                  if (this.needsRefresh(selected, hover)) {
                    var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
                    var size = dimensions.width + this.margin.right + this.margin.left;
                    this.width = size;
                    this.height = size;
                    this.radius = this.width / 2;
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.initContextForDraw(ctx, values);
                  ctx.database(x - this.width / 2, y - this.height / 2, this.width, this.height);
                  this.performFill(ctx, values);
                  this.updateBoundingBox(x, y, ctx, selected, hover);
                  this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Database2;
            }(_NodeBase3["default"]);
            exports2["default"] = Database;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(17);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Diamond = function(_ShapeBase) {
              (0, _inherits3["default"])(Diamond2, _ShapeBase);
              function Diamond2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Diamond2);
                return (0, _possibleConstructorReturn3["default"])(this, (Diamond2.__proto__ || (0, _getPrototypeOf2["default"])(Diamond2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Diamond2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "diamond", 4, x, y, selected, hover, values);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Diamond2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Diamond;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(17);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Dot = function(_ShapeBase) {
              (0, _inherits3["default"])(Dot2, _ShapeBase);
              function Dot2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Dot2);
                return (0, _possibleConstructorReturn3["default"])(this, (Dot2.__proto__ || (0, _getPrototypeOf2["default"])(Dot2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Dot2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "circle", 2, x, y, selected, hover, values);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  return this.options.size;
                }
              }]);
              return Dot2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Dot;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(16);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Ellipse = function(_NodeBase) {
              (0, _inherits3["default"])(Ellipse2, _NodeBase);
              function Ellipse2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Ellipse2);
                return (0, _possibleConstructorReturn3["default"])(this, (Ellipse2.__proto__ || (0, _getPrototypeOf2["default"])(Ellipse2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Ellipse2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  if (this.needsRefresh(selected, hover)) {
                    var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
                    this.height = dimensions.height * 2;
                    this.width = dimensions.width + dimensions.height;
                    this.radius = 0.5 * this.width;
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width * 0.5;
                  this.top = y - this.height * 0.5;
                  this.initContextForDraw(ctx, values);
                  ctx.ellipse_vis(this.left, this.top, this.width, this.height);
                  this.performFill(ctx, values);
                  this.updateBoundingBox(x, y, ctx, selected, hover);
                  this.labelModule.draw(ctx, x, y, selected, hover);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  var a = this.width * 0.5;
                  var b = this.height * 0.5;
                  var w = Math.sin(angle) * a;
                  var h = Math.cos(angle) * b;
                  return a * b / Math.sqrt(w * w + h * h);
                }
              }]);
              return Ellipse2;
            }(_NodeBase3["default"]);
            exports2["default"] = Ellipse;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(16);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Icon = function(_NodeBase) {
              (0, _inherits3["default"])(Icon2, _NodeBase);
              function Icon2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Icon2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Icon2.__proto__ || (0, _getPrototypeOf2["default"])(Icon2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Icon2, [{
                key: "resize",
                value: function resize(ctx, selected, hover) {
                  if (this.needsRefresh(selected, hover)) {
                    this.iconSize = {
                      width: Number(this.options.icon.size),
                      height: Number(this.options.icon.size)
                    };
                    this.width = this.iconSize.width + this.margin.right + this.margin.left;
                    this.height = this.iconSize.height + this.margin.top + this.margin.bottom;
                    this.radius = 0.5 * this.width;
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.options.icon.size = this.options.icon.size || 50;
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this._icon(ctx, x, y, selected, hover, values);
                  if (this.options.label !== void 0) {
                    var iconTextSpacing = 5;
                    this.labelModule.draw(ctx, this.left + this.iconSize.width / 2 + this.margin.left, y + this.height / 2 + iconTextSpacing, selected);
                  }
                  this.updateBoundingBox(x, y);
                }
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.boundingBox.top = y - this.options.icon.size * 0.5;
                  this.boundingBox.left = x - this.options.icon.size * 0.5;
                  this.boundingBox.right = x + this.options.icon.size * 0.5;
                  this.boundingBox.bottom = y + this.options.icon.size * 0.5;
                  if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
                    var iconTextSpacing = 5;
                    this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
                    this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
                    this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
                  }
                }
              }, {
                key: "_icon",
                value: function _icon(ctx, x, y, selected, hover, values) {
                  var iconSize = Number(this.options.icon.size);
                  if (this.options.icon.code !== void 0) {
                    ctx.font = (selected ? "bold " : "") + iconSize + "px " + this.options.icon.face;
                    ctx.fillStyle = this.options.icon.color || "black";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    this.enableShadow(ctx, values);
                    ctx.fillText(this.options.icon.code, x, y);
                    this.disableShadow(ctx, values);
                  } else {
                    console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");
                  }
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Icon2;
            }(_NodeBase3["default"]);
            exports2["default"] = Icon;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CircleImageBase2 = __webpack_require__(53);
            var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Image2 = function(_CircleImageBase) {
              (0, _inherits3["default"])(Image3, _CircleImageBase);
              function Image3(options, body, labelModule, imageObj, imageObjAlt) {
                (0, _classCallCheck3["default"])(this, Image3);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Image3.__proto__ || (0, _getPrototypeOf2["default"])(Image3)).call(this, options, body, labelModule));
                _this.setImages(imageObj, imageObjAlt);
                return _this;
              }
              (0, _createClass3["default"])(Image3, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;
                  if (imageAbsent) {
                    var side = this.options.size * 2;
                    this.width = side;
                    this.height = side;
                    return;
                  }
                  if (this.needsRefresh(selected, hover)) {
                    this._resizeImage();
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.switchImages(selected);
                  this.resize();
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  if (this.options.shapeProperties.useBorderWithImage === true) {
                    var neutralborderWidth = this.options.borderWidth;
                    var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
                    var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
                    ctx.lineWidth = Math.min(this.width, borderWidth);
                    ctx.beginPath();
                    ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
                    ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
                    ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);
                    ctx.fill();
                    this.performStroke(ctx, values);
                    ctx.closePath();
                  }
                  this._drawImageAtPosition(ctx, values);
                  this._drawImageLabel(ctx, x, y, selected, hover);
                  this.updateBoundingBox(x, y);
                }
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.resize();
                  this._updateBoundingBox(x, y);
                  if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
                    this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
                    this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
                    this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
                  }
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Image3;
            }(_CircleImageBase3["default"]);
            exports2["default"] = Image2;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(17);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Square = function(_ShapeBase) {
              (0, _inherits3["default"])(Square2, _ShapeBase);
              function Square2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Square2);
                return (0, _possibleConstructorReturn3["default"])(this, (Square2.__proto__ || (0, _getPrototypeOf2["default"])(Square2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Square2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "square", 2, x, y, selected, hover, values);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Square2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Square;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(17);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hexagon = function(_ShapeBase) {
              (0, _inherits3["default"])(Hexagon2, _ShapeBase);
              function Hexagon2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Hexagon2);
                return (0, _possibleConstructorReturn3["default"])(this, (Hexagon2.__proto__ || (0, _getPrototypeOf2["default"])(Hexagon2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Hexagon2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "hexagon", 4, x, y, selected, hover, values);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Hexagon2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Hexagon;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(17);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Star = function(_ShapeBase) {
              (0, _inherits3["default"])(Star2, _ShapeBase);
              function Star2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Star2);
                return (0, _possibleConstructorReturn3["default"])(this, (Star2.__proto__ || (0, _getPrototypeOf2["default"])(Star2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Star2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "star", 4, x, y, selected, hover, values);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Star2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Star;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(16);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Text = function(_NodeBase) {
              (0, _inherits3["default"])(Text2, _NodeBase);
              function Text2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Text2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Text2.__proto__ || (0, _getPrototypeOf2["default"])(Text2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Text2, [{
                key: "resize",
                value: function resize(ctx, selected, hover) {
                  if (this.needsRefresh(selected, hover)) {
                    this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
                    this.width = this.textSize.width + this.margin.right + this.margin.left;
                    this.height = this.textSize.height + this.margin.top + this.margin.bottom;
                    this.radius = 0.5 * this.width;
                  }
                }
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.enableShadow(ctx, values);
                  this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
                  this.disableShadow(ctx, values);
                  this.updateBoundingBox(x, y, ctx, selected, hover);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Text2;
            }(_NodeBase3["default"]);
            exports2["default"] = Text;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(17);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Triangle = function(_ShapeBase) {
              (0, _inherits3["default"])(Triangle2, _ShapeBase);
              function Triangle2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Triangle2);
                return (0, _possibleConstructorReturn3["default"])(this, (Triangle2.__proto__ || (0, _getPrototypeOf2["default"])(Triangle2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Triangle2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "triangle", 3, x, y, selected, hover, values);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Triangle2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Triangle;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(17);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var TriangleDown = function(_ShapeBase) {
              (0, _inherits3["default"])(TriangleDown2, _ShapeBase);
              function TriangleDown2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, TriangleDown2);
                return (0, _possibleConstructorReturn3["default"])(this, (TriangleDown2.__proto__ || (0, _getPrototypeOf2["default"])(TriangleDown2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(TriangleDown2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "triangleDown", 3, x, y, selected, hover, values);
                }
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return TriangleDown2;
            }(_ShapeBase3["default"]);
            exports2["default"] = TriangleDown;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var DataSet2 = __webpack_require__(33);
            var DataView = __webpack_require__(51);
            var Edge = __webpack_require__(55)["default"];
            var EdgesHandler = function() {
              function EdgesHandler2(body, images, groups) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, EdgesHandler2);
                this.body = body;
                this.images = images;
                this.groups = groups;
                this.body.functions.createEdge = this.create.bind(this);
                this.edgesListeners = {
                  add: function add2(event, params) {
                    _this.add(params.items);
                  },
                  update: function update(event, params) {
                    _this.update(params.items);
                  },
                  remove: function remove2(event, params) {
                    _this.remove(params.items);
                  }
                };
                this.options = {};
                this.defaultOptions = {
                  arrows: {
                    to: { enabled: false, scaleFactor: 1, type: "arrow" },
                    middle: { enabled: false, scaleFactor: 1, type: "arrow" },
                    from: { enabled: false, scaleFactor: 1, type: "arrow" }
                  },
                  arrowStrikethrough: true,
                  color: {
                    color: "#848484",
                    highlight: "#848484",
                    hover: "#848484",
                    inherit: "from",
                    opacity: 1
                  },
                  dashes: false,
                  font: {
                    color: "#343434",
                    size: 14,
                    face: "arial",
                    background: "none",
                    strokeWidth: 2,
                    strokeColor: "#ffffff",
                    align: "horizontal",
                    multi: false,
                    vadjust: 0,
                    bold: {
                      mod: "bold"
                    },
                    boldital: {
                      mod: "bold italic"
                    },
                    ital: {
                      mod: "italic"
                    },
                    mono: {
                      mod: "",
                      size: 15,
                      face: "courier new",
                      vadjust: 2
                    }
                  },
                  hidden: false,
                  hoverWidth: 1.5,
                  label: void 0,
                  labelHighlightBold: true,
                  length: void 0,
                  physics: true,
                  scaling: {
                    min: 1,
                    max: 15,
                    label: {
                      enabled: true,
                      min: 14,
                      max: 30,
                      maxVisible: 30,
                      drawThreshold: 5
                    },
                    customScalingFunction: function customScalingFunction(min, max, total, value) {
                      if (max === min) {
                        return 0.5;
                      } else {
                        var scale = 1 / (max - min);
                        return Math.max(0, (value - min) * scale);
                      }
                    }
                  },
                  selectionWidth: 1.5,
                  selfReferenceSize: 20,
                  shadow: {
                    enabled: false,
                    color: "rgba(0,0,0,0.5)",
                    size: 10,
                    x: 5,
                    y: 5
                  },
                  background: {
                    enabled: false,
                    color: "rgba(111,111,111,1)",
                    size: 10,
                    dashes: false
                  },
                  smooth: {
                    enabled: true,
                    type: "dynamic",
                    forceDirection: "none",
                    roundness: 0.5
                  },
                  title: void 0,
                  width: 1,
                  value: void 0
                };
                util.deepExtend(this.options, this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(EdgesHandler2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this2 = this;
                  this.body.emitter.on("_forceDisableDynamicCurves", function(type) {
                    var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                    if (type === "dynamic") {
                      type = "continuous";
                    }
                    var dataChanged = false;
                    for (var edgeId in _this2.body.edges) {
                      if (_this2.body.edges.hasOwnProperty(edgeId)) {
                        var edge = _this2.body.edges[edgeId];
                        var edgeData = _this2.body.data.edges._data[edgeId];
                        if (edgeData !== void 0) {
                          var smoothOptions = edgeData.smooth;
                          if (smoothOptions !== void 0) {
                            if (smoothOptions.enabled === true && smoothOptions.type === "dynamic") {
                              if (type === void 0) {
                                edge.setOptions({ smooth: false });
                              } else {
                                edge.setOptions({ smooth: { type } });
                              }
                              dataChanged = true;
                            }
                          }
                        }
                      }
                    }
                    if (emit === true && dataChanged === true) {
                      _this2.body.emitter.emit("_dataChanged");
                    }
                  });
                  this.body.emitter.on("_dataUpdated", function() {
                    _this2.reconnectEdges();
                  });
                  this.body.emitter.on("refreshEdges", this.refresh.bind(this));
                  this.body.emitter.on("refresh", this.refresh.bind(this));
                  this.body.emitter.on("destroy", function() {
                    util.forEach(_this2.edgesListeners, function(callback, event) {
                      if (_this2.body.data.edges)
                        _this2.body.data.edges.off(event, callback);
                    });
                    delete _this2.body.functions.createEdge;
                    delete _this2.edgesListeners.add;
                    delete _this2.edgesListeners.update;
                    delete _this2.edgesListeners.remove;
                    delete _this2.edgesListeners;
                  });
                }
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    Edge.parseOptions(this.options, options, true, this.defaultOptions, true);
                    var dataChanged = false;
                    if (options.smooth !== void 0) {
                      for (var edgeId in this.body.edges) {
                        if (this.body.edges.hasOwnProperty(edgeId)) {
                          dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
                        }
                      }
                    }
                    if (options.font !== void 0) {
                      for (var _edgeId in this.body.edges) {
                        if (this.body.edges.hasOwnProperty(_edgeId)) {
                          this.body.edges[_edgeId].updateLabelModule();
                        }
                      }
                    }
                    if (options.hidden !== void 0 || options.physics !== void 0 || dataChanged === true) {
                      this.body.emitter.emit("_dataChanged");
                    }
                  }
                }
              }, {
                key: "setData",
                value: function setData(edges2) {
                  var _this3 = this;
                  var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var oldEdgesData = this.body.data.edges;
                  if (edges2 instanceof DataSet2 || edges2 instanceof DataView) {
                    this.body.data.edges = edges2;
                  } else if (Array.isArray(edges2)) {
                    this.body.data.edges = new DataSet2();
                    this.body.data.edges.add(edges2);
                  } else if (!edges2) {
                    this.body.data.edges = new DataSet2();
                  } else {
                    throw new TypeError("Array or DataSet expected");
                  }
                  if (oldEdgesData) {
                    util.forEach(this.edgesListeners, function(callback, event) {
                      oldEdgesData.off(event, callback);
                    });
                  }
                  this.body.edges = {};
                  if (this.body.data.edges) {
                    util.forEach(this.edgesListeners, function(callback, event) {
                      _this3.body.data.edges.on(event, callback);
                    });
                    var ids = this.body.data.edges.getIds();
                    this.add(ids, true);
                  }
                  this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
                  if (doNotEmit === false) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
              }, {
                key: "add",
                value: function add2(ids) {
                  var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var edges2 = this.body.edges;
                  var edgesData = this.body.data.edges;
                  for (var i = 0; i < ids.length; i++) {
                    var id2 = ids[i];
                    var oldEdge = edges2[id2];
                    if (oldEdge) {
                      oldEdge.disconnect();
                    }
                    var data = edgesData.get(id2, { showInternalIds: true });
                    edges2[id2] = this.create(data);
                  }
                  this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
                  if (doNotEmit === false) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
              }, {
                key: "update",
                value: function update(ids) {
                  var edges2 = this.body.edges;
                  var edgesData = this.body.data.edges;
                  var dataChanged = false;
                  for (var i = 0; i < ids.length; i++) {
                    var id2 = ids[i];
                    var data = edgesData.get(id2);
                    var edge = edges2[id2];
                    if (edge !== void 0) {
                      edge.disconnect();
                      dataChanged = edge.setOptions(data) || dataChanged;
                      edge.connect();
                    } else {
                      this.body.edges[id2] = this.create(data);
                      dataChanged = true;
                    }
                  }
                  if (dataChanged === true) {
                    this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
                    this.body.emitter.emit("_dataChanged");
                  } else {
                    this.body.emitter.emit("_dataUpdated");
                  }
                }
              }, {
                key: "remove",
                value: function remove2(ids) {
                  var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (ids.length === 0)
                    return;
                  var edges2 = this.body.edges;
                  util.forEach(ids, function(id2) {
                    var edge = edges2[id2];
                    if (edge !== void 0) {
                      edge.remove();
                    }
                  });
                  if (emit) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
              }, {
                key: "refresh",
                value: function refresh() {
                  var _this4 = this;
                  util.forEach(this.body.edges, function(edge, edgeId) {
                    var data = _this4.body.data.edges._data[edgeId];
                    if (data !== void 0) {
                      edge.setOptions(data);
                    }
                  });
                }
              }, {
                key: "create",
                value: function create(properties) {
                  return new Edge(properties, this.body, this.options, this.defaultOptions);
                }
              }, {
                key: "reconnectEdges",
                value: function reconnectEdges() {
                  var id2;
                  var nodes2 = this.body.nodes;
                  var edges2 = this.body.edges;
                  for (id2 in nodes2) {
                    if (nodes2.hasOwnProperty(id2)) {
                      nodes2[id2].edges = [];
                    }
                  }
                  for (id2 in edges2) {
                    if (edges2.hasOwnProperty(id2)) {
                      var edge = edges2[id2];
                      edge.from = null;
                      edge.to = null;
                      edge.connect();
                    }
                  }
                }
              }, {
                key: "getConnectedNodes",
                value: function getConnectedNodes(edgeId) {
                  var nodeList = [];
                  if (this.body.edges[edgeId] !== void 0) {
                    var edge = this.body.edges[edgeId];
                    if (edge.fromId !== void 0) {
                      nodeList.push(edge.fromId);
                    }
                    if (edge.toId !== void 0) {
                      nodeList.push(edge.toId);
                    }
                  }
                  return nodeList;
                }
              }, {
                key: "_updateState",
                value: function _updateState() {
                  this._addMissingEdges();
                  this._removeInvalidEdges();
                }
              }, {
                key: "_removeInvalidEdges",
                value: function _removeInvalidEdges() {
                  var _this5 = this;
                  var edgesToDelete = [];
                  util.forEach(this.body.edges, function(edge, id2) {
                    var toNode = _this5.body.nodes[edge.toId];
                    var fromNode = _this5.body.nodes[edge.fromId];
                    if (toNode !== void 0 && toNode.isCluster === true || fromNode !== void 0 && fromNode.isCluster === true) {
                      return;
                    }
                    if (toNode === void 0 || fromNode === void 0) {
                      edgesToDelete.push(id2);
                    }
                  });
                  this.remove(edgesToDelete, false);
                }
              }, {
                key: "_addMissingEdges",
                value: function _addMissingEdges() {
                  var edgesData = this.body.data.edges;
                  if (edgesData === void 0 || edgesData === null) {
                    return;
                  }
                  var edges2 = this.body.edges;
                  var addIds = [];
                  if (edgesData instanceof DataView) {
                    edgesData = edgesData.getDataSet();
                  }
                  edgesData.forEach(function(edgeData, edgeId) {
                    var edge = edges2[edgeId];
                    if (edge === void 0) {
                      addIds.push(edgeId);
                    }
                  });
                  this.add(addIds, true);
                }
              }]);
              return EdgesHandler2;
            }();
            exports2["default"] = EdgesHandler;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(15);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CubicBezierEdgeBase2 = __webpack_require__(167);
            var _CubicBezierEdgeBase3 = _interopRequireDefault(_CubicBezierEdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CubicBezierEdge = function(_CubicBezierEdgeBase) {
              (0, _inherits3["default"])(CubicBezierEdge2, _CubicBezierEdgeBase);
              function CubicBezierEdge2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, CubicBezierEdge2);
                return (0, _possibleConstructorReturn3["default"])(this, (CubicBezierEdge2.__proto__ || (0, _getPrototypeOf2["default"])(CubicBezierEdge2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(CubicBezierEdge2, [{
                key: "_line",
                value: function _line(ctx, values, viaNodes) {
                  var via1 = viaNodes[0];
                  var via2 = viaNodes[1];
                  this._bezierCurve(ctx, values, via1, via2);
                }
              }, {
                key: "_getViaCoordinates",
                value: function _getViaCoordinates() {
                  var dx = this.from.x - this.to.x;
                  var dy = this.from.y - this.to.y;
                  var x1 = void 0, y1 = void 0, x2 = void 0, y2 = void 0;
                  var roundness = this.options.smooth.roundness;
                  if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === "horizontal") && this.options.smooth.forceDirection !== "vertical") {
                    y1 = this.from.y;
                    y2 = this.to.y;
                    x1 = this.from.x - roundness * dx;
                    x2 = this.to.x + roundness * dx;
                  } else {
                    y1 = this.from.y - roundness * dy;
                    y2 = this.to.y + roundness * dy;
                    x1 = this.from.x;
                    x2 = this.to.x;
                  }
                  return [{ x: x1, y: y1 }, { x: x2, y: y2 }];
                }
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return this._getViaCoordinates();
                }
              }, {
                key: "_findBorderPosition",
                value: function _findBorderPosition(nearNode, ctx) {
                  return this._findBorderPositionBezier(nearNode, ctx);
                }
              }, {
                key: "_getDistanceToEdge",
                value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
                  var _ref = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates(), _ref2 = (0, _slicedToArray3["default"])(_ref, 2), via1 = _ref2[0], via2 = _ref2[1];
                  return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2);
                }
              }, {
                key: "getPoint",
                value: function getPoint(percentage) {
                  var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates(), _ref4 = (0, _slicedToArray3["default"])(_ref3, 2), via1 = _ref4[0], via2 = _ref4[1];
                  var t = percentage;
                  var vec = [];
                  vec[0] = Math.pow(1 - t, 3);
                  vec[1] = 3 * t * Math.pow(1 - t, 2);
                  vec[2] = 3 * Math.pow(t, 2) * (1 - t);
                  vec[3] = Math.pow(t, 3);
                  var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
                  var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;
                  return { x, y };
                }
              }]);
              return CubicBezierEdge2;
            }(_CubicBezierEdgeBase3["default"]);
            exports2["default"] = CubicBezierEdge;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _BezierEdgeBase2 = __webpack_require__(56);
            var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CubicBezierEdgeBase = function(_BezierEdgeBase) {
              (0, _inherits3["default"])(CubicBezierEdgeBase2, _BezierEdgeBase);
              function CubicBezierEdgeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, CubicBezierEdgeBase2);
                return (0, _possibleConstructorReturn3["default"])(this, (CubicBezierEdgeBase2.__proto__ || (0, _getPrototypeOf2["default"])(CubicBezierEdgeBase2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(CubicBezierEdgeBase2, [{
                key: "_getDistanceToBezierEdge",
                value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2) {
                  var minDistance = 1e9;
                  var distance = void 0;
                  var i = void 0, t = void 0, x = void 0, y = void 0;
                  var lastX = x1;
                  var lastY = y1;
                  var vec = [0, 0, 0, 0];
                  for (i = 1; i < 10; i++) {
                    t = 0.1 * i;
                    vec[0] = Math.pow(1 - t, 3);
                    vec[1] = 3 * t * Math.pow(1 - t, 2);
                    vec[2] = 3 * Math.pow(t, 2) * (1 - t);
                    vec[3] = Math.pow(t, 3);
                    x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
                    y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;
                    if (i > 0) {
                      distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
                      minDistance = distance < minDistance ? distance : minDistance;
                    }
                    lastX = x;
                    lastY = y;
                  }
                  return minDistance;
                }
              }]);
              return CubicBezierEdgeBase2;
            }(_BezierEdgeBase3["default"]);
            exports2["default"] = CubicBezierEdgeBase;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(15);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _BezierEdgeBase2 = __webpack_require__(56);
            var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BezierEdgeDynamic = function(_BezierEdgeBase) {
              (0, _inherits3["default"])(BezierEdgeDynamic2, _BezierEdgeBase);
              function BezierEdgeDynamic2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, BezierEdgeDynamic2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (BezierEdgeDynamic2.__proto__ || (0, _getPrototypeOf2["default"])(BezierEdgeDynamic2)).call(this, options, body, labelModule));
                _this._boundFunction = function() {
                  _this.positionBezierNode();
                };
                _this.body.emitter.on("_repositionBezierNodes", _this._boundFunction);
                return _this;
              }
              (0, _createClass3["default"])(BezierEdgeDynamic2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  var physicsChange = false;
                  if (this.options.physics !== options.physics) {
                    physicsChange = true;
                  }
                  this.options = options;
                  this.id = this.options.id;
                  this.from = this.body.nodes[this.options.from];
                  this.to = this.body.nodes[this.options.to];
                  this.setupSupportNode();
                  this.connect();
                  if (physicsChange === true) {
                    this.via.setOptions({ physics: this.options.physics });
                    this.positionBezierNode();
                  }
                }
              }, {
                key: "connect",
                value: function connect() {
                  this.from = this.body.nodes[this.options.from];
                  this.to = this.body.nodes[this.options.to];
                  if (this.from === void 0 || this.to === void 0 || this.options.physics === false) {
                    this.via.setOptions({ physics: false });
                  } else {
                    if (this.from.id === this.to.id) {
                      this.via.setOptions({ physics: false });
                    } else {
                      this.via.setOptions({ physics: true });
                    }
                  }
                }
              }, {
                key: "cleanup",
                value: function cleanup() {
                  this.body.emitter.off("_repositionBezierNodes", this._boundFunction);
                  if (this.via !== void 0) {
                    delete this.body.nodes[this.via.id];
                    this.via = void 0;
                    return true;
                  }
                  return false;
                }
              }, {
                key: "setupSupportNode",
                value: function setupSupportNode() {
                  if (this.via === void 0) {
                    var nodeId = "edgeId:" + this.id;
                    var node = this.body.functions.createNode({
                      id: nodeId,
                      shape: "circle",
                      physics: true,
                      hidden: true
                    });
                    this.body.nodes[nodeId] = node;
                    this.via = node;
                    this.via.parentEdgeId = this.id;
                    this.positionBezierNode();
                  }
                }
              }, {
                key: "positionBezierNode",
                value: function positionBezierNode() {
                  if (this.via !== void 0 && this.from !== void 0 && this.to !== void 0) {
                    this.via.x = 0.5 * (this.from.x + this.to.x);
                    this.via.y = 0.5 * (this.from.y + this.to.y);
                  } else if (this.via !== void 0) {
                    this.via.x = 0;
                    this.via.y = 0;
                  }
                }
              }, {
                key: "_line",
                value: function _line(ctx, values, viaNode) {
                  this._bezierCurve(ctx, values, viaNode);
                }
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return this.via;
                }
              }, {
                key: "getPoint",
                value: function getPoint(percentage) {
                  var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.via;
                  var t = percentage;
                  var x = void 0, y = void 0;
                  if (this.from === this.to) {
                    var _getCircleData = this._getCircleData(this.from), _getCircleData2 = (0, _slicedToArray3["default"])(_getCircleData, 3), cx = _getCircleData2[0], cy = _getCircleData2[1], cr = _getCircleData2[2];
                    var a = 2 * Math.PI * (1 - t);
                    x = cx + cr * Math.sin(a);
                    y = cy + cr - cr * (1 - Math.cos(a));
                  } else {
                    x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
                    y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
                  }
                  return { x, y };
                }
              }, {
                key: "_findBorderPosition",
                value: function _findBorderPosition(nearNode, ctx) {
                  return this._findBorderPositionBezier(nearNode, ctx, this.via);
                }
              }, {
                key: "_getDistanceToEdge",
                value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
                  return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
                }
              }]);
              return BezierEdgeDynamic2;
            }(_BezierEdgeBase3["default"]);
            exports2["default"] = BezierEdgeDynamic;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _BezierEdgeBase2 = __webpack_require__(56);
            var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BezierEdgeStatic = function(_BezierEdgeBase) {
              (0, _inherits3["default"])(BezierEdgeStatic2, _BezierEdgeBase);
              function BezierEdgeStatic2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, BezierEdgeStatic2);
                return (0, _possibleConstructorReturn3["default"])(this, (BezierEdgeStatic2.__proto__ || (0, _getPrototypeOf2["default"])(BezierEdgeStatic2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(BezierEdgeStatic2, [{
                key: "_line",
                value: function _line(ctx, values, viaNode) {
                  this._bezierCurve(ctx, values, viaNode);
                }
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return this._getViaCoordinates();
                }
              }, {
                key: "_getViaCoordinates",
                value: function _getViaCoordinates() {
                  var xVia = void 0;
                  var yVia = void 0;
                  var factor = this.options.smooth.roundness;
                  var type = this.options.smooth.type;
                  var dx = Math.abs(this.from.x - this.to.x);
                  var dy = Math.abs(this.from.y - this.to.y);
                  if (type === "discrete" || type === "diagonalCross") {
                    var stepX = void 0;
                    var stepY = void 0;
                    if (dx <= dy) {
                      stepX = stepY = factor * dy;
                    } else {
                      stepX = stepY = factor * dx;
                    }
                    if (this.from.x > this.to.x)
                      stepX = -stepX;
                    if (this.from.y >= this.to.y)
                      stepY = -stepY;
                    xVia = this.from.x + stepX;
                    yVia = this.from.y + stepY;
                    if (type === "discrete") {
                      if (dx <= dy) {
                        xVia = dx < factor * dy ? this.from.x : xVia;
                      } else {
                        yVia = dy < factor * dx ? this.from.y : yVia;
                      }
                    }
                  } else if (type === "straightCross") {
                    var _stepX = (1 - factor) * dx;
                    var _stepY = (1 - factor) * dy;
                    if (dx <= dy) {
                      _stepX = 0;
                      if (this.from.y < this.to.y)
                        _stepY = -_stepY;
                    } else {
                      if (this.from.x < this.to.x)
                        _stepX = -_stepX;
                      _stepY = 0;
                    }
                    xVia = this.to.x + _stepX;
                    yVia = this.to.y + _stepY;
                  } else if (type === "horizontal") {
                    var _stepX2 = (1 - factor) * dx;
                    if (this.from.x < this.to.x)
                      _stepX2 = -_stepX2;
                    xVia = this.to.x + _stepX2;
                    yVia = this.from.y;
                  } else if (type === "vertical") {
                    var _stepY2 = (1 - factor) * dy;
                    if (this.from.y < this.to.y)
                      _stepY2 = -_stepY2;
                    xVia = this.from.x;
                    yVia = this.to.y + _stepY2;
                  } else if (type === "curvedCW") {
                    dx = this.to.x - this.from.x;
                    dy = this.from.y - this.to.y;
                    var radius = Math.sqrt(dx * dx + dy * dy);
                    var pi = Math.PI;
                    var originalAngle = Math.atan2(dy, dx);
                    var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);
                    xVia = this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle);
                    yVia = this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle);
                  } else if (type === "curvedCCW") {
                    dx = this.to.x - this.from.x;
                    dy = this.from.y - this.to.y;
                    var _radius = Math.sqrt(dx * dx + dy * dy);
                    var _pi = Math.PI;
                    var _originalAngle = Math.atan2(dy, dx);
                    var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);
                    xVia = this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle);
                    yVia = this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle);
                  } else {
                    var _stepX3 = void 0;
                    var _stepY3 = void 0;
                    if (dx <= dy) {
                      _stepX3 = _stepY3 = factor * dy;
                    } else {
                      _stepX3 = _stepY3 = factor * dx;
                    }
                    if (this.from.x > this.to.x)
                      _stepX3 = -_stepX3;
                    if (this.from.y >= this.to.y)
                      _stepY3 = -_stepY3;
                    xVia = this.from.x + _stepX3;
                    yVia = this.from.y + _stepY3;
                    if (dx <= dy) {
                      if (this.from.x <= this.to.x) {
                        xVia = this.to.x < xVia ? this.to.x : xVia;
                      } else {
                        xVia = this.to.x > xVia ? this.to.x : xVia;
                      }
                    } else {
                      if (this.from.y >= this.to.y) {
                        yVia = this.to.y > yVia ? this.to.y : yVia;
                      } else {
                        yVia = this.to.y < yVia ? this.to.y : yVia;
                      }
                    }
                  }
                  return { x: xVia, y: yVia };
                }
              }, {
                key: "_findBorderPosition",
                value: function _findBorderPosition(nearNode, ctx) {
                  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  return this._findBorderPositionBezier(nearNode, ctx, options.via);
                }
              }, {
                key: "_getDistanceToEdge",
                value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
                  var viaNode = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates();
                  return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
                }
              }, {
                key: "getPoint",
                value: function getPoint(percentage) {
                  var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates();
                  var t = percentage;
                  var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
                  var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
                  return { x, y };
                }
              }]);
              return BezierEdgeStatic2;
            }(_BezierEdgeBase3["default"]);
            exports2["default"] = BezierEdgeStatic;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _EdgeBase2 = __webpack_require__(79);
            var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var StraightEdge = function(_EdgeBase) {
              (0, _inherits3["default"])(StraightEdge2, _EdgeBase);
              function StraightEdge2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, StraightEdge2);
                return (0, _possibleConstructorReturn3["default"])(this, (StraightEdge2.__proto__ || (0, _getPrototypeOf2["default"])(StraightEdge2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(StraightEdge2, [{
                key: "_line",
                value: function _line(ctx, values) {
                  ctx.beginPath();
                  ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
                  ctx.lineTo(this.toPoint.x, this.toPoint.y);
                  this.enableShadow(ctx, values);
                  ctx.stroke();
                  this.disableShadow(ctx, values);
                }
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return void 0;
                }
              }, {
                key: "getPoint",
                value: function getPoint(percentage) {
                  return {
                    x: (1 - percentage) * this.fromPoint.x + percentage * this.toPoint.x,
                    y: (1 - percentage) * this.fromPoint.y + percentage * this.toPoint.y
                  };
                }
              }, {
                key: "_findBorderPosition",
                value: function _findBorderPosition(nearNode, ctx) {
                  var node1 = this.to;
                  var node2 = this.from;
                  if (nearNode.id === this.from.id) {
                    node1 = this.from;
                    node2 = this.to;
                  }
                  var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
                  var dx = node1.x - node2.x;
                  var dy = node1.y - node2.y;
                  var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
                  var toBorderDist = nearNode.distanceToBorder(ctx, angle);
                  var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;
                  var borderPos = {};
                  borderPos.x = (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x;
                  borderPos.y = (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y;
                  return borderPos;
                }
              }, {
                key: "_getDistanceToEdge",
                value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
                  return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
                }
              }]);
              return StraightEdge2;
            }(_EdgeBase3["default"]);
            exports2["default"] = StraightEdge;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _keys = __webpack_require__(9);
            var _keys2 = _interopRequireDefault(_keys);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BarnesHutSolver = __webpack_require__(81)["default"];
            var Repulsion = __webpack_require__(172)["default"];
            var HierarchicalRepulsion = __webpack_require__(173)["default"];
            var SpringSolver = __webpack_require__(174)["default"];
            var HierarchicalSpringSolver = __webpack_require__(175)["default"];
            var CentralGravitySolver = __webpack_require__(82)["default"];
            var ForceAtlas2BasedRepulsionSolver = __webpack_require__(176)["default"];
            var ForceAtlas2BasedCentralGravitySolver = __webpack_require__(177)["default"];
            var util = __webpack_require__(2);
            var EndPoints = __webpack_require__(80)["default"];
            var PhysicsEngine = function() {
              function PhysicsEngine2(body) {
                (0, _classCallCheck3["default"])(this, PhysicsEngine2);
                this.body = body;
                this.physicsBody = {
                  physicsNodeIndices: [],
                  physicsEdgeIndices: [],
                  forces: {},
                  velocities: {}
                };
                this.physicsEnabled = true;
                this.simulationInterval = 1e3 / 60;
                this.requiresTimeout = true;
                this.previousStates = {};
                this.referenceState = {};
                this.freezeCache = {};
                this.renderTimer = void 0;
                this.adaptiveTimestep = false;
                this.adaptiveTimestepEnabled = false;
                this.adaptiveCounter = 0;
                this.adaptiveInterval = 3;
                this.stabilized = false;
                this.startedStabilization = false;
                this.stabilizationIterations = 0;
                this.ready = false;
                this.options = {};
                this.defaultOptions = {
                  enabled: true,
                  barnesHut: {
                    theta: 0.5,
                    gravitationalConstant: -2e3,
                    centralGravity: 0.3,
                    springLength: 95,
                    springConstant: 0.04,
                    damping: 0.09,
                    avoidOverlap: 0
                  },
                  forceAtlas2Based: {
                    theta: 0.5,
                    gravitationalConstant: -50,
                    centralGravity: 0.01,
                    springConstant: 0.08,
                    springLength: 100,
                    damping: 0.4,
                    avoidOverlap: 0
                  },
                  repulsion: {
                    centralGravity: 0.2,
                    springLength: 200,
                    springConstant: 0.05,
                    nodeDistance: 100,
                    damping: 0.09,
                    avoidOverlap: 0
                  },
                  hierarchicalRepulsion: {
                    centralGravity: 0,
                    springLength: 100,
                    springConstant: 0.01,
                    nodeDistance: 120,
                    damping: 0.09
                  },
                  maxVelocity: 50,
                  minVelocity: 0.75,
                  solver: "barnesHut",
                  stabilization: {
                    enabled: true,
                    iterations: 1e3,
                    updateInterval: 50,
                    onlyDynamicEdges: false,
                    fit: true
                  },
                  timestep: 0.5,
                  adaptiveTimestep: true
                };
                util.extend(this.options, this.defaultOptions);
                this.timestep = 0.5;
                this.layoutFailed = false;
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(PhysicsEngine2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this = this;
                  this.body.emitter.on("initPhysics", function() {
                    _this.initPhysics();
                  });
                  this.body.emitter.on("_layoutFailed", function() {
                    _this.layoutFailed = true;
                  });
                  this.body.emitter.on("resetPhysics", function() {
                    _this.stopSimulation();
                    _this.ready = false;
                  });
                  this.body.emitter.on("disablePhysics", function() {
                    _this.physicsEnabled = false;
                    _this.stopSimulation();
                  });
                  this.body.emitter.on("restorePhysics", function() {
                    _this.setOptions(_this.options);
                    if (_this.ready === true) {
                      _this.startSimulation();
                    }
                  });
                  this.body.emitter.on("startSimulation", function() {
                    if (_this.ready === true) {
                      _this.startSimulation();
                    }
                  });
                  this.body.emitter.on("stopSimulation", function() {
                    _this.stopSimulation();
                  });
                  this.body.emitter.on("destroy", function() {
                    _this.stopSimulation(false);
                    _this.body.emitter.off();
                  });
                  this.body.emitter.on("_dataChanged", function() {
                    _this.updatePhysicsData();
                  });
                }
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    if (options === false) {
                      this.options.enabled = false;
                      this.physicsEnabled = false;
                      this.stopSimulation();
                    } else if (options === true) {
                      this.options.enabled = true;
                      this.physicsEnabled = true;
                      this.startSimulation();
                    } else {
                      this.physicsEnabled = true;
                      util.selectiveNotDeepExtend(["stabilization"], this.options, options);
                      util.mergeOptions(this.options, options, "stabilization");
                      if (options.enabled === void 0) {
                        this.options.enabled = true;
                      }
                      if (this.options.enabled === false) {
                        this.physicsEnabled = false;
                        this.stopSimulation();
                      }
                      this.timestep = this.options.timestep;
                    }
                  }
                  this.init();
                }
              }, {
                key: "init",
                value: function init() {
                  var options;
                  if (this.options.solver === "forceAtlas2Based") {
                    options = this.options.forceAtlas2Based;
                    this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);
                    this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
                    this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);
                  } else if (this.options.solver === "repulsion") {
                    options = this.options.repulsion;
                    this.nodesSolver = new Repulsion(this.body, this.physicsBody, options);
                    this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
                    this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
                  } else if (this.options.solver === "hierarchicalRepulsion") {
                    options = this.options.hierarchicalRepulsion;
                    this.nodesSolver = new HierarchicalRepulsion(this.body, this.physicsBody, options);
                    this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);
                    this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
                  } else {
                    options = this.options.barnesHut;
                    this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);
                    this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
                    this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
                  }
                  this.modelOptions = options;
                }
              }, {
                key: "initPhysics",
                value: function initPhysics() {
                  if (this.physicsEnabled === true && this.options.enabled === true) {
                    if (this.options.stabilization.enabled === true) {
                      this.stabilize();
                    } else {
                      this.stabilized = false;
                      this.ready = true;
                      this.body.emitter.emit("fit", {}, this.layoutFailed);
                      this.startSimulation();
                    }
                  } else {
                    this.ready = true;
                    this.body.emitter.emit("fit");
                  }
                }
              }, {
                key: "startSimulation",
                value: function startSimulation() {
                  if (this.physicsEnabled === true && this.options.enabled === true) {
                    this.stabilized = false;
                    this.adaptiveTimestep = false;
                    this.body.emitter.emit("_resizeNodes");
                    if (this.viewFunction === void 0) {
                      this.viewFunction = this.simulationStep.bind(this);
                      this.body.emitter.on("initRedraw", this.viewFunction);
                      this.body.emitter.emit("_startRendering");
                    }
                  } else {
                    this.body.emitter.emit("_redraw");
                  }
                }
              }, {
                key: "stopSimulation",
                value: function stopSimulation() {
                  var emit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                  this.stabilized = true;
                  if (emit === true) {
                    this._emitStabilized();
                  }
                  if (this.viewFunction !== void 0) {
                    this.body.emitter.off("initRedraw", this.viewFunction);
                    this.viewFunction = void 0;
                    if (emit === true) {
                      this.body.emitter.emit("_stopRendering");
                    }
                  }
                }
              }, {
                key: "simulationStep",
                value: function simulationStep() {
                  var startTime = Date.now();
                  this.physicsTick();
                  var physicsTime = Date.now() - startTime;
                  if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
                    this.physicsTick();
                    this.runDoubleSpeed = true;
                  }
                  if (this.stabilized === true) {
                    this.stopSimulation();
                  }
                }
              }, {
                key: "_emitStabilized",
                value: function _emitStabilized() {
                  var _this2 = this;
                  var amountOfIterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.stabilizationIterations;
                  if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
                    setTimeout(function() {
                      _this2.body.emitter.emit("stabilized", { iterations: amountOfIterations });
                      _this2.startedStabilization = false;
                      _this2.stabilizationIterations = 0;
                    }, 0);
                  }
                }
              }, {
                key: "physicsStep",
                value: function physicsStep() {
                  this.gravitySolver.solve();
                  this.nodesSolver.solve();
                  this.edgesSolver.solve();
                  this.moveNodes();
                }
              }, {
                key: "adjustTimeStep",
                value: function adjustTimeStep() {
                  var factor = 1.2;
                  if (this._evaluateStepQuality() === true) {
                    this.timestep = factor * this.timestep;
                  } else {
                    if (this.timestep / factor < this.options.timestep) {
                      this.timestep = this.options.timestep;
                    } else {
                      this.adaptiveCounter = -1;
                      this.timestep = Math.max(this.options.timestep, this.timestep / factor);
                    }
                  }
                }
              }, {
                key: "physicsTick",
                value: function physicsTick() {
                  this._startStabilizing();
                  if (this.stabilized === true)
                    return;
                  if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
                    var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;
                    if (doAdaptive) {
                      this.timestep = 2 * this.timestep;
                      this.physicsStep();
                      this.revert();
                      this.timestep = 0.5 * this.timestep;
                      this.physicsStep();
                      this.physicsStep();
                      this.adjustTimeStep();
                    } else {
                      this.physicsStep();
                    }
                    this.adaptiveCounter += 1;
                  } else {
                    this.timestep = this.options.timestep;
                    this.physicsStep();
                  }
                  if (this.stabilized === true)
                    this.revert();
                  this.stabilizationIterations++;
                }
              }, {
                key: "updatePhysicsData",
                value: function updatePhysicsData() {
                  this.physicsBody.forces = {};
                  this.physicsBody.physicsNodeIndices = [];
                  this.physicsBody.physicsEdgeIndices = [];
                  var nodes2 = this.body.nodes;
                  var edges2 = this.body.edges;
                  for (var nodeId in nodes2) {
                    if (nodes2.hasOwnProperty(nodeId)) {
                      if (nodes2[nodeId].options.physics === true) {
                        this.physicsBody.physicsNodeIndices.push(nodes2[nodeId].id);
                      }
                    }
                  }
                  for (var edgeId in edges2) {
                    if (edges2.hasOwnProperty(edgeId)) {
                      if (edges2[edgeId].options.physics === true) {
                        this.physicsBody.physicsEdgeIndices.push(edges2[edgeId].id);
                      }
                    }
                  }
                  for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
                    var _nodeId = this.physicsBody.physicsNodeIndices[i];
                    this.physicsBody.forces[_nodeId] = {
                      x: 0,
                      y: 0
                    };
                    if (this.physicsBody.velocities[_nodeId] === void 0) {
                      this.physicsBody.velocities[_nodeId] = { x: 0, y: 0 };
                    }
                  }
                  for (var _nodeId2 in this.physicsBody.velocities) {
                    if (nodes2[_nodeId2] === void 0) {
                      delete this.physicsBody.velocities[_nodeId2];
                    }
                  }
                }
              }, {
                key: "revert",
                value: function revert2() {
                  var nodeIds = (0, _keys2["default"])(this.previousStates);
                  var nodes2 = this.body.nodes;
                  var velocities = this.physicsBody.velocities;
                  this.referenceState = {};
                  for (var i = 0; i < nodeIds.length; i++) {
                    var nodeId = nodeIds[i];
                    if (nodes2[nodeId] !== void 0) {
                      if (nodes2[nodeId].options.physics === true) {
                        this.referenceState[nodeId] = {
                          positions: { x: nodes2[nodeId].x, y: nodes2[nodeId].y }
                        };
                        velocities[nodeId].x = this.previousStates[nodeId].vx;
                        velocities[nodeId].y = this.previousStates[nodeId].vy;
                        nodes2[nodeId].x = this.previousStates[nodeId].x;
                        nodes2[nodeId].y = this.previousStates[nodeId].y;
                      }
                    } else {
                      delete this.previousStates[nodeId];
                    }
                  }
                }
              }, {
                key: "_evaluateStepQuality",
                value: function _evaluateStepQuality() {
                  var dx = void 0, dy = void 0, dpos = void 0;
                  var nodes2 = this.body.nodes;
                  var reference = this.referenceState;
                  var posThreshold = 0.3;
                  for (var nodeId in this.referenceState) {
                    if (this.referenceState.hasOwnProperty(nodeId) && nodes2[nodeId] !== void 0) {
                      dx = nodes2[nodeId].x - reference[nodeId].positions.x;
                      dy = nodes2[nodeId].y - reference[nodeId].positions.y;
                      dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                      if (dpos > posThreshold) {
                        return false;
                      }
                    }
                  }
                  return true;
                }
              }, {
                key: "moveNodes",
                value: function moveNodes() {
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var maxNodeVelocity = 0;
                  var averageNodeVelocity = 0;
                  var velocityAdaptiveThreshold = 5;
                  for (var i = 0; i < nodeIndices.length; i++) {
                    var nodeId = nodeIndices[i];
                    var nodeVelocity = this._performStep(nodeId);
                    maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
                    averageNodeVelocity += nodeVelocity;
                  }
                  this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
                  this.stabilized = maxNodeVelocity < this.options.minVelocity;
                }
              }, {
                key: "calculateComponentVelocity",
                value: function calculateComponentVelocity(v, f, m) {
                  var df = this.modelOptions.damping * v;
                  var a = (f - df) / m;
                  v += a * this.timestep;
                  var maxV = this.options.maxVelocity || 1e9;
                  if (Math.abs(v) > maxV) {
                    v = v > 0 ? maxV : -maxV;
                  }
                  return v;
                }
              }, {
                key: "_performStep",
                value: function _performStep(nodeId) {
                  var node = this.body.nodes[nodeId];
                  var force = this.physicsBody.forces[nodeId];
                  var velocity = this.physicsBody.velocities[nodeId];
                  this.previousStates[nodeId] = {
                    x: node.x,
                    y: node.y,
                    vx: velocity.x,
                    vy: velocity.y
                  };
                  if (node.options.fixed.x === false) {
                    velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);
                    node.x += velocity.x * this.timestep;
                  } else {
                    force.x = 0;
                    velocity.x = 0;
                  }
                  if (node.options.fixed.y === false) {
                    velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);
                    node.y += velocity.y * this.timestep;
                  } else {
                    force.y = 0;
                    velocity.y = 0;
                  }
                  var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));
                  return totalVelocity;
                }
              }, {
                key: "_freezeNodes",
                value: function _freezeNodes() {
                  var nodes2 = this.body.nodes;
                  for (var id2 in nodes2) {
                    if (nodes2.hasOwnProperty(id2)) {
                      if (nodes2[id2].x && nodes2[id2].y) {
                        var fixed = nodes2[id2].options.fixed;
                        this.freezeCache[id2] = { x: fixed.x, y: fixed.y };
                        fixed.x = true;
                        fixed.y = true;
                      }
                    }
                  }
                }
              }, {
                key: "_restoreFrozenNodes",
                value: function _restoreFrozenNodes() {
                  var nodes2 = this.body.nodes;
                  for (var id2 in nodes2) {
                    if (nodes2.hasOwnProperty(id2)) {
                      if (this.freezeCache[id2] !== void 0) {
                        nodes2[id2].options.fixed.x = this.freezeCache[id2].x;
                        nodes2[id2].options.fixed.y = this.freezeCache[id2].y;
                      }
                    }
                  }
                  this.freezeCache = {};
                }
              }, {
                key: "stabilize",
                value: function stabilize() {
                  var _this3 = this;
                  var iterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.stabilization.iterations;
                  if (typeof iterations !== "number") {
                    iterations = this.options.stabilization.iterations;
                    console.log("The stabilize method needs a numeric amount of iterations. Switching to default: ", iterations);
                  }
                  if (this.physicsBody.physicsNodeIndices.length === 0) {
                    this.ready = true;
                    return;
                  }
                  this.adaptiveTimestep = this.options.adaptiveTimestep;
                  this.body.emitter.emit("_resizeNodes");
                  this.stopSimulation();
                  this.stabilized = false;
                  this.body.emitter.emit("_blockRedraw");
                  this.targetIterations = iterations;
                  if (this.options.stabilization.onlyDynamicEdges === true) {
                    this._freezeNodes();
                  }
                  this.stabilizationIterations = 0;
                  setTimeout(function() {
                    return _this3._stabilizationBatch();
                  }, 0);
                }
              }, {
                key: "_startStabilizing",
                value: function _startStabilizing() {
                  if (this.startedStabilization === true)
                    return false;
                  this.body.emitter.emit("startStabilizing");
                  this.startedStabilization = true;
                  return true;
                }
              }, {
                key: "_stabilizationBatch",
                value: function _stabilizationBatch() {
                  var _this4 = this;
                  var running = function running2() {
                    return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;
                  };
                  var sendProgress = function sendProgress2() {
                    _this4.body.emitter.emit("stabilizationProgress", {
                      iterations: _this4.stabilizationIterations,
                      total: _this4.targetIterations
                    });
                  };
                  if (this._startStabilizing()) {
                    sendProgress();
                  }
                  var count = 0;
                  while (running() && count < this.options.stabilization.updateInterval) {
                    this.physicsTick();
                    count++;
                  }
                  sendProgress();
                  if (running()) {
                    setTimeout(this._stabilizationBatch.bind(this), 0);
                  } else {
                    this._finalizeStabilization();
                  }
                }
              }, {
                key: "_finalizeStabilization",
                value: function _finalizeStabilization() {
                  this.body.emitter.emit("_allowRedraw");
                  if (this.options.stabilization.fit === true) {
                    this.body.emitter.emit("fit");
                  }
                  if (this.options.stabilization.onlyDynamicEdges === true) {
                    this._restoreFrozenNodes();
                  }
                  this.body.emitter.emit("stabilizationIterationsDone");
                  this.body.emitter.emit("_requestRedraw");
                  if (this.stabilized === true) {
                    this._emitStabilized();
                  } else {
                    this.startSimulation();
                  }
                  this.ready = true;
                }
              }, {
                key: "_drawForces",
                value: function _drawForces(ctx) {
                  for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
                    var index = this.physicsBody.physicsNodeIndices[i];
                    var node = this.body.nodes[index];
                    var force = this.physicsBody.forces[index];
                    var factor = 20;
                    var colorFactor = 0.03;
                    var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));
                    var size = Math.min(Math.max(5, forceSize), 15);
                    var arrowSize = 3 * size;
                    var color = util.HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);
                    var point = {
                      x: node.x + factor * force.x,
                      y: node.y + factor * force.y
                    };
                    ctx.lineWidth = size;
                    ctx.strokeStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(point.x, point.y);
                    ctx.stroke();
                    var angle = Math.atan2(force.y, force.x);
                    ctx.fillStyle = color;
                    EndPoints.draw(ctx, {
                      type: "arrow",
                      point,
                      angle,
                      length: arrowSize
                    });
                    ctx.fill();
                  }
                }
              }]);
              return PhysicsEngine2;
            }();
            exports2["default"] = PhysicsEngine;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var RepulsionSolver = function() {
              function RepulsionSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, RepulsionSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(RepulsionSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
              }, {
                key: "solve",
                value: function solve() {
                  var dx, dy, distance, fx, fy, repulsingForce, node1, node2;
                  var nodes2 = this.body.nodes;
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var forces = this.physicsBody.forces;
                  var nodeDistance = this.options.nodeDistance;
                  var a = -2 / 3 / nodeDistance;
                  var b = 4 / 3;
                  for (var i = 0; i < nodeIndices.length - 1; i++) {
                    node1 = nodes2[nodeIndices[i]];
                    for (var j = i + 1; j < nodeIndices.length; j++) {
                      node2 = nodes2[nodeIndices[j]];
                      dx = node2.x - node1.x;
                      dy = node2.y - node1.y;
                      distance = Math.sqrt(dx * dx + dy * dy);
                      if (distance === 0) {
                        distance = 0.1 * Math.random();
                        dx = distance;
                      }
                      if (distance < 2 * nodeDistance) {
                        if (distance < 0.5 * nodeDistance) {
                          repulsingForce = 1;
                        } else {
                          repulsingForce = a * distance + b;
                        }
                        repulsingForce = repulsingForce / distance;
                        fx = dx * repulsingForce;
                        fy = dy * repulsingForce;
                        forces[node1.id].x -= fx;
                        forces[node1.id].y -= fy;
                        forces[node2.id].x += fx;
                        forces[node2.id].y += fy;
                      }
                    }
                  }
                }
              }]);
              return RepulsionSolver2;
            }();
            exports2["default"] = RepulsionSolver;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var HierarchicalRepulsionSolver = function() {
              function HierarchicalRepulsionSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, HierarchicalRepulsionSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(HierarchicalRepulsionSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
              }, {
                key: "solve",
                value: function solve() {
                  var dx, dy, distance, fx, fy, repulsingForce, node1, node2, i, j;
                  var nodes2 = this.body.nodes;
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var forces = this.physicsBody.forces;
                  var nodeDistance = this.options.nodeDistance;
                  for (i = 0; i < nodeIndices.length - 1; i++) {
                    node1 = nodes2[nodeIndices[i]];
                    for (j = i + 1; j < nodeIndices.length; j++) {
                      node2 = nodes2[nodeIndices[j]];
                      if (node1.level === node2.level) {
                        dx = node2.x - node1.x;
                        dy = node2.y - node1.y;
                        distance = Math.sqrt(dx * dx + dy * dy);
                        var steepness = 0.05;
                        if (distance < nodeDistance) {
                          repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * nodeDistance, 2);
                        } else {
                          repulsingForce = 0;
                        }
                        if (distance === 0) {
                          distance = 0.01;
                        } else {
                          repulsingForce = repulsingForce / distance;
                        }
                        fx = dx * repulsingForce;
                        fy = dy * repulsingForce;
                        forces[node1.id].x -= fx;
                        forces[node1.id].y -= fy;
                        forces[node2.id].x += fx;
                        forces[node2.id].y += fy;
                      }
                    }
                  }
                }
              }]);
              return HierarchicalRepulsionSolver2;
            }();
            exports2["default"] = HierarchicalRepulsionSolver;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var SpringSolver = function() {
              function SpringSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, SpringSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(SpringSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
              }, {
                key: "solve",
                value: function solve() {
                  var edgeLength = void 0, edge = void 0;
                  var edgeIndices = this.physicsBody.physicsEdgeIndices;
                  var edges2 = this.body.edges;
                  var node1 = void 0, node2 = void 0, node3 = void 0;
                  for (var i = 0; i < edgeIndices.length; i++) {
                    edge = edges2[edgeIndices[i]];
                    if (edge.connected === true && edge.toId !== edge.fromId) {
                      if (this.body.nodes[edge.toId] !== void 0 && this.body.nodes[edge.fromId] !== void 0) {
                        if (edge.edgeType.via !== void 0) {
                          edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;
                          node1 = edge.to;
                          node2 = edge.edgeType.via;
                          node3 = edge.from;
                          this._calculateSpringForce(node1, node2, 0.5 * edgeLength);
                          this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
                        } else {
                          edgeLength = edge.options.length === void 0 ? this.options.springLength * 1.5 : edge.options.length;
                          this._calculateSpringForce(edge.from, edge.to, edgeLength);
                        }
                      }
                    }
                  }
                }
              }, {
                key: "_calculateSpringForce",
                value: function _calculateSpringForce(node1, node2, edgeLength) {
                  var dx = node1.x - node2.x;
                  var dy = node1.y - node2.y;
                  var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);
                  var springForce = this.options.springConstant * (edgeLength - distance) / distance;
                  var fx = dx * springForce;
                  var fy = dy * springForce;
                  if (this.physicsBody.forces[node1.id] !== void 0) {
                    this.physicsBody.forces[node1.id].x += fx;
                    this.physicsBody.forces[node1.id].y += fy;
                  }
                  if (this.physicsBody.forces[node2.id] !== void 0) {
                    this.physicsBody.forces[node2.id].x -= fx;
                    this.physicsBody.forces[node2.id].y -= fy;
                  }
                }
              }]);
              return SpringSolver2;
            }();
            exports2["default"] = SpringSolver;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var HierarchicalSpringSolver = function() {
              function HierarchicalSpringSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, HierarchicalSpringSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(HierarchicalSpringSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
              }, {
                key: "solve",
                value: function solve() {
                  var edgeLength, edge;
                  var dx, dy, fx, fy, springForce, distance;
                  var edges2 = this.body.edges;
                  var factor = 0.5;
                  var edgeIndices = this.physicsBody.physicsEdgeIndices;
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var forces = this.physicsBody.forces;
                  for (var i = 0; i < nodeIndices.length; i++) {
                    var nodeId = nodeIndices[i];
                    forces[nodeId].springFx = 0;
                    forces[nodeId].springFy = 0;
                  }
                  for (var _i = 0; _i < edgeIndices.length; _i++) {
                    edge = edges2[edgeIndices[_i]];
                    if (edge.connected === true) {
                      edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;
                      dx = edge.from.x - edge.to.x;
                      dy = edge.from.y - edge.to.y;
                      distance = Math.sqrt(dx * dx + dy * dy);
                      distance = distance === 0 ? 0.01 : distance;
                      springForce = this.options.springConstant * (edgeLength - distance) / distance;
                      fx = dx * springForce;
                      fy = dy * springForce;
                      if (edge.to.level != edge.from.level) {
                        if (forces[edge.toId] !== void 0) {
                          forces[edge.toId].springFx -= fx;
                          forces[edge.toId].springFy -= fy;
                        }
                        if (forces[edge.fromId] !== void 0) {
                          forces[edge.fromId].springFx += fx;
                          forces[edge.fromId].springFy += fy;
                        }
                      } else {
                        if (forces[edge.toId] !== void 0) {
                          forces[edge.toId].x -= factor * fx;
                          forces[edge.toId].y -= factor * fy;
                        }
                        if (forces[edge.fromId] !== void 0) {
                          forces[edge.fromId].x += factor * fx;
                          forces[edge.fromId].y += factor * fy;
                        }
                      }
                    }
                  }
                  springForce = 1;
                  var springFx, springFy;
                  for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
                    var _nodeId = nodeIndices[_i2];
                    springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
                    springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));
                    forces[_nodeId].x += springFx;
                    forces[_nodeId].y += springFy;
                  }
                  var totalFx = 0;
                  var totalFy = 0;
                  for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
                    var _nodeId2 = nodeIndices[_i3];
                    totalFx += forces[_nodeId2].x;
                    totalFy += forces[_nodeId2].y;
                  }
                  var correctionFx = totalFx / nodeIndices.length;
                  var correctionFy = totalFy / nodeIndices.length;
                  for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
                    var _nodeId3 = nodeIndices[_i4];
                    forces[_nodeId3].x -= correctionFx;
                    forces[_nodeId3].y -= correctionFy;
                  }
                }
              }]);
              return HierarchicalSpringSolver2;
            }();
            exports2["default"] = HierarchicalSpringSolver;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _BarnesHutSolver2 = __webpack_require__(81);
            var _BarnesHutSolver3 = _interopRequireDefault(_BarnesHutSolver2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var ForceAtlas2BasedRepulsionSolver = function(_BarnesHutSolver) {
              (0, _inherits3["default"])(ForceAtlas2BasedRepulsionSolver2, _BarnesHutSolver);
              function ForceAtlas2BasedRepulsionSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, ForceAtlas2BasedRepulsionSolver2);
                return (0, _possibleConstructorReturn3["default"])(this, (ForceAtlas2BasedRepulsionSolver2.__proto__ || (0, _getPrototypeOf2["default"])(ForceAtlas2BasedRepulsionSolver2)).call(this, body, physicsBody, options));
              }
              (0, _createClass3["default"])(ForceAtlas2BasedRepulsionSolver2, [{
                key: "_calculateForces",
                value: function _calculateForces(distance, dx, dy, node, parentBranch) {
                  if (distance === 0) {
                    distance = 0.1 * Math.random();
                    dx = distance;
                  }
                  if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
                    distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
                  }
                  var degree = node.edges.length + 1;
                  var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
                  var fx = dx * gravityForce;
                  var fy = dy * gravityForce;
                  this.physicsBody.forces[node.id].x += fx;
                  this.physicsBody.forces[node.id].y += fy;
                }
              }]);
              return ForceAtlas2BasedRepulsionSolver2;
            }(_BarnesHutSolver3["default"]);
            exports2["default"] = ForceAtlas2BasedRepulsionSolver;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CentralGravitySolver2 = __webpack_require__(82);
            var _CentralGravitySolver3 = _interopRequireDefault(_CentralGravitySolver2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var ForceAtlas2BasedCentralGravitySolver = function(_CentralGravitySolver) {
              (0, _inherits3["default"])(ForceAtlas2BasedCentralGravitySolver2, _CentralGravitySolver);
              function ForceAtlas2BasedCentralGravitySolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, ForceAtlas2BasedCentralGravitySolver2);
                return (0, _possibleConstructorReturn3["default"])(this, (ForceAtlas2BasedCentralGravitySolver2.__proto__ || (0, _getPrototypeOf2["default"])(ForceAtlas2BasedCentralGravitySolver2)).call(this, body, physicsBody, options));
              }
              (0, _createClass3["default"])(ForceAtlas2BasedCentralGravitySolver2, [{
                key: "_calculateForces",
                value: function _calculateForces(distance, dx, dy, forces, node) {
                  if (distance > 0) {
                    var degree = node.edges.length + 1;
                    var gravityForce = this.options.centralGravity * degree * node.options.mass;
                    forces[node.id].x = dx * gravityForce;
                    forces[node.id].y = dy * gravityForce;
                  }
                }
              }]);
              return ForceAtlas2BasedCentralGravitySolver2;
            }(_CentralGravitySolver3["default"]);
            exports2["default"] = ForceAtlas2BasedCentralGravitySolver;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _keys = __webpack_require__(9);
            var _keys2 = _interopRequireDefault(_keys);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var NetworkUtil = __webpack_require__(57)["default"];
            var Cluster = __webpack_require__(179)["default"];
            var Edge = __webpack_require__(55)["default"];
            var Node = __webpack_require__(34)["default"];
            var ClusterEngine = function() {
              function ClusterEngine2(body) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, ClusterEngine2);
                this.body = body;
                this.clusteredNodes = {};
                this.clusteredEdges = {};
                this.options = {};
                this.defaultOptions = {};
                util.extend(this.options, this.defaultOptions);
                this.body.emitter.on("_resetData", function() {
                  _this.clusteredNodes = {};
                  _this.clusteredEdges = {};
                });
              }
              (0, _createClass3["default"])(ClusterEngine2, [{
                key: "clusterByHubsize",
                value: function clusterByHubsize(hubsize, options) {
                  if (hubsize === void 0) {
                    hubsize = this._getHubSize();
                  } else if ((typeof hubsize === "undefined" ? "undefined" : (0, _typeof3["default"])(hubsize)) === "object") {
                    options = this._checkOptions(hubsize);
                    hubsize = this._getHubSize();
                  }
                  var nodesToCluster = [];
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var node = this.body.nodes[this.body.nodeIndices[i]];
                    if (node.edges.length >= hubsize) {
                      nodesToCluster.push(node.id);
                    }
                  }
                  for (var _i = 0; _i < nodesToCluster.length; _i++) {
                    this.clusterByConnection(nodesToCluster[_i], options, true);
                  }
                  this.body.emitter.emit("_dataChanged");
                }
              }, {
                key: "cluster",
                value: function cluster() {
                  var _this2 = this;
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (options.joinCondition === void 0) {
                    throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
                  }
                  options = this._checkOptions(options);
                  var childNodesObj = {};
                  var childEdgesObj = {};
                  util.forEach(this.body.nodes, function(node, nodeId) {
                    if (node.options && options.joinCondition(node.options) === true) {
                      childNodesObj[nodeId] = node;
                      util.forEach(node.edges, function(edge) {
                        if (_this2.clusteredEdges[edge.id] === void 0) {
                          childEdgesObj[edge.id] = edge;
                        }
                      });
                    }
                  });
                  this._cluster(childNodesObj, childEdgesObj, options, refreshData);
                }
              }, {
                key: "clusterByEdgeCount",
                value: function clusterByEdgeCount(edgeCount, options) {
                  var _this3 = this;
                  var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                  options = this._checkOptions(options);
                  var clusters = [];
                  var usedNodes = {};
                  var edge = void 0, edges2 = void 0, relevantEdgeCount = void 0;
                  var _loop = function _loop2(i2) {
                    var childNodesObj = {};
                    var childEdgesObj = {};
                    var nodeId = _this3.body.nodeIndices[i2];
                    var node = _this3.body.nodes[nodeId];
                    if (usedNodes[nodeId] === void 0) {
                      relevantEdgeCount = 0;
                      edges2 = [];
                      for (var j = 0; j < node.edges.length; j++) {
                        edge = node.edges[j];
                        if (_this3.clusteredEdges[edge.id] === void 0) {
                          if (edge.toId !== edge.fromId) {
                            relevantEdgeCount++;
                          }
                          edges2.push(edge);
                        }
                      }
                      if (relevantEdgeCount === edgeCount) {
                        checkJoinCondition = function checkJoinCondition2(node2) {
                          if (options.joinCondition === void 0 || options.joinCondition === null) {
                            return true;
                          }
                          var clonedOptions = NetworkUtil.cloneOptions(node2);
                          return options.joinCondition(clonedOptions);
                        };
                        var gatheringSuccessful = true;
                        for (var _j = 0; _j < edges2.length; _j++) {
                          edge = edges2[_j];
                          var childNodeId = _this3._getConnectedId(edge, nodeId);
                          if (checkJoinCondition(node)) {
                            childEdgesObj[edge.id] = edge;
                            childNodesObj[nodeId] = node;
                            childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];
                            usedNodes[nodeId] = true;
                          } else {
                            gatheringSuccessful = false;
                            break;
                          }
                        }
                        if ((0, _keys2["default"])(childNodesObj).length > 0 && (0, _keys2["default"])(childEdgesObj).length > 0 && gatheringSuccessful === true) {
                          findClusterData = function findClusterData2() {
                            for (var n = 0; n < clusters.length; ++n) {
                              for (var m2 in childNodesObj) {
                                if (clusters[n].nodes[m2] !== void 0) {
                                  return clusters[n];
                                }
                              }
                            }
                            return void 0;
                          };
                          foundCluster = findClusterData();
                          if (foundCluster !== void 0) {
                            for (var m in childNodesObj) {
                              if (foundCluster.nodes[m] === void 0) {
                                foundCluster.nodes[m] = childNodesObj[m];
                              }
                            }
                            for (var _m in childEdgesObj) {
                              if (foundCluster.edges[_m] === void 0) {
                                foundCluster.edges[_m] = childEdgesObj[_m];
                              }
                            }
                          } else {
                            clusters.push({
                              nodes: childNodesObj,
                              edges: childEdgesObj
                            });
                          }
                        }
                      }
                    }
                  };
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var checkJoinCondition;
                    var findClusterData;
                    var foundCluster;
                    _loop(i);
                  }
                  for (var i = 0; i < clusters.length; i++) {
                    this._cluster(clusters[i].nodes, clusters[i].edges, options, false);
                  }
                  if (refreshData === true) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
              }, {
                key: "clusterOutliers",
                value: function clusterOutliers(options) {
                  var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  this.clusterByEdgeCount(1, options, refreshData);
                }
              }, {
                key: "clusterBridges",
                value: function clusterBridges(options) {
                  var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  this.clusterByEdgeCount(2, options, refreshData);
                }
              }, {
                key: "clusterByConnection",
                value: function clusterByConnection(nodeId, options) {
                  var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                  if (nodeId === void 0) {
                    throw new Error("No nodeId supplied to clusterByConnection!");
                  }
                  if (this.body.nodes[nodeId] === void 0) {
                    throw new Error("The nodeId given to clusterByConnection does not exist!");
                  }
                  var node = this.body.nodes[nodeId];
                  options = this._checkOptions(options, node);
                  if (options.clusterNodeProperties.x === void 0) {
                    options.clusterNodeProperties.x = node.x;
                  }
                  if (options.clusterNodeProperties.y === void 0) {
                    options.clusterNodeProperties.y = node.y;
                  }
                  if (options.clusterNodeProperties.fixed === void 0) {
                    options.clusterNodeProperties.fixed = {};
                    options.clusterNodeProperties.fixed.x = node.options.fixed.x;
                    options.clusterNodeProperties.fixed.y = node.options.fixed.y;
                  }
                  var childNodesObj = {};
                  var childEdgesObj = {};
                  var parentNodeId = node.id;
                  var parentClonedOptions = NetworkUtil.cloneOptions(node);
                  childNodesObj[parentNodeId] = node;
                  for (var i = 0; i < node.edges.length; i++) {
                    var edge = node.edges[i];
                    if (this.clusteredEdges[edge.id] === void 0) {
                      var childNodeId = this._getConnectedId(edge, parentNodeId);
                      if (this.clusteredNodes[childNodeId] === void 0) {
                        if (childNodeId !== parentNodeId) {
                          if (options.joinCondition === void 0) {
                            childEdgesObj[edge.id] = edge;
                            childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                          } else {
                            var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);
                            if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                              childEdgesObj[edge.id] = edge;
                              childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                            }
                          }
                        } else {
                          childEdgesObj[edge.id] = edge;
                        }
                      }
                    }
                  }
                  var childNodeIDs = (0, _keys2["default"])(childNodesObj).map(function(childNode2) {
                    return childNodesObj[childNode2].id;
                  });
                  for (childNode in childNodesObj) {
                    if (!childNodesObj.hasOwnProperty(childNode))
                      continue;
                    var childNode = childNodesObj[childNode];
                    for (var y = 0; y < childNode.edges.length; y++) {
                      var childEdge = childNode.edges[y];
                      if (childNodeIDs.indexOf(this._getConnectedId(childEdge, childNode.id)) > -1) {
                        childEdgesObj[childEdge.id] = childEdge;
                      }
                    }
                  }
                  this._cluster(childNodesObj, childEdgesObj, options, refreshData);
                }
              }, {
                key: "_createClusterEdges",
                value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
                  var edge = void 0, childNodeId = void 0, childNode = void 0, toId = void 0, fromId = void 0, otherNodeId = void 0;
                  var childKeys = (0, _keys2["default"])(childNodesObj);
                  var createEdges = [];
                  for (var i = 0; i < childKeys.length; i++) {
                    childNodeId = childKeys[i];
                    childNode = childNodesObj[childNodeId];
                    for (var j = 0; j < childNode.edges.length; j++) {
                      edge = childNode.edges[j];
                      if (this.clusteredEdges[edge.id] === void 0) {
                        if (edge.toId == edge.fromId) {
                          childEdgesObj[edge.id] = edge;
                        } else {
                          if (edge.toId == childNodeId) {
                            toId = clusterNodeProperties.id;
                            fromId = edge.fromId;
                            otherNodeId = fromId;
                          } else {
                            toId = edge.toId;
                            fromId = clusterNodeProperties.id;
                            otherNodeId = toId;
                          }
                        }
                        if (childNodesObj[otherNodeId] === void 0) {
                          createEdges.push({
                            edge,
                            fromId,
                            toId
                          });
                        }
                      }
                    }
                  }
                  var newEdges = [];
                  var getNewEdge = function getNewEdge2(createdEdge2) {
                    for (var _j2 = 0; _j2 < newEdges.length; _j2++) {
                      var newEdge2 = newEdges[_j2];
                      var matchToDirection = createdEdge2.fromId === newEdge2.fromId && createdEdge2.toId === newEdge2.toId;
                      var matchFromDirection = createdEdge2.fromId === newEdge2.toId && createdEdge2.toId === newEdge2.fromId;
                      if (matchToDirection || matchFromDirection) {
                        return newEdge2;
                      }
                    }
                    return null;
                  };
                  for (var _j3 = 0; _j3 < createEdges.length; _j3++) {
                    var createdEdge = createEdges[_j3];
                    var _edge = createdEdge.edge;
                    var newEdge = getNewEdge(createdEdge);
                    if (newEdge === null) {
                      newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);
                      newEdges.push(newEdge);
                    } else {
                      newEdge.clusteringEdgeReplacingIds.push(_edge.id);
                    }
                    this.body.edges[_edge.id].edgeReplacedById = newEdge.id;
                    this._backupEdgeOptions(_edge);
                    _edge.setOptions({
                      physics: false
                    });
                  }
                }
              }, {
                key: "_checkOptions",
                value: function _checkOptions() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  if (options.clusterEdgeProperties === void 0) {
                    options.clusterEdgeProperties = {};
                  }
                  if (options.clusterNodeProperties === void 0) {
                    options.clusterNodeProperties = {};
                  }
                  return options;
                }
              }, {
                key: "_cluster",
                value: function _cluster(childNodesObj, childEdgesObj, options) {
                  var refreshData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                  var tmpNodesToRemove = [];
                  for (var _nodeId in childNodesObj) {
                    if (childNodesObj.hasOwnProperty(_nodeId)) {
                      if (this.clusteredNodes[_nodeId] !== void 0) {
                        tmpNodesToRemove.push(_nodeId);
                      }
                    }
                  }
                  for (var n = 0; n < tmpNodesToRemove.length; ++n) {
                    delete childNodesObj[tmpNodesToRemove[n]];
                  }
                  if ((0, _keys2["default"])(childNodesObj).length == 0) {
                    return;
                  }
                  if ((0, _keys2["default"])(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {
                    return;
                  }
                  var clusterNodeProperties = util.deepExtend({}, options.clusterNodeProperties);
                  if (options.processProperties !== void 0) {
                    var childNodesOptions = [];
                    for (var _nodeId2 in childNodesObj) {
                      if (childNodesObj.hasOwnProperty(_nodeId2)) {
                        var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId2]);
                        childNodesOptions.push(clonedOptions);
                      }
                    }
                    var childEdgesOptions = [];
                    for (var edgeId in childEdgesObj) {
                      if (childEdgesObj.hasOwnProperty(edgeId)) {
                        if (edgeId.substr(0, 12) !== "clusterEdge:") {
                          var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], "edge");
                          childEdgesOptions.push(_clonedOptions);
                        }
                      }
                    }
                    clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);
                    if (!clusterNodeProperties) {
                      throw new Error("The processProperties function does not return properties!");
                    }
                  }
                  if (clusterNodeProperties.id === void 0) {
                    clusterNodeProperties.id = "cluster:" + util.randomUUID();
                  }
                  var clusterId = clusterNodeProperties.id;
                  if (clusterNodeProperties.label === void 0) {
                    clusterNodeProperties.label = "cluster";
                  }
                  var pos = void 0;
                  if (clusterNodeProperties.x === void 0) {
                    pos = this._getClusterPosition(childNodesObj);
                    clusterNodeProperties.x = pos.x;
                  }
                  if (clusterNodeProperties.y === void 0) {
                    if (pos === void 0) {
                      pos = this._getClusterPosition(childNodesObj);
                    }
                    clusterNodeProperties.y = pos.y;
                  }
                  clusterNodeProperties.id = clusterId;
                  var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);
                  clusterNode.containedNodes = childNodesObj;
                  clusterNode.containedEdges = childEdgesObj;
                  clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;
                  this.body.nodes[clusterNodeProperties.id] = clusterNode;
                  this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);
                  clusterNodeProperties.id = void 0;
                  if (refreshData === true) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
              }, {
                key: "_backupEdgeOptions",
                value: function _backupEdgeOptions(edge) {
                  if (this.clusteredEdges[edge.id] === void 0) {
                    this.clusteredEdges[edge.id] = {
                      physics: edge.options.physics
                    };
                  }
                }
              }, {
                key: "_restoreEdge",
                value: function _restoreEdge(edge) {
                  var originalOptions = this.clusteredEdges[edge.id];
                  if (originalOptions !== void 0) {
                    edge.setOptions({
                      physics: originalOptions.physics
                    });
                    delete this.clusteredEdges[edge.id];
                  }
                }
              }, {
                key: "isCluster",
                value: function isCluster(nodeId) {
                  if (this.body.nodes[nodeId] !== void 0) {
                    return this.body.nodes[nodeId].isCluster === true;
                  } else {
                    console.log("Node does not exist.");
                    return false;
                  }
                }
              }, {
                key: "_getClusterPosition",
                value: function _getClusterPosition(childNodesObj) {
                  var childKeys = (0, _keys2["default"])(childNodesObj);
                  var minX = childNodesObj[childKeys[0]].x;
                  var maxX = childNodesObj[childKeys[0]].x;
                  var minY = childNodesObj[childKeys[0]].y;
                  var maxY = childNodesObj[childKeys[0]].y;
                  var node = void 0;
                  for (var i = 1; i < childKeys.length; i++) {
                    node = childNodesObj[childKeys[i]];
                    minX = node.x < minX ? node.x : minX;
                    maxX = node.x > maxX ? node.x : maxX;
                    minY = node.y < minY ? node.y : minY;
                    maxY = node.y > maxY ? node.y : maxY;
                  }
                  return {
                    x: 0.5 * (minX + maxX),
                    y: 0.5 * (minY + maxY)
                  };
                }
              }, {
                key: "openCluster",
                value: function openCluster(clusterNodeId, options) {
                  var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                  if (clusterNodeId === void 0) {
                    throw new Error("No clusterNodeId supplied to openCluster.");
                  }
                  var clusterNode = this.body.nodes[clusterNodeId];
                  if (clusterNode === void 0) {
                    throw new Error("The clusterNodeId supplied to openCluster does not exist.");
                  }
                  if (clusterNode.isCluster !== true || clusterNode.containedNodes === void 0 || clusterNode.containedEdges === void 0) {
                    throw new Error("The node:" + clusterNodeId + " is not a valid cluster.");
                  }
                  var stack = this.findNode(clusterNodeId);
                  var parentIndex = stack.indexOf(clusterNodeId) - 1;
                  if (parentIndex >= 0) {
                    var parentClusterNodeId = stack[parentIndex];
                    var parentClusterNode = this.body.nodes[parentClusterNodeId];
                    parentClusterNode._openChildCluster(clusterNodeId);
                    delete this.body.nodes[clusterNodeId];
                    if (refreshData === true) {
                      this.body.emitter.emit("_dataChanged");
                    }
                    return;
                  }
                  var containedNodes = clusterNode.containedNodes;
                  var containedEdges = clusterNode.containedEdges;
                  if (options !== void 0 && options.releaseFunction !== void 0 && typeof options.releaseFunction === "function") {
                    var positions = {};
                    var clusterPosition = {
                      x: clusterNode.x,
                      y: clusterNode.y
                    };
                    for (var _nodeId3 in containedNodes) {
                      if (containedNodes.hasOwnProperty(_nodeId3)) {
                        var containedNode = this.body.nodes[_nodeId3];
                        positions[_nodeId3] = {
                          x: containedNode.x,
                          y: containedNode.y
                        };
                      }
                    }
                    var newPositions = options.releaseFunction(clusterPosition, positions);
                    for (var _nodeId4 in containedNodes) {
                      if (containedNodes.hasOwnProperty(_nodeId4)) {
                        var _containedNode = this.body.nodes[_nodeId4];
                        if (newPositions[_nodeId4] !== void 0) {
                          _containedNode.x = newPositions[_nodeId4].x === void 0 ? clusterNode.x : newPositions[_nodeId4].x;
                          _containedNode.y = newPositions[_nodeId4].y === void 0 ? clusterNode.y : newPositions[_nodeId4].y;
                        }
                      }
                    }
                  } else {
                    util.forEach(containedNodes, function(containedNode2) {
                      if (containedNode2.options.fixed.x === false) {
                        containedNode2.x = clusterNode.x;
                      }
                      if (containedNode2.options.fixed.y === false) {
                        containedNode2.y = clusterNode.y;
                      }
                    });
                  }
                  for (var _nodeId5 in containedNodes) {
                    if (containedNodes.hasOwnProperty(_nodeId5)) {
                      var _containedNode2 = this.body.nodes[_nodeId5];
                      _containedNode2.vx = clusterNode.vx;
                      _containedNode2.vy = clusterNode.vy;
                      _containedNode2.setOptions({
                        physics: true
                      });
                      delete this.clusteredNodes[_nodeId5];
                    }
                  }
                  var edgesToBeDeleted = [];
                  for (var i = 0; i < clusterNode.edges.length; i++) {
                    edgesToBeDeleted.push(clusterNode.edges[i]);
                  }
                  for (var _i2 = 0; _i2 < edgesToBeDeleted.length; _i2++) {
                    var edge = edgesToBeDeleted[_i2];
                    var otherNodeId = this._getConnectedId(edge, clusterNodeId);
                    var otherNode = this.clusteredNodes[otherNodeId];
                    for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {
                      var transferId = edge.clusteringEdgeReplacingIds[j];
                      var transferEdge = this.body.edges[transferId];
                      if (transferEdge === void 0)
                        continue;
                      if (otherNode !== void 0) {
                        var otherCluster = this.body.nodes[otherNode.clusterId];
                        otherCluster.containedEdges[transferEdge.id] = transferEdge;
                        delete containedEdges[transferEdge.id];
                        var fromId = transferEdge.fromId;
                        var toId = transferEdge.toId;
                        if (transferEdge.toId == otherNodeId) {
                          toId = otherNode.clusterId;
                        } else {
                          fromId = otherNode.clusterId;
                        }
                        this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {
                          hidden: false,
                          physics: true
                        });
                      } else {
                        this._restoreEdge(transferEdge);
                      }
                    }
                    edge.remove();
                  }
                  for (var edgeId in containedEdges) {
                    if (containedEdges.hasOwnProperty(edgeId)) {
                      this._restoreEdge(containedEdges[edgeId]);
                    }
                  }
                  delete this.body.nodes[clusterNodeId];
                  if (refreshData === true) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
              }, {
                key: "getNodesInCluster",
                value: function getNodesInCluster(clusterId) {
                  var nodesArray = [];
                  if (this.isCluster(clusterId) === true) {
                    var containedNodes = this.body.nodes[clusterId].containedNodes;
                    for (var _nodeId6 in containedNodes) {
                      if (containedNodes.hasOwnProperty(_nodeId6)) {
                        nodesArray.push(this.body.nodes[_nodeId6].id);
                      }
                    }
                  }
                  return nodesArray;
                }
              }, {
                key: "findNode",
                value: function findNode(nodeId) {
                  var stack = [];
                  var max = 100;
                  var counter = 0;
                  var node = void 0;
                  while (this.clusteredNodes[nodeId] !== void 0 && counter < max) {
                    node = this.body.nodes[nodeId];
                    if (node === void 0)
                      return [];
                    stack.push(node.id);
                    nodeId = this.clusteredNodes[nodeId].clusterId;
                    counter++;
                  }
                  node = this.body.nodes[nodeId];
                  if (node === void 0)
                    return [];
                  stack.push(node.id);
                  stack.reverse();
                  return stack;
                }
              }, {
                key: "updateClusteredNode",
                value: function updateClusteredNode(clusteredNodeId, newOptions) {
                  if (clusteredNodeId === void 0) {
                    throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
                  }
                  if (newOptions === void 0) {
                    throw new Error("No newOptions supplied to updateClusteredNode.");
                  }
                  if (this.body.nodes[clusteredNodeId] === void 0) {
                    throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
                  }
                  this.body.nodes[clusteredNodeId].setOptions(newOptions);
                  this.body.emitter.emit("_dataChanged");
                }
              }, {
                key: "updateEdge",
                value: function updateEdge(startEdgeId, newOptions) {
                  if (startEdgeId === void 0) {
                    throw new Error("No startEdgeId supplied to updateEdge.");
                  }
                  if (newOptions === void 0) {
                    throw new Error("No newOptions supplied to updateEdge.");
                  }
                  if (this.body.edges[startEdgeId] === void 0) {
                    throw new Error("The startEdgeId supplied to updateEdge does not exist.");
                  }
                  var allEdgeIds = this.getClusteredEdges(startEdgeId);
                  for (var i = 0; i < allEdgeIds.length; i++) {
                    var edge = this.body.edges[allEdgeIds[i]];
                    edge.setOptions(newOptions);
                  }
                  this.body.emitter.emit("_dataChanged");
                }
              }, {
                key: "getClusteredEdges",
                value: function getClusteredEdges(edgeId) {
                  var stack = [];
                  var max = 100;
                  var counter = 0;
                  while (edgeId !== void 0 && this.body.edges[edgeId] !== void 0 && counter < max) {
                    stack.push(this.body.edges[edgeId].id);
                    edgeId = this.body.edges[edgeId].edgeReplacedById;
                    counter++;
                  }
                  stack.reverse();
                  return stack;
                }
              }, {
                key: "getBaseEdge",
                value: function getBaseEdge(clusteredEdgeId) {
                  return this.getBaseEdges(clusteredEdgeId)[0];
                }
              }, {
                key: "getBaseEdges",
                value: function getBaseEdges(clusteredEdgeId) {
                  var IdsToHandle = [clusteredEdgeId];
                  var doneIds = [];
                  var foundIds = [];
                  var max = 100;
                  var counter = 0;
                  while (IdsToHandle.length > 0 && counter < max) {
                    var nextId = IdsToHandle.pop();
                    if (nextId === void 0)
                      continue;
                    var nextEdge = this.body.edges[nextId];
                    if (nextEdge === void 0)
                      continue;
                    counter++;
                    var replacingIds = nextEdge.clusteringEdgeReplacingIds;
                    if (replacingIds === void 0) {
                      foundIds.push(nextId);
                    } else {
                      for (var i = 0; i < replacingIds.length; ++i) {
                        var replacingId = replacingIds[i];
                        if (IdsToHandle.indexOf(replacingIds) !== -1 || doneIds.indexOf(replacingIds) !== -1) {
                          continue;
                        }
                        IdsToHandle.push(replacingId);
                      }
                    }
                    doneIds.push(nextId);
                  }
                  return foundIds;
                }
              }, {
                key: "_getConnectedId",
                value: function _getConnectedId(edge, nodeId) {
                  if (edge.toId != nodeId) {
                    return edge.toId;
                  } else if (edge.fromId != nodeId) {
                    return edge.fromId;
                  } else {
                    return edge.fromId;
                  }
                }
              }, {
                key: "_getHubSize",
                value: function _getHubSize() {
                  var average = 0;
                  var averageSquared = 0;
                  var hubCounter = 0;
                  var largestHub = 0;
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var _node = this.body.nodes[this.body.nodeIndices[i]];
                    if (_node.edges.length > largestHub) {
                      largestHub = _node.edges.length;
                    }
                    average += _node.edges.length;
                    averageSquared += Math.pow(_node.edges.length, 2);
                    hubCounter += 1;
                  }
                  average = average / hubCounter;
                  averageSquared = averageSquared / hubCounter;
                  var variance = averageSquared - Math.pow(average, 2);
                  var standardDeviation = Math.sqrt(variance);
                  var hubThreshold = Math.floor(average + 2 * standardDeviation);
                  if (hubThreshold > largestHub) {
                    hubThreshold = largestHub;
                  }
                  return hubThreshold;
                }
              }, {
                key: "_createClusteredEdge",
                value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {
                  var clonedOptions = NetworkUtil.cloneOptions(baseEdge, "edge");
                  util.deepExtend(clonedOptions, clusterEdgeProperties);
                  clonedOptions.from = fromId;
                  clonedOptions.to = toId;
                  clonedOptions.id = "clusterEdge:" + util.randomUUID();
                  if (extraOptions !== void 0) {
                    util.deepExtend(clonedOptions, extraOptions);
                  }
                  var newEdge = this.body.functions.createEdge(clonedOptions);
                  newEdge.clusteringEdgeReplacingIds = [baseEdge.id];
                  newEdge.connect();
                  this.body.edges[newEdge.id] = newEdge;
                  return newEdge;
                }
              }, {
                key: "_clusterEdges",
                value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {
                  if (childEdges instanceof Edge) {
                    var edge = childEdges;
                    var obj = {};
                    obj[edge.id] = edge;
                    childEdges = obj;
                  }
                  if (childNodes instanceof Node) {
                    var _node2 = childNodes;
                    var _obj = {};
                    _obj[_node2.id] = _node2;
                    childNodes = _obj;
                  }
                  if (clusterNode === void 0 || clusterNode === null) {
                    throw new Error("_clusterEdges: parameter clusterNode required");
                  }
                  if (clusterEdgeProperties === void 0) {
                    clusterEdgeProperties = clusterNode.clusterEdgeProperties;
                  }
                  this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties);
                  for (var edgeId in childEdges) {
                    if (childEdges.hasOwnProperty(edgeId)) {
                      if (this.body.edges[edgeId] !== void 0) {
                        var _edge2 = this.body.edges[edgeId];
                        this._backupEdgeOptions(_edge2);
                        _edge2.setOptions({
                          physics: false
                        });
                      }
                    }
                  }
                  for (var _nodeId7 in childNodes) {
                    if (childNodes.hasOwnProperty(_nodeId7)) {
                      this.clusteredNodes[_nodeId7] = {
                        clusterId: clusterNode.id,
                        node: this.body.nodes[_nodeId7]
                      };
                      this.body.nodes[_nodeId7].setOptions({
                        physics: false
                      });
                    }
                  }
                }
              }, {
                key: "_getClusterNodeForNode",
                value: function _getClusterNodeForNode(nodeId) {
                  if (nodeId === void 0)
                    return void 0;
                  var clusteredNode = this.clusteredNodes[nodeId];
                  if (clusteredNode === void 0)
                    return void 0;
                  var clusterId = clusteredNode.clusterId;
                  if (clusterId === void 0)
                    return void 0;
                  return this.body.nodes[clusterId];
                }
              }, {
                key: "_filter",
                value: function _filter(arr, callback) {
                  var ret = [];
                  util.forEach(arr, function(item) {
                    if (callback(item)) {
                      ret.push(item);
                    }
                  });
                  return ret;
                }
              }, {
                key: "_updateState",
                value: function _updateState() {
                  var _this4 = this;
                  var nodeId = void 0;
                  var deletedNodeIds = [];
                  var deletedEdgeIds = {};
                  var eachClusterNode = function eachClusterNode2(callback) {
                    util.forEach(_this4.body.nodes, function(node) {
                      if (node.isCluster === true) {
                        callback(node);
                      }
                    });
                  };
                  for (nodeId in this.clusteredNodes) {
                    if (!this.clusteredNodes.hasOwnProperty(nodeId))
                      continue;
                    var _node3 = this.body.nodes[nodeId];
                    if (_node3 === void 0) {
                      deletedNodeIds.push(nodeId);
                    }
                  }
                  eachClusterNode(function(clusterNode) {
                    for (var n2 = 0; n2 < deletedNodeIds.length; n2++) {
                      delete clusterNode.containedNodes[deletedNodeIds[n2]];
                    }
                  });
                  for (var n = 0; n < deletedNodeIds.length; n++) {
                    delete this.clusteredNodes[deletedNodeIds[n]];
                  }
                  util.forEach(this.clusteredEdges, function(edgeId) {
                    var edge = _this4.body.edges[edgeId];
                    if (edge === void 0 || !edge.endPointsValid()) {
                      deletedEdgeIds[edgeId] = edgeId;
                    }
                  });
                  eachClusterNode(function(clusterNode) {
                    util.forEach(clusterNode.containedEdges, function(edge, edgeId) {
                      if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {
                        deletedEdgeIds[edgeId] = edgeId;
                      }
                    });
                  });
                  util.forEach(this.body.edges, function(edge, edgeId) {
                    var isValid = true;
                    var replacedIds = edge.clusteringEdgeReplacingIds;
                    if (replacedIds !== void 0) {
                      var numValid = 0;
                      util.forEach(replacedIds, function(containedEdgeId) {
                        var containedEdge = _this4.body.edges[containedEdgeId];
                        if (containedEdge !== void 0 && containedEdge.endPointsValid()) {
                          numValid += 1;
                        }
                      });
                      isValid = numValid > 0;
                    }
                    if (!edge.endPointsValid() || !isValid) {
                      deletedEdgeIds[edgeId] = edgeId;
                    }
                  });
                  eachClusterNode(function(clusterNode) {
                    util.forEach(deletedEdgeIds, function(deletedEdgeId) {
                      delete clusterNode.containedEdges[deletedEdgeId];
                      util.forEach(clusterNode.edges, function(edge, m) {
                        if (edge.id === deletedEdgeId) {
                          clusterNode.edges[m] = null;
                          return;
                        }
                        edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function(id2) {
                          return !deletedEdgeIds[id2];
                        });
                      });
                      clusterNode.edges = _this4._filter(clusterNode.edges, function(item) {
                        return item !== null;
                      });
                    });
                  });
                  util.forEach(deletedEdgeIds, function(edgeId) {
                    delete _this4.clusteredEdges[edgeId];
                  });
                  util.forEach(deletedEdgeIds, function(edgeId) {
                    delete _this4.body.edges[edgeId];
                  });
                  var ids = (0, _keys2["default"])(this.body.edges);
                  util.forEach(ids, function(edgeId) {
                    var edge = _this4.body.edges[edgeId];
                    var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);
                    if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {
                      return;
                    }
                    if (shouldBeClustered) {
                      var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);
                      if (clusterFrom !== void 0) {
                        _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);
                      }
                      var clusterTo = _this4._getClusterNodeForNode(edge.toId);
                      if (clusterTo !== void 0) {
                        _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);
                      }
                    } else {
                      delete _this4._clusterEdges[edgeId];
                      _this4._restoreEdge(edge);
                    }
                  });
                  var changed = false;
                  var continueLoop = true;
                  var _loop2 = function _loop22() {
                    var clustersToOpen = [];
                    eachClusterNode(function(clusterNode) {
                      var numNodes = (0, _keys2["default"])(clusterNode.containedNodes).length;
                      var allowSingle = clusterNode.options.allowSingleNodeCluster === true;
                      if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {
                        clustersToOpen.push(clusterNode.id);
                      }
                    });
                    for (var _n = 0; _n < clustersToOpen.length; ++_n) {
                      _this4.openCluster(
                        clustersToOpen[_n],
                        {},
                        false
                      );
                    }
                    continueLoop = clustersToOpen.length > 0;
                    changed = changed || continueLoop;
                  };
                  while (continueLoop) {
                    _loop2();
                  }
                  if (changed) {
                    this._updateState();
                  }
                }
              }, {
                key: "_isClusteredNode",
                value: function _isClusteredNode(nodeId) {
                  return this.clusteredNodes[nodeId] !== void 0;
                }
              }, {
                key: "_isClusteredEdge",
                value: function _isClusteredEdge(edgeId) {
                  return this.clusteredEdges[edgeId] !== void 0;
                }
              }]);
              return ClusterEngine2;
            }();
            exports2["default"] = ClusterEngine;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Node = __webpack_require__(34)["default"];
            var Cluster = function(_Node) {
              (0, _inherits3["default"])(Cluster2, _Node);
              function Cluster2(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
                (0, _classCallCheck3["default"])(this, Cluster2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Cluster2.__proto__ || (0, _getPrototypeOf2["default"])(Cluster2)).call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions));
                _this.isCluster = true;
                _this.containedNodes = {};
                _this.containedEdges = {};
                return _this;
              }
              (0, _createClass3["default"])(Cluster2, [{
                key: "_openChildCluster",
                value: function _openChildCluster(childClusterId) {
                  var _this2 = this;
                  var childCluster = this.body.nodes[childClusterId];
                  if (this.containedNodes[childClusterId] === void 0) {
                    throw new Error("node with id: " + childClusterId + " not in current cluster");
                  }
                  if (!childCluster.isCluster) {
                    throw new Error("node with id: " + childClusterId + " is not a cluster");
                  }
                  delete this.containedNodes[childClusterId];
                  util.forEach(childCluster.edges, function(edge) {
                    delete _this2.containedEdges[edge.id];
                  });
                  util.forEach(childCluster.containedNodes, function(node, nodeId) {
                    _this2.containedNodes[nodeId] = node;
                  });
                  childCluster.containedNodes = {};
                  util.forEach(childCluster.containedEdges, function(edge, edgeId) {
                    _this2.containedEdges[edgeId] = edge;
                  });
                  childCluster.containedEdges = {};
                  util.forEach(childCluster.edges, function(clusterEdge) {
                    util.forEach(_this2.edges, function(parentClusterEdge) {
                      var index = parentClusterEdge.clusteringEdgeReplacingIds.indexOf(clusterEdge.id);
                      if (index === -1)
                        return;
                      util.forEach(clusterEdge.clusteringEdgeReplacingIds, function(srcId) {
                        parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);
                        _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;
                      });
                      parentClusterEdge.clusteringEdgeReplacingIds.splice(index, 1);
                    });
                  });
                  childCluster.edges = [];
                }
              }]);
              return Cluster2;
            }(Node);
            exports2["default"] = Cluster;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function _initRequestAnimationFrame() {
              var func;
              if (window !== void 0) {
                func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
              }
              if (func === void 0) {
                window.requestAnimationFrame = function(callback) {
                  callback();
                };
              } else {
                window.requestAnimationFrame = func;
              }
            }
            var util = __webpack_require__(2);
            var CanvasRenderer = function() {
              function CanvasRenderer2(body, canvas) {
                (0, _classCallCheck3["default"])(this, CanvasRenderer2);
                _initRequestAnimationFrame();
                this.body = body;
                this.canvas = canvas;
                this.redrawRequested = false;
                this.renderTimer = void 0;
                this.requiresTimeout = true;
                this.renderingActive = false;
                this.renderRequests = 0;
                this.allowRedraw = true;
                this.dragging = false;
                this.zooming = false;
                this.options = {};
                this.defaultOptions = {
                  hideEdgesOnDrag: false,
                  hideEdgesOnZoom: false,
                  hideNodesOnDrag: false
                };
                util.extend(this.options, this.defaultOptions);
                this._determineBrowserMethod();
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(CanvasRenderer2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this = this;
                  this.body.emitter.on("dragStart", function() {
                    _this.dragging = true;
                  });
                  this.body.emitter.on("dragEnd", function() {
                    _this.dragging = false;
                  });
                  this.body.emitter.on("zoom", function() {
                    _this.zooming = true;
                    window.clearTimeout(_this.zoomTimeoutId);
                    _this.zoomTimeoutId = window.setTimeout(function() {
                      _this.zooming = false;
                      _this._requestRedraw.bind(_this)();
                    }, 250);
                  });
                  this.body.emitter.on("_resizeNodes", function() {
                    _this._resizeNodes();
                  });
                  this.body.emitter.on("_redraw", function() {
                    if (_this.renderingActive === false) {
                      _this._redraw();
                    }
                  });
                  this.body.emitter.on("_blockRedraw", function() {
                    _this.allowRedraw = false;
                  });
                  this.body.emitter.on("_allowRedraw", function() {
                    _this.allowRedraw = true;
                    _this.redrawRequested = false;
                  });
                  this.body.emitter.on("_requestRedraw", this._requestRedraw.bind(this));
                  this.body.emitter.on("_startRendering", function() {
                    _this.renderRequests += 1;
                    _this.renderingActive = true;
                    _this._startRendering();
                  });
                  this.body.emitter.on("_stopRendering", function() {
                    _this.renderRequests -= 1;
                    _this.renderingActive = _this.renderRequests > 0;
                    _this.renderTimer = void 0;
                  });
                  this.body.emitter.on("destroy", function() {
                    _this.renderRequests = 0;
                    _this.allowRedraw = false;
                    _this.renderingActive = false;
                    if (_this.requiresTimeout === true) {
                      clearTimeout(_this.renderTimer);
                    } else {
                      window.cancelAnimationFrame(_this.renderTimer);
                    }
                    _this.body.emitter.off();
                  });
                }
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag"];
                    util.selectiveDeepExtend(fields, this.options, options);
                  }
                }
              }, {
                key: "_requestNextFrame",
                value: function _requestNextFrame(callback, delay) {
                  if (typeof window === "undefined")
                    return;
                  var timer = void 0;
                  var myWindow = window;
                  if (this.requiresTimeout === true) {
                    timer = myWindow.setTimeout(callback, delay);
                  } else {
                    if (myWindow.requestAnimationFrame) {
                      timer = myWindow.requestAnimationFrame(callback);
                    }
                  }
                  return timer;
                }
              }, {
                key: "_startRendering",
                value: function _startRendering() {
                  if (this.renderingActive === true) {
                    if (this.renderTimer === void 0) {
                      this.renderTimer = this._requestNextFrame(this._renderStep.bind(this), this.simulationInterval);
                    }
                  }
                }
              }, {
                key: "_renderStep",
                value: function _renderStep() {
                  if (this.renderingActive === true) {
                    this.renderTimer = void 0;
                    if (this.requiresTimeout === true) {
                      this._startRendering();
                    }
                    this._redraw();
                    if (this.requiresTimeout === false) {
                      this._startRendering();
                    }
                  }
                }
              }, {
                key: "redraw",
                value: function redraw() {
                  this.body.emitter.emit("setSize");
                  this._redraw();
                }
              }, {
                key: "_requestRedraw",
                value: function _requestRedraw() {
                  var _this2 = this;
                  if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
                    this.redrawRequested = true;
                    this._requestNextFrame(function() {
                      _this2._redraw(false);
                    }, 0);
                  }
                }
              }, {
                key: "_redraw",
                value: function _redraw() {
                  var hidden = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (this.allowRedraw === true) {
                    this.body.emitter.emit("initRedraw");
                    this.redrawRequested = false;
                    if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
                      this.canvas.setSize();
                    }
                    this.canvas.setTransform();
                    var ctx = this.canvas.getContext();
                    var w = this.canvas.frame.canvas.clientWidth;
                    var h = this.canvas.frame.canvas.clientHeight;
                    ctx.clearRect(0, 0, w, h);
                    if (this.canvas.frame.clientWidth === 0) {
                      return;
                    }
                    ctx.save();
                    ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
                    ctx.scale(this.body.view.scale, this.body.view.scale);
                    ctx.beginPath();
                    this.body.emitter.emit("beforeDrawing", ctx);
                    ctx.closePath();
                    if (hidden === false) {
                      if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
                        this._drawEdges(ctx);
                      }
                    }
                    if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
                      this._drawNodes(ctx, hidden);
                    }
                    ctx.beginPath();
                    this.body.emitter.emit("afterDrawing", ctx);
                    ctx.closePath();
                    ctx.restore();
                    if (hidden === true) {
                      ctx.clearRect(0, 0, w, h);
                    }
                  }
                }
              }, {
                key: "_resizeNodes",
                value: function _resizeNodes() {
                  this.canvas.setTransform();
                  var ctx = this.canvas.getContext();
                  ctx.save();
                  ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
                  ctx.scale(this.body.view.scale, this.body.view.scale);
                  var nodes2 = this.body.nodes;
                  var node = void 0;
                  for (var nodeId in nodes2) {
                    if (nodes2.hasOwnProperty(nodeId)) {
                      node = nodes2[nodeId];
                      node.resize(ctx);
                      node.updateBoundingBox(ctx, node.selected);
                    }
                  }
                  ctx.restore();
                }
              }, {
                key: "_drawNodes",
                value: function _drawNodes(ctx) {
                  var alwaysShow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var nodes2 = this.body.nodes;
                  var nodeIndices = this.body.nodeIndices;
                  var node = void 0;
                  var selected = [];
                  var margin = 20;
                  var topLeft = this.canvas.DOMtoCanvas({ x: -margin, y: -margin });
                  var bottomRight = this.canvas.DOMtoCanvas({
                    x: this.canvas.frame.canvas.clientWidth + margin,
                    y: this.canvas.frame.canvas.clientHeight + margin
                  });
                  var viewableArea = {
                    top: topLeft.y,
                    left: topLeft.x,
                    bottom: bottomRight.y,
                    right: bottomRight.x
                  };
                  for (var i = 0; i < nodeIndices.length; i++) {
                    node = nodes2[nodeIndices[i]];
                    if (node.isSelected()) {
                      selected.push(nodeIndices[i]);
                    } else {
                      if (alwaysShow === true) {
                        node.draw(ctx);
                      } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
                        node.draw(ctx);
                      } else {
                        node.updateBoundingBox(ctx, node.selected);
                      }
                    }
                  }
                  for (var _i = 0; _i < selected.length; _i++) {
                    node = nodes2[selected[_i]];
                    node.draw(ctx);
                  }
                }
              }, {
                key: "_drawEdges",
                value: function _drawEdges(ctx) {
                  var edges2 = this.body.edges;
                  var edgeIndices = this.body.edgeIndices;
                  var edge = void 0;
                  for (var i = 0; i < edgeIndices.length; i++) {
                    edge = edges2[edgeIndices[i]];
                    if (edge.connected === true) {
                      edge.draw(ctx);
                    }
                  }
                }
              }, {
                key: "_determineBrowserMethod",
                value: function _determineBrowserMethod() {
                  if (typeof window !== "undefined") {
                    var browserType = navigator.userAgent.toLowerCase();
                    this.requiresTimeout = false;
                    if (browserType.indexOf("msie 9.0") != -1) {
                      this.requiresTimeout = true;
                    } else if (browserType.indexOf("safari") != -1) {
                      if (browserType.indexOf("chrome") <= -1) {
                        this.requiresTimeout = true;
                      }
                    }
                  } else {
                    this.requiresTimeout = true;
                  }
                }
              }]);
              return CanvasRenderer2;
            }();
            exports2["default"] = CanvasRenderer;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hammer = __webpack_require__(24);
            var hammerUtil = __webpack_require__(36);
            var util = __webpack_require__(2);
            var Canvas = function() {
              function Canvas2(body) {
                (0, _classCallCheck3["default"])(this, Canvas2);
                this.body = body;
                this.pixelRatio = 1;
                this.resizeTimer = void 0;
                this.resizeFunction = this._onResize.bind(this);
                this.cameraState = {};
                this.initialized = false;
                this.canvasViewCenter = {};
                this.options = {};
                this.defaultOptions = {
                  autoResize: true,
                  height: "100%",
                  width: "100%"
                };
                util.extend(this.options, this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(Canvas2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this = this;
                  this.body.emitter.once("resize", function(obj) {
                    if (obj.width !== 0) {
                      _this.body.view.translation.x = obj.width * 0.5;
                    }
                    if (obj.height !== 0) {
                      _this.body.view.translation.y = obj.height * 0.5;
                    }
                  });
                  this.body.emitter.on("setSize", this.setSize.bind(this));
                  this.body.emitter.on("destroy", function() {
                    _this.hammerFrame.destroy();
                    _this.hammer.destroy();
                    _this._cleanUp();
                  });
                }
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  var _this2 = this;
                  if (options !== void 0) {
                    var fields = ["width", "height", "autoResize"];
                    util.selectiveDeepExtend(fields, this.options, options);
                  }
                  if (this.options.autoResize === true) {
                    this._cleanUp();
                    this.resizeTimer = setInterval(function() {
                      var changed = _this2.setSize();
                      if (changed === true) {
                        _this2.body.emitter.emit("_requestRedraw");
                      }
                    }, 1e3);
                    this.resizeFunction = this._onResize.bind(this);
                    util.addEventListener(window, "resize", this.resizeFunction);
                  }
                }
              }, {
                key: "_cleanUp",
                value: function _cleanUp() {
                  if (this.resizeTimer !== void 0) {
                    clearInterval(this.resizeTimer);
                  }
                  util.removeEventListener(window, "resize", this.resizeFunction);
                  this.resizeFunction = void 0;
                }
              }, {
                key: "_onResize",
                value: function _onResize() {
                  this.setSize();
                  this.body.emitter.emit("_redraw");
                }
              }, {
                key: "_getCameraState",
                value: function _getCameraState() {
                  var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.pixelRatio;
                  if (this.initialized === true) {
                    this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
                    this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
                    this.cameraState.scale = this.body.view.scale;
                    this.cameraState.position = this.DOMtoCanvas({
                      x: 0.5 * this.frame.canvas.width / pixelRatio,
                      y: 0.5 * this.frame.canvas.height / pixelRatio
                    });
                  }
                }
              }, {
                key: "_setCameraState",
                value: function _setCameraState() {
                  if (this.cameraState.scale !== void 0 && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0) {
                    var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
                    var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
                    var newScale = this.cameraState.scale;
                    if (widthRatio != 1 && heightRatio != 1) {
                      newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
                    } else if (widthRatio != 1) {
                      newScale = this.cameraState.scale * widthRatio;
                    } else if (heightRatio != 1) {
                      newScale = this.cameraState.scale * heightRatio;
                    }
                    this.body.view.scale = newScale;
                    var currentViewCenter = this.DOMtoCanvas({
                      x: 0.5 * this.frame.canvas.clientWidth,
                      y: 0.5 * this.frame.canvas.clientHeight
                    });
                    var distanceFromCenter = {
                      x: currentViewCenter.x - this.cameraState.position.x,
                      y: currentViewCenter.y - this.cameraState.position.y
                    };
                    this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
                    this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
                  }
                }
              }, {
                key: "_prepareValue",
                value: function _prepareValue(value) {
                  if (typeof value === "number") {
                    return value + "px";
                  } else if (typeof value === "string") {
                    if (value.indexOf("%") !== -1 || value.indexOf("px") !== -1) {
                      return value;
                    } else if (value.indexOf("%") === -1) {
                      return value + "px";
                    }
                  }
                  throw new Error("Could not use the value supplied for width or height:" + value);
                }
              }, {
                key: "_create",
                value: function _create() {
                  while (this.body.container.hasChildNodes()) {
                    this.body.container.removeChild(this.body.container.firstChild);
                  }
                  this.frame = document.createElement("div");
                  this.frame.className = "vis-network";
                  this.frame.style.position = "relative";
                  this.frame.style.overflow = "hidden";
                  this.frame.tabIndex = 900;
                  this.frame.canvas = document.createElement("canvas");
                  this.frame.canvas.style.position = "relative";
                  this.frame.appendChild(this.frame.canvas);
                  if (!this.frame.canvas.getContext) {
                    var noCanvas = document.createElement("DIV");
                    noCanvas.style.color = "red";
                    noCanvas.style.fontWeight = "bold";
                    noCanvas.style.padding = "10px";
                    noCanvas.innerHTML = "Error: your browser does not support HTML canvas";
                    this.frame.canvas.appendChild(noCanvas);
                  } else {
                    this._setPixelRatio();
                    this.setTransform();
                  }
                  this.body.container.appendChild(this.frame);
                  this.body.view.scale = 1;
                  this.body.view.translation = {
                    x: 0.5 * this.frame.canvas.clientWidth,
                    y: 0.5 * this.frame.canvas.clientHeight
                  };
                  this._bindHammer();
                }
              }, {
                key: "_bindHammer",
                value: function _bindHammer() {
                  var _this3 = this;
                  if (this.hammer !== void 0) {
                    this.hammer.destroy();
                  }
                  this.drag = {};
                  this.pinch = {};
                  this.hammer = new Hammer(this.frame.canvas);
                  this.hammer.get("pinch").set({ enable: true });
                  this.hammer.get("pan").set({ threshold: 5, direction: Hammer.DIRECTION_ALL });
                  hammerUtil.onTouch(this.hammer, function(event) {
                    _this3.body.eventListeners.onTouch(event);
                  });
                  this.hammer.on("tap", function(event) {
                    _this3.body.eventListeners.onTap(event);
                  });
                  this.hammer.on("doubletap", function(event) {
                    _this3.body.eventListeners.onDoubleTap(event);
                  });
                  this.hammer.on("press", function(event) {
                    _this3.body.eventListeners.onHold(event);
                  });
                  this.hammer.on("panstart", function(event) {
                    _this3.body.eventListeners.onDragStart(event);
                  });
                  this.hammer.on("panmove", function(event) {
                    _this3.body.eventListeners.onDrag(event);
                  });
                  this.hammer.on("panend", function(event) {
                    _this3.body.eventListeners.onDragEnd(event);
                  });
                  this.hammer.on("pinch", function(event) {
                    _this3.body.eventListeners.onPinch(event);
                  });
                  this.frame.canvas.addEventListener("mousewheel", function(event) {
                    _this3.body.eventListeners.onMouseWheel(event);
                  });
                  this.frame.canvas.addEventListener("DOMMouseScroll", function(event) {
                    _this3.body.eventListeners.onMouseWheel(event);
                  });
                  this.frame.canvas.addEventListener("mousemove", function(event) {
                    _this3.body.eventListeners.onMouseMove(event);
                  });
                  this.frame.canvas.addEventListener("contextmenu", function(event) {
                    _this3.body.eventListeners.onContext(event);
                  });
                  this.hammerFrame = new Hammer(this.frame);
                  hammerUtil.onRelease(this.hammerFrame, function(event) {
                    _this3.body.eventListeners.onRelease(event);
                  });
                }
              }, {
                key: "setSize",
                value: function setSize() {
                  var width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.width;
                  var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.height;
                  width = this._prepareValue(width);
                  height = this._prepareValue(height);
                  var emitEvent = false;
                  var oldWidth = this.frame.canvas.width;
                  var oldHeight = this.frame.canvas.height;
                  var previousRatio = this.pixelRatio;
                  this._setPixelRatio();
                  if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
                    this._getCameraState(previousRatio);
                    this.frame.style.width = width;
                    this.frame.style.height = height;
                    this.frame.canvas.style.width = "100%";
                    this.frame.canvas.style.height = "100%";
                    this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
                    this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
                    this.options.width = width;
                    this.options.height = height;
                    this.canvasViewCenter = {
                      x: 0.5 * this.frame.clientWidth,
                      y: 0.5 * this.frame.clientHeight
                    };
                    emitEvent = true;
                  } else {
                    var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
                    var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
                    if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {
                      this._getCameraState(previousRatio);
                    }
                    if (this.frame.canvas.width !== newWidth) {
                      this.frame.canvas.width = newWidth;
                      emitEvent = true;
                    }
                    if (this.frame.canvas.height !== newHeight) {
                      this.frame.canvas.height = newHeight;
                      emitEvent = true;
                    }
                  }
                  if (emitEvent === true) {
                    this.body.emitter.emit("resize", {
                      width: Math.round(this.frame.canvas.width / this.pixelRatio),
                      height: Math.round(this.frame.canvas.height / this.pixelRatio),
                      oldWidth: Math.round(oldWidth / this.pixelRatio),
                      oldHeight: Math.round(oldHeight / this.pixelRatio)
                    });
                    this._setCameraState();
                  }
                  this.initialized = true;
                  return emitEvent;
                }
              }, {
                key: "getContext",
                value: function getContext() {
                  return this.frame.canvas.getContext("2d");
                }
              }, {
                key: "_determinePixelRatio",
                value: function _determinePixelRatio() {
                  var ctx = this.getContext();
                  if (ctx === void 0) {
                    throw new Error("Could not get canvax context");
                  }
                  var numerator = 1;
                  if (typeof window !== "undefined") {
                    numerator = window.devicePixelRatio || 1;
                  }
                  var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
                  return numerator / denominator;
                }
              }, {
                key: "_setPixelRatio",
                value: function _setPixelRatio() {
                  this.pixelRatio = this._determinePixelRatio();
                }
              }, {
                key: "setTransform",
                value: function setTransform() {
                  var ctx = this.getContext();
                  if (ctx === void 0) {
                    throw new Error("Could not get canvax context");
                  }
                  ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                }
              }, {
                key: "_XconvertDOMtoCanvas",
                value: function _XconvertDOMtoCanvas(x) {
                  return (x - this.body.view.translation.x) / this.body.view.scale;
                }
              }, {
                key: "_XconvertCanvasToDOM",
                value: function _XconvertCanvasToDOM(x) {
                  return x * this.body.view.scale + this.body.view.translation.x;
                }
              }, {
                key: "_YconvertDOMtoCanvas",
                value: function _YconvertDOMtoCanvas(y) {
                  return (y - this.body.view.translation.y) / this.body.view.scale;
                }
              }, {
                key: "_YconvertCanvasToDOM",
                value: function _YconvertCanvasToDOM(y) {
                  return y * this.body.view.scale + this.body.view.translation.y;
                }
              }, {
                key: "canvasToDOM",
                value: function canvasToDOM(pos) {
                  return {
                    x: this._XconvertCanvasToDOM(pos.x),
                    y: this._YconvertCanvasToDOM(pos.y)
                  };
                }
              }, {
                key: "DOMtoCanvas",
                value: function DOMtoCanvas(pos) {
                  return {
                    x: this._XconvertDOMtoCanvas(pos.x),
                    y: this._YconvertDOMtoCanvas(pos.y)
                  };
                }
              }]);
              return Canvas2;
            }();
            exports2["default"] = Canvas;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _assign = __webpack_require__(78);
            var _assign2 = _interopRequireDefault(_assign);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var NetworkUtil = __webpack_require__(57)["default"];
            var View = function() {
              function View2(body, canvas) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, View2);
                this.body = body;
                this.canvas = canvas;
                this.animationSpeed = 1 / this.renderRefreshRate;
                this.animationEasingFunction = "easeInOutQuint";
                this.easingTime = 0;
                this.sourceScale = 0;
                this.targetScale = 0;
                this.sourceTranslation = 0;
                this.targetTranslation = 0;
                this.lockedOnNodeId = void 0;
                this.lockedOnNodeOffset = void 0;
                this.touchTime = 0;
                this.viewFunction = void 0;
                this.body.emitter.on("fit", this.fit.bind(this));
                this.body.emitter.on("animationFinished", function() {
                  _this.body.emitter.emit("_stopRendering");
                });
                this.body.emitter.on("unlockNode", this.releaseNode.bind(this));
              }
              (0, _createClass3["default"])(View2, [{
                key: "setOptions",
                value: function setOptions() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  this.options = options;
                }
              }, {
                key: "fit",
                value: function fit() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { nodes: [] };
                  var initialZoom = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var range = void 0;
                  var zoomLevel = void 0;
                  options = (0, _assign2["default"])({}, options);
                  if (options.nodes === void 0 || options.nodes.length === 0) {
                    options.nodes = this.body.nodeIndices;
                  }
                  if (initialZoom === true) {
                    var positionDefined = 0;
                    for (var nodeId in this.body.nodes) {
                      if (this.body.nodes.hasOwnProperty(nodeId)) {
                        var node = this.body.nodes[nodeId];
                        if (node.predefinedPosition === true) {
                          positionDefined += 1;
                        }
                      }
                    }
                    if (positionDefined > 0.5 * this.body.nodeIndices.length) {
                      this.fit(options, false);
                      return;
                    }
                    range = NetworkUtil.getRange(this.body.nodes, options.nodes);
                    var numberOfNodes = this.body.nodeIndices.length;
                    zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822;
                    var factor = Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600);
                    zoomLevel *= factor;
                  } else {
                    this.body.emitter.emit("_resizeNodes");
                    range = NetworkUtil.getRange(this.body.nodes, options.nodes);
                    var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
                    var yDistance = Math.abs(range.maxY - range.minY) * 1.1;
                    var xZoomLevel = this.canvas.frame.canvas.clientWidth / xDistance;
                    var yZoomLevel = this.canvas.frame.canvas.clientHeight / yDistance;
                    zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
                  }
                  if (zoomLevel > 1) {
                    zoomLevel = 1;
                  } else if (zoomLevel === 0) {
                    zoomLevel = 1;
                  }
                  var center = NetworkUtil.findCenter(range);
                  var animationOptions = {
                    position: center,
                    scale: zoomLevel,
                    animation: options.animation
                  };
                  this.moveTo(animationOptions);
                }
              }, {
                key: "focus",
                value: function focus(nodeId) {
                  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  if (this.body.nodes[nodeId] !== void 0) {
                    var nodePosition = {
                      x: this.body.nodes[nodeId].x,
                      y: this.body.nodes[nodeId].y
                    };
                    options.position = nodePosition;
                    options.lockedOnNode = nodeId;
                    this.moveTo(options);
                  } else {
                    console.log("Node: " + nodeId + " cannot be found.");
                  }
                }
              }, {
                key: "moveTo",
                value: function moveTo(options) {
                  if (options === void 0) {
                    options = {};
                    return;
                  }
                  if (options.offset === void 0) {
                    options.offset = { x: 0, y: 0 };
                  }
                  if (options.offset.x === void 0) {
                    options.offset.x = 0;
                  }
                  if (options.offset.y === void 0) {
                    options.offset.y = 0;
                  }
                  if (options.scale === void 0) {
                    options.scale = this.body.view.scale;
                  }
                  if (options.position === void 0) {
                    options.position = this.getViewPosition();
                  }
                  if (options.animation === void 0) {
                    options.animation = { duration: 0 };
                  }
                  if (options.animation === false) {
                    options.animation = { duration: 0 };
                  }
                  if (options.animation === true) {
                    options.animation = {};
                  }
                  if (options.animation.duration === void 0) {
                    options.animation.duration = 1e3;
                  }
                  if (options.animation.easingFunction === void 0) {
                    options.animation.easingFunction = "easeInOutQuad";
                  }
                  this.animateView(options);
                }
              }, {
                key: "animateView",
                value: function animateView(options) {
                  if (options === void 0) {
                    return;
                  }
                  this.animationEasingFunction = options.animation.easingFunction;
                  this.releaseNode();
                  if (options.locked === true) {
                    this.lockedOnNodeId = options.lockedOnNode;
                    this.lockedOnNodeOffset = options.offset;
                  }
                  if (this.easingTime != 0) {
                    this._transitionRedraw(true);
                  }
                  this.sourceScale = this.body.view.scale;
                  this.sourceTranslation = this.body.view.translation;
                  this.targetScale = options.scale;
                  this.body.view.scale = this.targetScale;
                  var viewCenter = this.canvas.DOMtoCanvas({
                    x: 0.5 * this.canvas.frame.canvas.clientWidth,
                    y: 0.5 * this.canvas.frame.canvas.clientHeight
                  });
                  var distanceFromCenter = {
                    x: viewCenter.x - options.position.x,
                    y: viewCenter.y - options.position.y
                  };
                  this.targetTranslation = {
                    x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
                    y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y
                  };
                  if (options.animation.duration === 0) {
                    if (this.lockedOnNodeId != void 0) {
                      this.viewFunction = this._lockedRedraw.bind(this);
                      this.body.emitter.on("initRedraw", this.viewFunction);
                    } else {
                      this.body.view.scale = this.targetScale;
                      this.body.view.translation = this.targetTranslation;
                      this.body.emitter.emit("_requestRedraw");
                    }
                  } else {
                    this.animationSpeed = 1 / (60 * options.animation.duration * 1e-3) || 1 / 60;
                    this.animationEasingFunction = options.animation.easingFunction;
                    this.viewFunction = this._transitionRedraw.bind(this);
                    this.body.emitter.on("initRedraw", this.viewFunction);
                    this.body.emitter.emit("_startRendering");
                  }
                }
              }, {
                key: "_lockedRedraw",
                value: function _lockedRedraw() {
                  var nodePosition = {
                    x: this.body.nodes[this.lockedOnNodeId].x,
                    y: this.body.nodes[this.lockedOnNodeId].y
                  };
                  var viewCenter = this.canvas.DOMtoCanvas({
                    x: 0.5 * this.canvas.frame.canvas.clientWidth,
                    y: 0.5 * this.canvas.frame.canvas.clientHeight
                  });
                  var distanceFromCenter = {
                    x: viewCenter.x - nodePosition.x,
                    y: viewCenter.y - nodePosition.y
                  };
                  var sourceTranslation = this.body.view.translation;
                  var targetTranslation = {
                    x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
                    y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
                  };
                  this.body.view.translation = targetTranslation;
                }
              }, {
                key: "releaseNode",
                value: function releaseNode() {
                  if (this.lockedOnNodeId !== void 0 && this.viewFunction !== void 0) {
                    this.body.emitter.off("initRedraw", this.viewFunction);
                    this.lockedOnNodeId = void 0;
                    this.lockedOnNodeOffset = void 0;
                  }
                }
              }, {
                key: "_transitionRedraw",
                value: function _transitionRedraw() {
                  var finished = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  this.easingTime += this.animationSpeed;
                  this.easingTime = finished === true ? 1 : this.easingTime;
                  var progress = util.easingFunctions[this.animationEasingFunction](this.easingTime);
                  this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
                  this.body.view.translation = {
                    x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
                    y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
                  };
                  if (this.easingTime >= 1) {
                    this.body.emitter.off("initRedraw", this.viewFunction);
                    this.easingTime = 0;
                    if (this.lockedOnNodeId != void 0) {
                      this.viewFunction = this._lockedRedraw.bind(this);
                      this.body.emitter.on("initRedraw", this.viewFunction);
                    }
                    this.body.emitter.emit("animationFinished");
                  }
                }
              }, {
                key: "getScale",
                value: function getScale() {
                  return this.body.view.scale;
                }
              }, {
                key: "getViewPosition",
                value: function getViewPosition() {
                  return this.canvas.DOMtoCanvas({
                    x: 0.5 * this.canvas.frame.canvas.clientWidth,
                    y: 0.5 * this.canvas.frame.canvas.clientHeight
                  });
                }
              }]);
              return View2;
            }();
            exports2["default"] = View;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var NavigationHandler = __webpack_require__(184)["default"];
            var Popup = __webpack_require__(185)["default"];
            var InteractionHandler = function() {
              function InteractionHandler2(body, canvas, selectionHandler) {
                (0, _classCallCheck3["default"])(this, InteractionHandler2);
                this.body = body;
                this.canvas = canvas;
                this.selectionHandler = selectionHandler;
                this.navigationHandler = new NavigationHandler(body, canvas);
                this.body.eventListeners.onTap = this.onTap.bind(this);
                this.body.eventListeners.onTouch = this.onTouch.bind(this);
                this.body.eventListeners.onDoubleTap = this.onDoubleTap.bind(this);
                this.body.eventListeners.onHold = this.onHold.bind(this);
                this.body.eventListeners.onDragStart = this.onDragStart.bind(this);
                this.body.eventListeners.onDrag = this.onDrag.bind(this);
                this.body.eventListeners.onDragEnd = this.onDragEnd.bind(this);
                this.body.eventListeners.onMouseWheel = this.onMouseWheel.bind(this);
                this.body.eventListeners.onPinch = this.onPinch.bind(this);
                this.body.eventListeners.onMouseMove = this.onMouseMove.bind(this);
                this.body.eventListeners.onRelease = this.onRelease.bind(this);
                this.body.eventListeners.onContext = this.onContext.bind(this);
                this.touchTime = 0;
                this.drag = {};
                this.pinch = {};
                this.popup = void 0;
                this.popupObj = void 0;
                this.popupTimer = void 0;
                this.body.functions.getPointer = this.getPointer.bind(this);
                this.options = {};
                this.defaultOptions = {
                  dragNodes: true,
                  dragView: true,
                  hover: false,
                  keyboard: {
                    enabled: false,
                    speed: { x: 10, y: 10, zoom: 0.02 },
                    bindToWindow: true
                  },
                  navigationButtons: false,
                  tooltipDelay: 300,
                  zoomView: true,
                  zoomSpeed: 1
                };
                util.extend(this.options, this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(InteractionHandler2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this = this;
                  this.body.emitter.on("destroy", function() {
                    clearTimeout(_this.popupTimer);
                    delete _this.body.functions.getPointer;
                  });
                }
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag", "keyboard", "multiselect", "selectable", "selectConnectedEdges"];
                    util.selectiveNotDeepExtend(fields, this.options, options);
                    util.mergeOptions(this.options, options, "keyboard");
                    if (options.tooltip) {
                      util.extend(this.options.tooltip, options.tooltip);
                      if (options.tooltip.color) {
                        this.options.tooltip.color = util.parseColor(options.tooltip.color);
                      }
                    }
                  }
                  this.navigationHandler.setOptions(this.options);
                }
              }, {
                key: "getPointer",
                value: function getPointer(touch) {
                  return {
                    x: touch.x - util.getAbsoluteLeft(this.canvas.frame.canvas),
                    y: touch.y - util.getAbsoluteTop(this.canvas.frame.canvas)
                  };
                }
              }, {
                key: "onTouch",
                value: function onTouch(event) {
                  if (new Date().valueOf() - this.touchTime > 50) {
                    this.drag.pointer = this.getPointer(event.center);
                    this.drag.pinched = false;
                    this.pinch.scale = this.body.view.scale;
                    this.touchTime = new Date().valueOf();
                  }
                }
              }, {
                key: "onTap",
                value: function onTap(event) {
                  var pointer = this.getPointer(event.center);
                  var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);
                  this.checkSelectionChanges(pointer, event, multiselect);
                  this.selectionHandler._generateClickEvent("click", event, pointer);
                }
              }, {
                key: "onDoubleTap",
                value: function onDoubleTap(event) {
                  var pointer = this.getPointer(event.center);
                  this.selectionHandler._generateClickEvent("doubleClick", event, pointer);
                }
              }, {
                key: "onHold",
                value: function onHold(event) {
                  var pointer = this.getPointer(event.center);
                  var multiselect = this.selectionHandler.options.multiselect;
                  this.checkSelectionChanges(pointer, event, multiselect);
                  this.selectionHandler._generateClickEvent("click", event, pointer);
                  this.selectionHandler._generateClickEvent("hold", event, pointer);
                }
              }, {
                key: "onRelease",
                value: function onRelease(event) {
                  if (new Date().valueOf() - this.touchTime > 10) {
                    var pointer = this.getPointer(event.center);
                    this.selectionHandler._generateClickEvent("release", event, pointer);
                    this.touchTime = new Date().valueOf();
                  }
                }
              }, {
                key: "onContext",
                value: function onContext(event) {
                  var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
                  this.selectionHandler._generateClickEvent("oncontext", event, pointer);
                }
              }, {
                key: "checkSelectionChanges",
                value: function checkSelectionChanges(pointer, event) {
                  var add2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var previousSelection = this.selectionHandler.getSelection();
                  var selected = false;
                  if (add2 === true) {
                    selected = this.selectionHandler.selectAdditionalOnPoint(pointer);
                  } else {
                    selected = this.selectionHandler.selectOnPoint(pointer);
                  }
                  var currentSelection = this.selectionHandler.getSelection();
                  var deselectedItems = this._determineDifference(previousSelection, currentSelection);
                  var selectedItems = this._determineDifference(currentSelection, previousSelection);
                  if (deselectedItems.edges.length > 0) {
                    this.selectionHandler._generateClickEvent("deselectEdge", event, pointer, previousSelection);
                    selected = true;
                  }
                  if (deselectedItems.nodes.length > 0) {
                    this.selectionHandler._generateClickEvent("deselectNode", event, pointer, previousSelection);
                    selected = true;
                  }
                  if (selectedItems.nodes.length > 0) {
                    this.selectionHandler._generateClickEvent("selectNode", event, pointer);
                    selected = true;
                  }
                  if (selectedItems.edges.length > 0) {
                    this.selectionHandler._generateClickEvent("selectEdge", event, pointer);
                    selected = true;
                  }
                  if (selected === true) {
                    this.selectionHandler._generateClickEvent("select", event, pointer);
                  }
                }
              }, {
                key: "_determineDifference",
                value: function _determineDifference(firstSet, secondSet) {
                  var arrayDiff = function arrayDiff2(firstArr, secondArr) {
                    var result2 = [];
                    for (var i = 0; i < firstArr.length; i++) {
                      var value = firstArr[i];
                      if (secondArr.indexOf(value) === -1) {
                        result2.push(value);
                      }
                    }
                    return result2;
                  };
                  return {
                    nodes: arrayDiff(firstSet.nodes, secondSet.nodes),
                    edges: arrayDiff(firstSet.edges, secondSet.edges)
                  };
                }
              }, {
                key: "onDragStart",
                value: function onDragStart(event) {
                  if (this.drag.pointer === void 0) {
                    this.onTouch(event);
                  }
                  var node = this.selectionHandler.getNodeAt(this.drag.pointer);
                  this.drag.dragging = true;
                  this.drag.selection = [];
                  this.drag.translation = util.extend({}, this.body.view.translation);
                  this.drag.nodeId = void 0;
                  if (node !== void 0 && this.options.dragNodes === true) {
                    this.drag.nodeId = node.id;
                    if (node.isSelected() === false) {
                      this.selectionHandler.unselectAll();
                      this.selectionHandler.selectObject(node);
                    }
                    this.selectionHandler._generateClickEvent("dragStart", event, this.drag.pointer);
                    var selection = this.selectionHandler.selectionObj.nodes;
                    for (var nodeId in selection) {
                      if (selection.hasOwnProperty(nodeId)) {
                        var object = selection[nodeId];
                        var s = {
                          id: object.id,
                          node: object,
                          x: object.x,
                          y: object.y,
                          xFixed: object.options.fixed.x,
                          yFixed: object.options.fixed.y
                        };
                        object.options.fixed.x = true;
                        object.options.fixed.y = true;
                        this.drag.selection.push(s);
                      }
                    }
                  } else {
                    this.selectionHandler._generateClickEvent("dragStart", event, this.drag.pointer, void 0, true);
                  }
                }
              }, {
                key: "onDrag",
                value: function onDrag(event) {
                  var _this2 = this;
                  if (this.drag.pinched === true) {
                    return;
                  }
                  this.body.emitter.emit("unlockNode");
                  var pointer = this.getPointer(event.center);
                  var selection = this.drag.selection;
                  if (selection && selection.length && this.options.dragNodes === true) {
                    this.selectionHandler._generateClickEvent("dragging", event, pointer);
                    var deltaX = pointer.x - this.drag.pointer.x;
                    var deltaY = pointer.y - this.drag.pointer.y;
                    selection.forEach(function(selection2) {
                      var node = selection2.node;
                      if (selection2.xFixed === false) {
                        node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection2.x) + deltaX);
                      }
                      if (selection2.yFixed === false) {
                        node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection2.y) + deltaY);
                      }
                    });
                    this.body.emitter.emit("startSimulation");
                  } else {
                    if (this.options.dragView === true) {
                      this.selectionHandler._generateClickEvent("dragging", event, pointer, void 0, true);
                      if (this.drag.pointer === void 0) {
                        this.onDragStart(event);
                        return;
                      }
                      var diffX = pointer.x - this.drag.pointer.x;
                      var diffY = pointer.y - this.drag.pointer.y;
                      this.body.view.translation = {
                        x: this.drag.translation.x + diffX,
                        y: this.drag.translation.y + diffY
                      };
                      this.body.emitter.emit("_requestRedraw");
                    }
                  }
                }
              }, {
                key: "onDragEnd",
                value: function onDragEnd(event) {
                  this.drag.dragging = false;
                  var selection = this.drag.selection;
                  if (selection && selection.length) {
                    selection.forEach(function(s) {
                      s.node.options.fixed.x = s.xFixed;
                      s.node.options.fixed.y = s.yFixed;
                    });
                    this.selectionHandler._generateClickEvent("dragEnd", event, this.getPointer(event.center));
                    this.body.emitter.emit("startSimulation");
                  } else {
                    this.selectionHandler._generateClickEvent("dragEnd", event, this.getPointer(event.center), void 0, true);
                    this.body.emitter.emit("_requestRedraw");
                  }
                }
              }, {
                key: "onPinch",
                value: function onPinch(event) {
                  var pointer = this.getPointer(event.center);
                  this.drag.pinched = true;
                  if (this.pinch["scale"] === void 0) {
                    this.pinch.scale = 1;
                  }
                  var scale = this.pinch.scale * event.scale;
                  this.zoom(scale, pointer);
                }
              }, {
                key: "zoom",
                value: function zoom(scale, pointer) {
                  if (this.options.zoomView === true) {
                    var scaleOld = this.body.view.scale;
                    if (scale < 1e-5) {
                      scale = 1e-5;
                    }
                    if (scale > 10) {
                      scale = 10;
                    }
                    var preScaleDragPointer = void 0;
                    if (this.drag !== void 0) {
                      if (this.drag.dragging === true) {
                        preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
                      }
                    }
                    var translation = this.body.view.translation;
                    var scaleFrac = scale / scaleOld;
                    var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
                    var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;
                    this.body.view.scale = scale;
                    this.body.view.translation = { x: tx, y: ty };
                    if (preScaleDragPointer != void 0) {
                      var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
                      this.drag.pointer.x = postScaleDragPointer.x;
                      this.drag.pointer.y = postScaleDragPointer.y;
                    }
                    this.body.emitter.emit("_requestRedraw");
                    if (scaleOld < scale) {
                      this.body.emitter.emit("zoom", {
                        direction: "+",
                        scale: this.body.view.scale,
                        pointer
                      });
                    } else {
                      this.body.emitter.emit("zoom", {
                        direction: "-",
                        scale: this.body.view.scale,
                        pointer
                      });
                    }
                  }
                }
              }, {
                key: "onMouseWheel",
                value: function onMouseWheel(event) {
                  if (this.options.zoomView === true) {
                    var delta = 0;
                    if (event.wheelDelta) {
                      delta = event.wheelDelta / 120;
                    } else if (event.detail) {
                      delta = -event.detail / 3;
                    }
                    if (delta !== 0) {
                      var scale = this.body.view.scale;
                      var zoom = delta * (this.options.zoomSpeed / 10);
                      if (delta < 0) {
                        zoom = zoom / (1 - zoom);
                      }
                      scale *= 1 + zoom;
                      var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
                      this.zoom(scale, pointer);
                    }
                    event.preventDefault();
                  }
                }
              }, {
                key: "onMouseMove",
                value: function onMouseMove(event) {
                  var _this3 = this;
                  var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
                  var popupVisible = false;
                  if (this.popup !== void 0) {
                    if (this.popup.hidden === false) {
                      this._checkHidePopup(pointer);
                    }
                    if (this.popup.hidden === false) {
                      popupVisible = true;
                      this.popup.setPosition(pointer.x + 3, pointer.y - 5);
                      this.popup.show();
                    }
                  }
                  if (this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
                    this.canvas.frame.focus();
                  }
                  if (popupVisible === false) {
                    if (this.popupTimer !== void 0) {
                      clearInterval(this.popupTimer);
                      this.popupTimer = void 0;
                    }
                    if (!this.drag.dragging) {
                      this.popupTimer = setTimeout(function() {
                        return _this3._checkShowPopup(pointer);
                      }, this.options.tooltipDelay);
                    }
                  }
                  if (this.options.hover === true) {
                    this.selectionHandler.hoverObject(event, pointer);
                  }
                }
              }, {
                key: "_checkShowPopup",
                value: function _checkShowPopup(pointer) {
                  var x = this.canvas._XconvertDOMtoCanvas(pointer.x);
                  var y = this.canvas._YconvertDOMtoCanvas(pointer.y);
                  var pointerObj = {
                    left: x,
                    top: y,
                    right: x,
                    bottom: y
                  };
                  var previousPopupObjId = this.popupObj === void 0 ? void 0 : this.popupObj.id;
                  var nodeUnderCursor = false;
                  var popupType = "node";
                  if (this.popupObj === void 0) {
                    var nodeIndices = this.body.nodeIndices;
                    var nodes2 = this.body.nodes;
                    var node = void 0;
                    var overlappingNodes = [];
                    for (var i = 0; i < nodeIndices.length; i++) {
                      node = nodes2[nodeIndices[i]];
                      if (node.isOverlappingWith(pointerObj) === true) {
                        nodeUnderCursor = true;
                        if (node.getTitle() !== void 0) {
                          overlappingNodes.push(nodeIndices[i]);
                        }
                      }
                    }
                    if (overlappingNodes.length > 0) {
                      this.popupObj = nodes2[overlappingNodes[overlappingNodes.length - 1]];
                      nodeUnderCursor = true;
                    }
                  }
                  if (this.popupObj === void 0 && nodeUnderCursor === false) {
                    var edgeIndices = this.body.edgeIndices;
                    var edges2 = this.body.edges;
                    var edge = void 0;
                    var overlappingEdges = [];
                    for (var _i = 0; _i < edgeIndices.length; _i++) {
                      edge = edges2[edgeIndices[_i]];
                      if (edge.isOverlappingWith(pointerObj) === true) {
                        if (edge.connected === true && edge.getTitle() !== void 0) {
                          overlappingEdges.push(edgeIndices[_i]);
                        }
                      }
                    }
                    if (overlappingEdges.length > 0) {
                      this.popupObj = edges2[overlappingEdges[overlappingEdges.length - 1]];
                      popupType = "edge";
                    }
                  }
                  if (this.popupObj !== void 0) {
                    if (this.popupObj.id !== previousPopupObjId) {
                      if (this.popup === void 0) {
                        this.popup = new Popup(this.canvas.frame);
                      }
                      this.popup.popupTargetType = popupType;
                      this.popup.popupTargetId = this.popupObj.id;
                      this.popup.setPosition(pointer.x + 3, pointer.y - 5);
                      this.popup.setText(this.popupObj.getTitle());
                      this.popup.show();
                      this.body.emitter.emit("showPopup", this.popupObj.id);
                    }
                  } else {
                    if (this.popup !== void 0) {
                      this.popup.hide();
                      this.body.emitter.emit("hidePopup");
                    }
                  }
                }
              }, {
                key: "_checkHidePopup",
                value: function _checkHidePopup(pointer) {
                  var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
                  var stillOnObj = false;
                  if (this.popup.popupTargetType === "node") {
                    if (this.body.nodes[this.popup.popupTargetId] !== void 0) {
                      stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);
                      if (stillOnObj === true) {
                        var overNode = this.selectionHandler.getNodeAt(pointer);
                        stillOnObj = overNode === void 0 ? false : overNode.id === this.popup.popupTargetId;
                      }
                    }
                  } else {
                    if (this.selectionHandler.getNodeAt(pointer) === void 0) {
                      if (this.body.edges[this.popup.popupTargetId] !== void 0) {
                        stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
                      }
                    }
                  }
                  if (stillOnObj === false) {
                    this.popupObj = void 0;
                    this.popup.hide();
                    this.body.emitter.emit("hidePopup");
                  }
                }
              }]);
              return InteractionHandler2;
            }();
            exports2["default"] = InteractionHandler;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hammer = __webpack_require__(24);
            var hammerUtil = __webpack_require__(36);
            var keycharm = __webpack_require__(52);
            var NavigationHandler = function() {
              function NavigationHandler2(body, canvas) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, NavigationHandler2);
                this.body = body;
                this.canvas = canvas;
                this.iconsCreated = false;
                this.navigationHammers = [];
                this.boundFunctions = {};
                this.touchTime = 0;
                this.activated = false;
                this.body.emitter.on("activate", function() {
                  _this.activated = true;
                  _this.configureKeyboardBindings();
                });
                this.body.emitter.on("deactivate", function() {
                  _this.activated = false;
                  _this.configureKeyboardBindings();
                });
                this.body.emitter.on("destroy", function() {
                  if (_this.keycharm !== void 0) {
                    _this.keycharm.destroy();
                  }
                });
                this.options = {};
              }
              (0, _createClass3["default"])(NavigationHandler2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    this.options = options;
                    this.create();
                  }
                }
              }, {
                key: "create",
                value: function create() {
                  if (this.options.navigationButtons === true) {
                    if (this.iconsCreated === false) {
                      this.loadNavigationElements();
                    }
                  } else if (this.iconsCreated === true) {
                    this.cleanNavigation();
                  }
                  this.configureKeyboardBindings();
                }
              }, {
                key: "cleanNavigation",
                value: function cleanNavigation() {
                  if (this.navigationHammers.length != 0) {
                    for (var i = 0; i < this.navigationHammers.length; i++) {
                      this.navigationHammers[i].destroy();
                    }
                    this.navigationHammers = [];
                  }
                  if (this.navigationDOM && this.navigationDOM["wrapper"] && this.navigationDOM["wrapper"].parentNode) {
                    this.navigationDOM["wrapper"].parentNode.removeChild(this.navigationDOM["wrapper"]);
                  }
                  this.iconsCreated = false;
                }
              }, {
                key: "loadNavigationElements",
                value: function loadNavigationElements() {
                  var _this2 = this;
                  this.cleanNavigation();
                  this.navigationDOM = {};
                  var navigationDivs = ["up", "down", "left", "right", "zoomIn", "zoomOut", "zoomExtends"];
                  var navigationDivActions = ["_moveUp", "_moveDown", "_moveLeft", "_moveRight", "_zoomIn", "_zoomOut", "_fit"];
                  this.navigationDOM["wrapper"] = document.createElement("div");
                  this.navigationDOM["wrapper"].className = "vis-navigation";
                  this.canvas.frame.appendChild(this.navigationDOM["wrapper"]);
                  for (var i = 0; i < navigationDivs.length; i++) {
                    this.navigationDOM[navigationDivs[i]] = document.createElement("div");
                    this.navigationDOM[navigationDivs[i]].className = "vis-button vis-" + navigationDivs[i];
                    this.navigationDOM["wrapper"].appendChild(this.navigationDOM[navigationDivs[i]]);
                    var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);
                    if (navigationDivActions[i] === "_fit") {
                      hammerUtil.onTouch(hammer, this._fit.bind(this));
                    } else {
                      hammerUtil.onTouch(hammer, this.bindToRedraw.bind(this, navigationDivActions[i]));
                    }
                    this.navigationHammers.push(hammer);
                  }
                  var hammerFrame = new Hammer(this.canvas.frame);
                  hammerUtil.onRelease(hammerFrame, function() {
                    _this2._stopMovement();
                  });
                  this.navigationHammers.push(hammerFrame);
                  this.iconsCreated = true;
                }
              }, {
                key: "bindToRedraw",
                value: function bindToRedraw(action) {
                  if (this.boundFunctions[action] === void 0) {
                    this.boundFunctions[action] = this[action].bind(this);
                    this.body.emitter.on("initRedraw", this.boundFunctions[action]);
                    this.body.emitter.emit("_startRendering");
                  }
                }
              }, {
                key: "unbindFromRedraw",
                value: function unbindFromRedraw(action) {
                  if (this.boundFunctions[action] !== void 0) {
                    this.body.emitter.off("initRedraw", this.boundFunctions[action]);
                    this.body.emitter.emit("_stopRendering");
                    delete this.boundFunctions[action];
                  }
                }
              }, {
                key: "_fit",
                value: function _fit() {
                  if (new Date().valueOf() - this.touchTime > 700) {
                    this.body.emitter.emit("fit", { duration: 700 });
                    this.touchTime = new Date().valueOf();
                  }
                }
              }, {
                key: "_stopMovement",
                value: function _stopMovement() {
                  for (var boundAction in this.boundFunctions) {
                    if (this.boundFunctions.hasOwnProperty(boundAction)) {
                      this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
                      this.body.emitter.emit("_stopRendering");
                    }
                  }
                  this.boundFunctions = {};
                }
              }, {
                key: "_moveUp",
                value: function _moveUp() {
                  this.body.view.translation.y += this.options.keyboard.speed.y;
                }
              }, {
                key: "_moveDown",
                value: function _moveDown() {
                  this.body.view.translation.y -= this.options.keyboard.speed.y;
                }
              }, {
                key: "_moveLeft",
                value: function _moveLeft() {
                  this.body.view.translation.x += this.options.keyboard.speed.x;
                }
              }, {
                key: "_moveRight",
                value: function _moveRight() {
                  this.body.view.translation.x -= this.options.keyboard.speed.x;
                }
              }, {
                key: "_zoomIn",
                value: function _zoomIn() {
                  var scaleOld = this.body.view.scale;
                  var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);
                  var translation = this.body.view.translation;
                  var scaleFrac = scale / scaleOld;
                  var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
                  var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
                  this.body.view.scale = scale;
                  this.body.view.translation = { x: tx, y: ty };
                  this.body.emitter.emit("zoom", {
                    direction: "+",
                    scale: this.body.view.scale,
                    pointer: null
                  });
                }
              }, {
                key: "_zoomOut",
                value: function _zoomOut() {
                  var scaleOld = this.body.view.scale;
                  var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);
                  var translation = this.body.view.translation;
                  var scaleFrac = scale / scaleOld;
                  var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
                  var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
                  this.body.view.scale = scale;
                  this.body.view.translation = { x: tx, y: ty };
                  this.body.emitter.emit("zoom", {
                    direction: "-",
                    scale: this.body.view.scale,
                    pointer: null
                  });
                }
              }, {
                key: "configureKeyboardBindings",
                value: function configureKeyboardBindings() {
                  var _this3 = this;
                  if (this.keycharm !== void 0) {
                    this.keycharm.destroy();
                  }
                  if (this.options.keyboard.enabled === true) {
                    if (this.options.keyboard.bindToWindow === true) {
                      this.keycharm = keycharm({ container: window, preventDefault: true });
                    } else {
                      this.keycharm = keycharm({
                        container: this.canvas.frame,
                        preventDefault: true
                      });
                    }
                    this.keycharm.reset();
                    if (this.activated === true) {
                      this.keycharm.bind("up", function() {
                        _this3.bindToRedraw("_moveUp");
                      }, "keydown");
                      this.keycharm.bind("down", function() {
                        _this3.bindToRedraw("_moveDown");
                      }, "keydown");
                      this.keycharm.bind("left", function() {
                        _this3.bindToRedraw("_moveLeft");
                      }, "keydown");
                      this.keycharm.bind("right", function() {
                        _this3.bindToRedraw("_moveRight");
                      }, "keydown");
                      this.keycharm.bind("=", function() {
                        _this3.bindToRedraw("_zoomIn");
                      }, "keydown");
                      this.keycharm.bind("num+", function() {
                        _this3.bindToRedraw("_zoomIn");
                      }, "keydown");
                      this.keycharm.bind("num-", function() {
                        _this3.bindToRedraw("_zoomOut");
                      }, "keydown");
                      this.keycharm.bind("-", function() {
                        _this3.bindToRedraw("_zoomOut");
                      }, "keydown");
                      this.keycharm.bind("[", function() {
                        _this3.bindToRedraw("_zoomOut");
                      }, "keydown");
                      this.keycharm.bind("]", function() {
                        _this3.bindToRedraw("_zoomIn");
                      }, "keydown");
                      this.keycharm.bind("pageup", function() {
                        _this3.bindToRedraw("_zoomIn");
                      }, "keydown");
                      this.keycharm.bind("pagedown", function() {
                        _this3.bindToRedraw("_zoomOut");
                      }, "keydown");
                      this.keycharm.bind("up", function() {
                        _this3.unbindFromRedraw("_moveUp");
                      }, "keyup");
                      this.keycharm.bind("down", function() {
                        _this3.unbindFromRedraw("_moveDown");
                      }, "keyup");
                      this.keycharm.bind("left", function() {
                        _this3.unbindFromRedraw("_moveLeft");
                      }, "keyup");
                      this.keycharm.bind("right", function() {
                        _this3.unbindFromRedraw("_moveRight");
                      }, "keyup");
                      this.keycharm.bind("=", function() {
                        _this3.unbindFromRedraw("_zoomIn");
                      }, "keyup");
                      this.keycharm.bind("num+", function() {
                        _this3.unbindFromRedraw("_zoomIn");
                      }, "keyup");
                      this.keycharm.bind("num-", function() {
                        _this3.unbindFromRedraw("_zoomOut");
                      }, "keyup");
                      this.keycharm.bind("-", function() {
                        _this3.unbindFromRedraw("_zoomOut");
                      }, "keyup");
                      this.keycharm.bind("[", function() {
                        _this3.unbindFromRedraw("_zoomOut");
                      }, "keyup");
                      this.keycharm.bind("]", function() {
                        _this3.unbindFromRedraw("_zoomIn");
                      }, "keyup");
                      this.keycharm.bind("pageup", function() {
                        _this3.unbindFromRedraw("_zoomIn");
                      }, "keyup");
                      this.keycharm.bind("pagedown", function() {
                        _this3.unbindFromRedraw("_zoomOut");
                      }, "keyup");
                    }
                  }
                }
              }]);
              return NavigationHandler2;
            }();
            exports2["default"] = NavigationHandler;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Popup = function() {
              function Popup2(container, overflowMethod) {
                (0, _classCallCheck3["default"])(this, Popup2);
                this.container = container;
                this.overflowMethod = overflowMethod || "cap";
                this.x = 0;
                this.y = 0;
                this.padding = 5;
                this.hidden = false;
                this.frame = document.createElement("div");
                this.frame.className = "vis-tooltip";
                this.container.appendChild(this.frame);
              }
              (0, _createClass3["default"])(Popup2, [{
                key: "setPosition",
                value: function setPosition(x, y) {
                  this.x = parseInt(x);
                  this.y = parseInt(y);
                }
              }, {
                key: "setText",
                value: function setText(content) {
                  if (content instanceof Element) {
                    this.frame.innerHTML = "";
                    this.frame.appendChild(content);
                  } else {
                    this.frame.innerHTML = content;
                  }
                }
              }, {
                key: "show",
                value: function show2(doShow) {
                  if (doShow === void 0) {
                    doShow = true;
                  }
                  if (doShow === true) {
                    var height = this.frame.clientHeight;
                    var width = this.frame.clientWidth;
                    var maxHeight = this.frame.parentNode.clientHeight;
                    var maxWidth = this.frame.parentNode.clientWidth;
                    var left = 0, top = 0;
                    if (this.overflowMethod == "flip") {
                      var isLeft = false, isTop = true;
                      if (this.y - height < this.padding) {
                        isTop = false;
                      }
                      if (this.x + width > maxWidth - this.padding) {
                        isLeft = true;
                      }
                      if (isLeft) {
                        left = this.x - width;
                      } else {
                        left = this.x;
                      }
                      if (isTop) {
                        top = this.y - height;
                      } else {
                        top = this.y;
                      }
                    } else {
                      top = this.y - height;
                      if (top + height + this.padding > maxHeight) {
                        top = maxHeight - height - this.padding;
                      }
                      if (top < this.padding) {
                        top = this.padding;
                      }
                      left = this.x;
                      if (left + width + this.padding > maxWidth) {
                        left = maxWidth - width - this.padding;
                      }
                      if (left < this.padding) {
                        left = this.padding;
                      }
                    }
                    this.frame.style.left = left + "px";
                    this.frame.style.top = top + "px";
                    this.frame.style.visibility = "visible";
                    this.hidden = false;
                  } else {
                    this.hide();
                  }
                }
              }, {
                key: "hide",
                value: function hide3() {
                  this.hidden = true;
                  this.frame.style.left = "0";
                  this.frame.style.top = "0";
                  this.frame.style.visibility = "hidden";
                }
              }, {
                key: "destroy",
                value: function destroy2() {
                  this.frame.parentNode.removeChild(this.frame);
                }
              }]);
              return Popup2;
            }();
            exports2["default"] = Popup;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _keys = __webpack_require__(9);
            var _keys2 = _interopRequireDefault(_keys);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Node = __webpack_require__(34)["default"];
            var Edge = __webpack_require__(55)["default"];
            var util = __webpack_require__(2);
            var SelectionHandler = function() {
              function SelectionHandler2(body, canvas) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, SelectionHandler2);
                this.body = body;
                this.canvas = canvas;
                this.selectionObj = { nodes: [], edges: [] };
                this.hoverObj = { nodes: {}, edges: {} };
                this.options = {};
                this.defaultOptions = {
                  multiselect: false,
                  selectable: true,
                  selectConnectedEdges: true,
                  hoverConnectedEdges: true
                };
                util.extend(this.options, this.defaultOptions);
                this.body.emitter.on("_dataChanged", function() {
                  _this.updateSelection();
                });
              }
              (0, _createClass3["default"])(SelectionHandler2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    var fields = ["multiselect", "hoverConnectedEdges", "selectable", "selectConnectedEdges"];
                    util.selectiveDeepExtend(fields, this.options, options);
                  }
                }
              }, {
                key: "selectOnPoint",
                value: function selectOnPoint(pointer) {
                  var selected = false;
                  if (this.options.selectable === true) {
                    var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);
                    this.unselectAll();
                    if (obj !== void 0) {
                      selected = this.selectObject(obj);
                    }
                    this.body.emitter.emit("_requestRedraw");
                  }
                  return selected;
                }
              }, {
                key: "selectAdditionalOnPoint",
                value: function selectAdditionalOnPoint(pointer) {
                  var selectionChanged = false;
                  if (this.options.selectable === true) {
                    var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);
                    if (obj !== void 0) {
                      selectionChanged = true;
                      if (obj.isSelected() === true) {
                        this.deselectObject(obj);
                      } else {
                        this.selectObject(obj);
                      }
                      this.body.emitter.emit("_requestRedraw");
                    }
                  }
                  return selectionChanged;
                }
              }, {
                key: "_initBaseEvent",
                value: function _initBaseEvent(event, pointer) {
                  var properties = {};
                  properties["pointer"] = {
                    DOM: { x: pointer.x, y: pointer.y },
                    canvas: this.canvas.DOMtoCanvas(pointer)
                  };
                  properties["event"] = event;
                  return properties;
                }
              }, {
                key: "_generateClickEvent",
                value: function _generateClickEvent(eventType, event, pointer, oldSelection) {
                  var emptySelection = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                  var properties = this._initBaseEvent(event, pointer);
                  if (emptySelection === true) {
                    properties.nodes = [];
                    properties.edges = [];
                  } else {
                    var tmp = this.getSelection();
                    properties.nodes = tmp.nodes;
                    properties.edges = tmp.edges;
                  }
                  if (oldSelection !== void 0) {
                    properties["previousSelection"] = oldSelection;
                  }
                  if (eventType == "click") {
                    properties.items = this.getClickedItems(pointer);
                  }
                  if (event.controlEdge !== void 0) {
                    properties.controlEdge = event.controlEdge;
                  }
                  this.body.emitter.emit(eventType, properties);
                }
              }, {
                key: "selectObject",
                value: function selectObject(obj) {
                  var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.selectConnectedEdges;
                  if (obj !== void 0) {
                    if (obj instanceof Node) {
                      if (highlightEdges === true) {
                        this._selectConnectedEdges(obj);
                      }
                    }
                    obj.select();
                    this._addToSelection(obj);
                    return true;
                  }
                  return false;
                }
              }, {
                key: "deselectObject",
                value: function deselectObject(obj) {
                  if (obj.isSelected() === true) {
                    obj.selected = false;
                    this._removeFromSelection(obj);
                  }
                }
              }, {
                key: "_getAllNodesOverlappingWith",
                value: function _getAllNodesOverlappingWith(object) {
                  var overlappingNodes = [];
                  var nodes2 = this.body.nodes;
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var nodeId = this.body.nodeIndices[i];
                    if (nodes2[nodeId].isOverlappingWith(object)) {
                      overlappingNodes.push(nodeId);
                    }
                  }
                  return overlappingNodes;
                }
              }, {
                key: "_pointerToPositionObject",
                value: function _pointerToPositionObject(pointer) {
                  var canvasPos = this.canvas.DOMtoCanvas(pointer);
                  return {
                    left: canvasPos.x - 1,
                    top: canvasPos.y + 1,
                    right: canvasPos.x + 1,
                    bottom: canvasPos.y - 1
                  };
                }
              }, {
                key: "getNodeAt",
                value: function getNodeAt(pointer) {
                  var returnNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  var positionObject = this._pointerToPositionObject(pointer);
                  var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);
                  if (overlappingNodes.length > 0) {
                    if (returnNode === true) {
                      return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
                    } else {
                      return overlappingNodes[overlappingNodes.length - 1];
                    }
                  } else {
                    return void 0;
                  }
                }
              }, {
                key: "_getEdgesOverlappingWith",
                value: function _getEdgesOverlappingWith(object, overlappingEdges) {
                  var edges2 = this.body.edges;
                  for (var i = 0; i < this.body.edgeIndices.length; i++) {
                    var edgeId = this.body.edgeIndices[i];
                    if (edges2[edgeId].isOverlappingWith(object)) {
                      overlappingEdges.push(edgeId);
                    }
                  }
                }
              }, {
                key: "_getAllEdgesOverlappingWith",
                value: function _getAllEdgesOverlappingWith(object) {
                  var overlappingEdges = [];
                  this._getEdgesOverlappingWith(object, overlappingEdges);
                  return overlappingEdges;
                }
              }, {
                key: "getEdgeAt",
                value: function getEdgeAt(pointer) {
                  var returnEdge = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  var canvasPos = this.canvas.DOMtoCanvas(pointer);
                  var mindist = 10;
                  var overlappingEdge = null;
                  var edges2 = this.body.edges;
                  for (var i = 0; i < this.body.edgeIndices.length; i++) {
                    var edgeId = this.body.edgeIndices[i];
                    var edge = edges2[edgeId];
                    if (edge.connected) {
                      var xFrom = edge.from.x;
                      var yFrom = edge.from.y;
                      var xTo = edge.to.x;
                      var yTo = edge.to.y;
                      var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);
                      if (dist < mindist) {
                        overlappingEdge = edgeId;
                        mindist = dist;
                      }
                    }
                  }
                  if (overlappingEdge !== null) {
                    if (returnEdge === true) {
                      return this.body.edges[overlappingEdge];
                    } else {
                      return overlappingEdge;
                    }
                  } else {
                    return void 0;
                  }
                }
              }, {
                key: "_addToSelection",
                value: function _addToSelection(obj) {
                  if (obj instanceof Node) {
                    this.selectionObj.nodes[obj.id] = obj;
                  } else {
                    this.selectionObj.edges[obj.id] = obj;
                  }
                }
              }, {
                key: "_addToHover",
                value: function _addToHover(obj) {
                  if (obj instanceof Node) {
                    this.hoverObj.nodes[obj.id] = obj;
                  } else {
                    this.hoverObj.edges[obj.id] = obj;
                  }
                }
              }, {
                key: "_removeFromSelection",
                value: function _removeFromSelection(obj) {
                  if (obj instanceof Node) {
                    delete this.selectionObj.nodes[obj.id];
                    this._unselectConnectedEdges(obj);
                  } else {
                    delete this.selectionObj.edges[obj.id];
                  }
                }
              }, {
                key: "unselectAll",
                value: function unselectAll() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      this.selectionObj.nodes[nodeId].unselect();
                    }
                  }
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      this.selectionObj.edges[edgeId].unselect();
                    }
                  }
                  this.selectionObj = { nodes: {}, edges: {} };
                }
              }, {
                key: "_getSelectedNodeCount",
                value: function _getSelectedNodeCount() {
                  var count = 0;
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      count += 1;
                    }
                  }
                  return count;
                }
              }, {
                key: "_getSelectedNode",
                value: function _getSelectedNode() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      return this.selectionObj.nodes[nodeId];
                    }
                  }
                  return void 0;
                }
              }, {
                key: "_getSelectedEdge",
                value: function _getSelectedEdge() {
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      return this.selectionObj.edges[edgeId];
                    }
                  }
                  return void 0;
                }
              }, {
                key: "_getSelectedEdgeCount",
                value: function _getSelectedEdgeCount() {
                  var count = 0;
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      count += 1;
                    }
                  }
                  return count;
                }
              }, {
                key: "_getSelectedObjectCount",
                value: function _getSelectedObjectCount() {
                  var count = 0;
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      count += 1;
                    }
                  }
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      count += 1;
                    }
                  }
                  return count;
                }
              }, {
                key: "_selectionIsEmpty",
                value: function _selectionIsEmpty() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      return false;
                    }
                  }
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      return false;
                    }
                  }
                  return true;
                }
              }, {
                key: "_clusterInSelection",
                value: function _clusterInSelection() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      if (this.selectionObj.nodes[nodeId].clusterSize > 1) {
                        return true;
                      }
                    }
                  }
                  return false;
                }
              }, {
                key: "_selectConnectedEdges",
                value: function _selectConnectedEdges(node) {
                  for (var i = 0; i < node.edges.length; i++) {
                    var edge = node.edges[i];
                    edge.select();
                    this._addToSelection(edge);
                  }
                }
              }, {
                key: "_hoverConnectedEdges",
                value: function _hoverConnectedEdges(node) {
                  for (var i = 0; i < node.edges.length; i++) {
                    var edge = node.edges[i];
                    edge.hover = true;
                    this._addToHover(edge);
                  }
                }
              }, {
                key: "_unselectConnectedEdges",
                value: function _unselectConnectedEdges(node) {
                  for (var i = 0; i < node.edges.length; i++) {
                    var edge = node.edges[i];
                    edge.unselect();
                    this._removeFromSelection(edge);
                  }
                }
              }, {
                key: "emitBlurEvent",
                value: function emitBlurEvent(event, pointer, object) {
                  var properties = this._initBaseEvent(event, pointer);
                  if (object.hover === true) {
                    object.hover = false;
                    if (object instanceof Node) {
                      properties.node = object.id;
                      this.body.emitter.emit("blurNode", properties);
                    } else {
                      properties.edge = object.id;
                      this.body.emitter.emit("blurEdge", properties);
                    }
                  }
                }
              }, {
                key: "emitHoverEvent",
                value: function emitHoverEvent(event, pointer, object) {
                  var properties = this._initBaseEvent(event, pointer);
                  var hoverChanged = false;
                  if (object.hover === false) {
                    object.hover = true;
                    this._addToHover(object);
                    hoverChanged = true;
                    if (object instanceof Node) {
                      properties.node = object.id;
                      this.body.emitter.emit("hoverNode", properties);
                    } else {
                      properties.edge = object.id;
                      this.body.emitter.emit("hoverEdge", properties);
                    }
                  }
                  return hoverChanged;
                }
              }, {
                key: "hoverObject",
                value: function hoverObject(event, pointer) {
                  var object = this.getNodeAt(pointer);
                  if (object === void 0) {
                    object = this.getEdgeAt(pointer);
                  }
                  var hoverChanged = false;
                  for (var nodeId in this.hoverObj.nodes) {
                    if (this.hoverObj.nodes.hasOwnProperty(nodeId)) {
                      if (object === void 0 || object instanceof Node && object.id != nodeId || object instanceof Edge) {
                        this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);
                        delete this.hoverObj.nodes[nodeId];
                        hoverChanged = true;
                      }
                    }
                  }
                  for (var edgeId in this.hoverObj.edges) {
                    if (this.hoverObj.edges.hasOwnProperty(edgeId)) {
                      if (hoverChanged === true) {
                        this.hoverObj.edges[edgeId].hover = false;
                        delete this.hoverObj.edges[edgeId];
                      } else if (object === void 0 || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {
                        this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);
                        delete this.hoverObj.edges[edgeId];
                        hoverChanged = true;
                      }
                    }
                  }
                  if (object !== void 0) {
                    var hoveredEdgesCount = (0, _keys2["default"])(this.hoverObj.edges).length;
                    var hoveredNodesCount = (0, _keys2["default"])(this.hoverObj.nodes).length;
                    var newOnlyHoveredEdge = object instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;
                    var newOnlyHoveredNode = object instanceof Node && hoveredEdgesCount === 0 && hoveredNodesCount === 0;
                    if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {
                      hoverChanged = this.emitHoverEvent(event, pointer, object);
                    }
                    if (object instanceof Node && this.options.hoverConnectedEdges === true) {
                      this._hoverConnectedEdges(object);
                    }
                  }
                  if (hoverChanged === true) {
                    this.body.emitter.emit("_requestRedraw");
                  }
                }
              }, {
                key: "getSelection",
                value: function getSelection() {
                  var nodeIds = this.getSelectedNodes();
                  var edgeIds = this.getSelectedEdges();
                  return { nodes: nodeIds, edges: edgeIds };
                }
              }, {
                key: "getSelectedNodes",
                value: function getSelectedNodes() {
                  var idArray = [];
                  if (this.options.selectable === true) {
                    for (var nodeId in this.selectionObj.nodes) {
                      if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                        idArray.push(this.selectionObj.nodes[nodeId].id);
                      }
                    }
                  }
                  return idArray;
                }
              }, {
                key: "getSelectedEdges",
                value: function getSelectedEdges() {
                  var idArray = [];
                  if (this.options.selectable === true) {
                    for (var edgeId in this.selectionObj.edges) {
                      if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                        idArray.push(this.selectionObj.edges[edgeId].id);
                      }
                    }
                  }
                  return idArray;
                }
              }, {
                key: "setSelection",
                value: function setSelection(selection) {
                  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  var i = void 0, id2 = void 0;
                  if (!selection || !selection.nodes && !selection.edges)
                    throw "Selection must be an object with nodes and/or edges properties";
                  if (options.unselectAll || options.unselectAll === void 0) {
                    this.unselectAll();
                  }
                  if (selection.nodes) {
                    for (i = 0; i < selection.nodes.length; i++) {
                      id2 = selection.nodes[i];
                      var node = this.body.nodes[id2];
                      if (!node) {
                        throw new RangeError('Node with id "' + id2 + '" not found');
                      }
                      this.selectObject(node, options.highlightEdges);
                    }
                  }
                  if (selection.edges) {
                    for (i = 0; i < selection.edges.length; i++) {
                      id2 = selection.edges[i];
                      var edge = this.body.edges[id2];
                      if (!edge) {
                        throw new RangeError('Edge with id "' + id2 + '" not found');
                      }
                      this.selectObject(edge);
                    }
                  }
                  this.body.emitter.emit("_requestRedraw");
                }
              }, {
                key: "selectNodes",
                value: function selectNodes(selection) {
                  var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (!selection || selection.length === void 0)
                    throw "Selection must be an array with ids";
                  this.setSelection({ nodes: selection }, { highlightEdges });
                }
              }, {
                key: "selectEdges",
                value: function selectEdges(selection) {
                  if (!selection || selection.length === void 0)
                    throw "Selection must be an array with ids";
                  this.setSelection({ edges: selection });
                }
              }, {
                key: "updateSelection",
                value: function updateSelection() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      if (!this.body.nodes.hasOwnProperty(nodeId)) {
                        delete this.selectionObj.nodes[nodeId];
                      }
                    }
                  }
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      if (!this.body.edges.hasOwnProperty(edgeId)) {
                        delete this.selectionObj.edges[edgeId];
                      }
                    }
                  }
                }
              }, {
                key: "getClickedItems",
                value: function getClickedItems(pointer) {
                  var point = this.canvas.DOMtoCanvas(pointer);
                  var items = [];
                  var nodeIndices = this.body.nodeIndices;
                  var nodes2 = this.body.nodes;
                  for (var i = nodeIndices.length - 1; i >= 0; i--) {
                    var node = nodes2[nodeIndices[i]];
                    var ret = node.getItemsOnPoint(point);
                    items.push.apply(items, ret);
                  }
                  var edgeIndices = this.body.edgeIndices;
                  var edges2 = this.body.edges;
                  for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {
                    var edge = edges2[edgeIndices[_i]];
                    var _ret = edge.getItemsOnPoint(point);
                    items.push.apply(items, _ret);
                  }
                  return items;
                }
              }]);
              return SelectionHandler2;
            }();
            exports2["default"] = SelectionHandler;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(15);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _keys = __webpack_require__(9);
            var _keys2 = _interopRequireDefault(_keys);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var TimSort = __webpack_require__(83);
            var util = __webpack_require__(2);
            var NetworkUtil = __webpack_require__(57)["default"];
            var _require = __webpack_require__(189), HorizontalStrategy = _require.HorizontalStrategy, VerticalStrategy = _require.VerticalStrategy;
            var HierarchicalStatus = function() {
              function HierarchicalStatus2() {
                (0, _classCallCheck3["default"])(this, HierarchicalStatus2);
                this.childrenReference = {};
                this.parentReference = {};
                this.trees = {};
                this.distributionOrdering = {};
                this.levels = {};
                this.distributionIndex = {};
                this.isTree = false;
                this.treeIndex = -1;
              }
              (0, _createClass3["default"])(HierarchicalStatus2, [{
                key: "addRelation",
                value: function addRelation(parentNodeId, childNodeId) {
                  if (this.childrenReference[parentNodeId] === void 0) {
                    this.childrenReference[parentNodeId] = [];
                  }
                  this.childrenReference[parentNodeId].push(childNodeId);
                  if (this.parentReference[childNodeId] === void 0) {
                    this.parentReference[childNodeId] = [];
                  }
                  this.parentReference[childNodeId].push(parentNodeId);
                }
              }, {
                key: "checkIfTree",
                value: function checkIfTree() {
                  for (var i in this.parentReference) {
                    if (this.parentReference[i].length > 1) {
                      this.isTree = false;
                      return;
                    }
                  }
                  this.isTree = true;
                }
              }, {
                key: "numTrees",
                value: function numTrees() {
                  return this.treeIndex + 1;
                }
              }, {
                key: "setTreeIndex",
                value: function setTreeIndex(node, treeId) {
                  if (treeId === void 0)
                    return;
                  if (this.trees[node.id] === void 0) {
                    this.trees[node.id] = treeId;
                    this.treeIndex = Math.max(treeId, this.treeIndex);
                  }
                }
              }, {
                key: "ensureLevel",
                value: function ensureLevel(nodeId) {
                  if (this.levels[nodeId] === void 0) {
                    this.levels[nodeId] = 0;
                  }
                }
              }, {
                key: "getMaxLevel",
                value: function getMaxLevel(nodeId) {
                  var _this = this;
                  var accumulator = {};
                  var _getMaxLevel = function _getMaxLevel2(nodeId2) {
                    if (accumulator[nodeId2] !== void 0) {
                      return accumulator[nodeId2];
                    }
                    var level = _this.levels[nodeId2];
                    if (_this.childrenReference[nodeId2]) {
                      var children = _this.childrenReference[nodeId2];
                      if (children.length > 0) {
                        for (var i = 0; i < children.length; i++) {
                          level = Math.max(level, _getMaxLevel2(children[i]));
                        }
                      }
                    }
                    accumulator[nodeId2] = level;
                    return level;
                  };
                  return _getMaxLevel(nodeId);
                }
              }, {
                key: "levelDownstream",
                value: function levelDownstream(nodeA, nodeB) {
                  if (this.levels[nodeB.id] === void 0) {
                    if (this.levels[nodeA.id] === void 0) {
                      this.levels[nodeA.id] = 0;
                    }
                    this.levels[nodeB.id] = this.levels[nodeA.id] + 1;
                  }
                }
              }, {
                key: "setMinLevelToZero",
                value: function setMinLevelToZero(nodes2) {
                  var minLevel = 1e9;
                  for (var nodeId in nodes2) {
                    if (nodes2.hasOwnProperty(nodeId)) {
                      if (this.levels[nodeId] !== void 0) {
                        minLevel = Math.min(this.levels[nodeId], minLevel);
                      }
                    }
                  }
                  for (var _nodeId in nodes2) {
                    if (nodes2.hasOwnProperty(_nodeId)) {
                      if (this.levels[_nodeId] !== void 0) {
                        this.levels[_nodeId] -= minLevel;
                      }
                    }
                  }
                }
              }, {
                key: "getTreeSize",
                value: function getTreeSize(nodes2, index) {
                  var min_x = 1e9;
                  var max_x = -1e9;
                  var min_y = 1e9;
                  var max_y = -1e9;
                  for (var nodeId in this.trees) {
                    if (this.trees.hasOwnProperty(nodeId)) {
                      if (this.trees[nodeId] === index) {
                        var node = nodes2[nodeId];
                        min_x = Math.min(node.x, min_x);
                        max_x = Math.max(node.x, max_x);
                        min_y = Math.min(node.y, min_y);
                        max_y = Math.max(node.y, max_y);
                      }
                    }
                  }
                  return {
                    min_x,
                    max_x,
                    min_y,
                    max_y
                  };
                }
              }, {
                key: "hasSameParent",
                value: function hasSameParent(node1, node2) {
                  var parents1 = this.parentReference[node1.id];
                  var parents2 = this.parentReference[node2.id];
                  if (parents1 === void 0 || parents2 === void 0) {
                    return false;
                  }
                  for (var i = 0; i < parents1.length; i++) {
                    for (var j = 0; j < parents2.length; j++) {
                      if (parents1[i] == parents2[j]) {
                        return true;
                      }
                    }
                  }
                  return false;
                }
              }, {
                key: "inSameSubNetwork",
                value: function inSameSubNetwork(node1, node2) {
                  return this.trees[node1.id] === this.trees[node2.id];
                }
              }, {
                key: "getLevels",
                value: function getLevels() {
                  return (0, _keys2["default"])(this.distributionOrdering);
                }
              }, {
                key: "addToOrdering",
                value: function addToOrdering(node, level) {
                  if (this.distributionOrdering[level] === void 0) {
                    this.distributionOrdering[level] = [];
                  }
                  var isPresent = false;
                  var curLevel = this.distributionOrdering[level];
                  for (var n in curLevel) {
                    if (curLevel[n] === node) {
                      isPresent = true;
                      break;
                    }
                  }
                  if (!isPresent) {
                    this.distributionOrdering[level].push(node);
                    this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
                  }
                }
              }]);
              return HierarchicalStatus2;
            }();
            var LayoutEngine = function() {
              function LayoutEngine2(body) {
                (0, _classCallCheck3["default"])(this, LayoutEngine2);
                this.body = body;
                this.initialRandomSeed = Math.round(Math.random() * 1e6);
                this.randomSeed = this.initialRandomSeed;
                this.setPhysics = false;
                this.options = {};
                this.optionsBackup = { physics: {} };
                this.defaultOptions = {
                  randomSeed: void 0,
                  improvedLayout: true,
                  hierarchical: {
                    enabled: false,
                    levelSeparation: 150,
                    nodeSpacing: 100,
                    treeSpacing: 200,
                    blockShifting: true,
                    edgeMinimization: true,
                    parentCentralization: true,
                    direction: "UD",
                    sortMethod: "hubsize"
                  }
                };
                util.extend(this.options, this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(LayoutEngine2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this2 = this;
                  this.body.emitter.on("_dataChanged", function() {
                    _this2.setupHierarchicalLayout();
                  });
                  this.body.emitter.on("_dataLoaded", function() {
                    _this2.layoutNetwork();
                  });
                  this.body.emitter.on("_resetHierarchicalLayout", function() {
                    _this2.setupHierarchicalLayout();
                  });
                  this.body.emitter.on("_adjustEdgesForHierarchicalLayout", function() {
                    if (_this2.options.hierarchical.enabled !== true) {
                      return;
                    }
                    var type = _this2.direction.curveType();
                    _this2.body.emitter.emit("_forceDisableDynamicCurves", type, false);
                  });
                }
              }, {
                key: "setOptions",
                value: function setOptions(options, allOptions) {
                  if (options !== void 0) {
                    var hierarchical = this.options.hierarchical;
                    var prevHierarchicalState = hierarchical.enabled;
                    util.selectiveDeepExtend(["randomSeed", "improvedLayout"], this.options, options);
                    util.mergeOptions(this.options, options, "hierarchical");
                    if (options.randomSeed !== void 0) {
                      this.initialRandomSeed = options.randomSeed;
                    }
                    if (hierarchical.enabled === true) {
                      if (prevHierarchicalState === true) {
                        this.body.emitter.emit("refresh", true);
                      }
                      if (hierarchical.direction === "RL" || hierarchical.direction === "DU") {
                        if (hierarchical.levelSeparation > 0) {
                          hierarchical.levelSeparation *= -1;
                        }
                      } else {
                        if (hierarchical.levelSeparation < 0) {
                          hierarchical.levelSeparation *= -1;
                        }
                      }
                      this.setDirectionStrategy();
                      this.body.emitter.emit("_resetHierarchicalLayout");
                      return this.adaptAllOptionsForHierarchicalLayout(allOptions);
                    } else {
                      if (prevHierarchicalState === true) {
                        this.body.emitter.emit("refresh");
                        return util.deepExtend(allOptions, this.optionsBackup);
                      }
                    }
                  }
                  return allOptions;
                }
              }, {
                key: "adaptAllOptionsForHierarchicalLayout",
                value: function adaptAllOptionsForHierarchicalLayout(allOptions) {
                  if (this.options.hierarchical.enabled === true) {
                    var backupPhysics = this.optionsBackup.physics;
                    if (allOptions.physics === void 0 || allOptions.physics === true) {
                      allOptions.physics = {
                        enabled: backupPhysics.enabled === void 0 ? true : backupPhysics.enabled,
                        solver: "hierarchicalRepulsion"
                      };
                      backupPhysics.enabled = backupPhysics.enabled === void 0 ? true : backupPhysics.enabled;
                      backupPhysics.solver = backupPhysics.solver || "barnesHut";
                    } else if ((0, _typeof3["default"])(allOptions.physics) === "object") {
                      backupPhysics.enabled = allOptions.physics.enabled === void 0 ? true : allOptions.physics.enabled;
                      backupPhysics.solver = allOptions.physics.solver || "barnesHut";
                      allOptions.physics.solver = "hierarchicalRepulsion";
                    } else if (allOptions.physics !== false) {
                      backupPhysics.solver = "barnesHut";
                      allOptions.physics = { solver: "hierarchicalRepulsion" };
                    }
                    var type = this.direction.curveType();
                    if (allOptions.edges === void 0) {
                      this.optionsBackup.edges = {
                        smooth: { enabled: true, type: "dynamic" }
                      };
                      allOptions.edges = { smooth: false };
                    } else if (allOptions.edges.smooth === void 0) {
                      this.optionsBackup.edges = {
                        smooth: { enabled: true, type: "dynamic" }
                      };
                      allOptions.edges.smooth = false;
                    } else {
                      if (typeof allOptions.edges.smooth === "boolean") {
                        this.optionsBackup.edges = { smooth: allOptions.edges.smooth };
                        allOptions.edges.smooth = {
                          enabled: allOptions.edges.smooth,
                          type
                        };
                      } else {
                        var smooth = allOptions.edges.smooth;
                        if (smooth.type !== void 0 && smooth.type !== "dynamic") {
                          type = smooth.type;
                        }
                        this.optionsBackup.edges = {
                          smooth: smooth.enabled === void 0 ? true : smooth.enabled,
                          type: smooth.type === void 0 ? "dynamic" : smooth.type,
                          roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,
                          forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection
                        };
                        allOptions.edges.smooth = {
                          enabled: smooth.enabled === void 0 ? true : smooth.enabled,
                          type,
                          roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,
                          forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection
                        };
                      }
                    }
                    this.body.emitter.emit("_forceDisableDynamicCurves", type);
                  }
                  return allOptions;
                }
              }, {
                key: "seededRandom",
                value: function seededRandom() {
                  var x = Math.sin(this.randomSeed++) * 1e4;
                  return x - Math.floor(x);
                }
              }, {
                key: "positionInitially",
                value: function positionInitially(nodesArray) {
                  if (this.options.hierarchical.enabled !== true) {
                    this.randomSeed = this.initialRandomSeed;
                    var radius = nodesArray.length + 50;
                    for (var i = 0; i < nodesArray.length; i++) {
                      var node = nodesArray[i];
                      var angle = 2 * Math.PI * this.seededRandom();
                      if (node.x === void 0) {
                        node.x = radius * Math.cos(angle);
                      }
                      if (node.y === void 0) {
                        node.y = radius * Math.sin(angle);
                      }
                    }
                  }
                }
              }, {
                key: "layoutNetwork",
                value: function layoutNetwork() {
                  if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
                    var indices = this.body.nodeIndices;
                    var positionDefined = 0;
                    for (var i = 0; i < indices.length; i++) {
                      var node = this.body.nodes[indices[i]];
                      if (node.predefinedPosition === true) {
                        positionDefined += 1;
                      }
                    }
                    if (positionDefined < 0.5 * indices.length) {
                      var MAX_LEVELS = 10;
                      var level = 0;
                      var clusterThreshold = 150;
                      var clusterOptions = {
                        clusterNodeProperties: {
                          shape: "ellipse",
                          label: "",
                          group: "",
                          font: {
                            multi: false
                          }
                        },
                        clusterEdgeProperties: {
                          label: "",
                          font: { multi: false },
                          smooth: {
                            enabled: false
                          }
                        }
                      };
                      if (indices.length > clusterThreshold) {
                        var startLength = indices.length;
                        while (indices.length > clusterThreshold && level <= MAX_LEVELS) {
                          level += 1;
                          var before = indices.length;
                          if (level % 3 === 0) {
                            this.body.modules.clustering.clusterBridges(clusterOptions);
                          } else {
                            this.body.modules.clustering.clusterOutliers(clusterOptions);
                          }
                          var after = indices.length;
                          if (before == after && level % 3 !== 0) {
                            this._declusterAll();
                            this.body.emitter.emit("_layoutFailed");
                            console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.");
                            return;
                          }
                        }
                        this.body.modules.kamadaKawai.setOptions({
                          springLength: Math.max(150, 2 * startLength)
                        });
                      }
                      if (level > MAX_LEVELS) {
                        console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result.");
                      }
                      this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true);
                      this._shiftToCenter();
                      var offset = 70;
                      for (var _i = 0; _i < indices.length; _i++) {
                        var _node = this.body.nodes[indices[_i]];
                        if (_node.predefinedPosition === false) {
                          _node.x += (0.5 - this.seededRandom()) * offset;
                          _node.y += (0.5 - this.seededRandom()) * offset;
                        }
                      }
                      this._declusterAll();
                      this.body.emitter.emit("_repositionBezierNodes");
                    }
                  }
                }
              }, {
                key: "_shiftToCenter",
                value: function _shiftToCenter() {
                  var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);
                  var center = NetworkUtil.findCenter(range);
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var node = this.body.nodes[this.body.nodeIndices[i]];
                    node.x -= center.x;
                    node.y -= center.y;
                  }
                }
              }, {
                key: "_declusterAll",
                value: function _declusterAll() {
                  var clustersPresent = true;
                  while (clustersPresent === true) {
                    clustersPresent = false;
                    for (var i = 0; i < this.body.nodeIndices.length; i++) {
                      if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
                        clustersPresent = true;
                        this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
                      }
                    }
                    if (clustersPresent === true) {
                      this.body.emitter.emit("_dataChanged");
                    }
                  }
                }
              }, {
                key: "getSeed",
                value: function getSeed() {
                  return this.initialRandomSeed;
                }
              }, {
                key: "setupHierarchicalLayout",
                value: function setupHierarchicalLayout() {
                  if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
                    var node = void 0, nodeId = void 0;
                    var definedLevel = false;
                    var undefinedLevel = false;
                    this.lastNodeOnLevel = {};
                    this.hierarchical = new HierarchicalStatus();
                    for (nodeId in this.body.nodes) {
                      if (this.body.nodes.hasOwnProperty(nodeId)) {
                        node = this.body.nodes[nodeId];
                        if (node.options.level !== void 0) {
                          definedLevel = true;
                          this.hierarchical.levels[nodeId] = node.options.level;
                        } else {
                          undefinedLevel = true;
                        }
                      }
                    }
                    if (undefinedLevel === true && definedLevel === true) {
                      throw new Error("To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.");
                    } else {
                      if (undefinedLevel === true) {
                        var sortMethod = this.options.hierarchical.sortMethod;
                        if (sortMethod === "hubsize") {
                          this._determineLevelsByHubsize();
                        } else if (sortMethod === "directed") {
                          this._determineLevelsDirected();
                        } else if (sortMethod === "custom") {
                          this._determineLevelsCustomCallback();
                        }
                      }
                      for (var _nodeId2 in this.body.nodes) {
                        if (this.body.nodes.hasOwnProperty(_nodeId2)) {
                          this.hierarchical.ensureLevel(_nodeId2);
                        }
                      }
                      var distribution = this._getDistribution();
                      this._generateMap();
                      this._placeNodesByHierarchy(distribution);
                      this._condenseHierarchy();
                      this._shiftToCenter();
                    }
                  }
                }
              }, {
                key: "_condenseHierarchy",
                value: function _condenseHierarchy() {
                  var _this3 = this;
                  var stillShifting = false;
                  var branches = {};
                  var shiftTrees = function shiftTrees2() {
                    var treeSizes = getTreeSizes();
                    var shiftBy = 0;
                    for (var i = 0; i < treeSizes.length - 1; i++) {
                      var diff = treeSizes[i].max - treeSizes[i + 1].min;
                      shiftBy += diff + _this3.options.hierarchical.treeSpacing;
                      shiftTree(i + 1, shiftBy);
                    }
                  };
                  var shiftTree = function shiftTree2(index, offset) {
                    var trees = _this3.hierarchical.trees;
                    for (var nodeId in trees) {
                      if (trees.hasOwnProperty(nodeId)) {
                        if (trees[nodeId] === index) {
                          _this3.direction.shift(nodeId, offset);
                        }
                      }
                    }
                  };
                  var getTreeSizes = function getTreeSizes2() {
                    var treeWidths = [];
                    for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {
                      treeWidths.push(_this3.direction.getTreeSize(i));
                    }
                    return treeWidths;
                  };
                  var getBranchNodes = function getBranchNodes2(source, map2) {
                    if (map2[source.id]) {
                      return;
                    }
                    map2[source.id] = true;
                    if (_this3.hierarchical.childrenReference[source.id]) {
                      var children = _this3.hierarchical.childrenReference[source.id];
                      if (children.length > 0) {
                        for (var i = 0; i < children.length; i++) {
                          getBranchNodes2(_this3.body.nodes[children[i]], map2);
                        }
                      }
                    }
                  };
                  var getBranchBoundary = function getBranchBoundary2(branchMap) {
                    var maxLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e9;
                    var minSpace = 1e9;
                    var maxSpace = 1e9;
                    var min = 1e9;
                    var max = -1e9;
                    for (var branchNode in branchMap) {
                      if (branchMap.hasOwnProperty(branchNode)) {
                        var node = _this3.body.nodes[branchNode];
                        var level = _this3.hierarchical.levels[node.id];
                        var position = _this3.direction.getPosition(node);
                        var _getSpaceAroundNode2 = _this3._getSpaceAroundNode(node, branchMap), _getSpaceAroundNode3 = (0, _slicedToArray3["default"])(_getSpaceAroundNode2, 2), minSpaceNode = _getSpaceAroundNode3[0], maxSpaceNode = _getSpaceAroundNode3[1];
                        minSpace = Math.min(minSpaceNode, minSpace);
                        maxSpace = Math.min(maxSpaceNode, maxSpace);
                        if (level <= maxLevel) {
                          min = Math.min(position, min);
                          max = Math.max(position, max);
                        }
                      }
                    }
                    return [min, max, minSpace, maxSpace];
                  };
                  var getCollisionLevel = function getCollisionLevel2(node1, node2) {
                    var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);
                    var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);
                    return Math.min(maxLevel1, maxLevel2);
                  };
                  var shiftElementsCloser = function shiftElementsCloser2(callback, levels, centerParents) {
                    var hier = _this3.hierarchical;
                    for (var i = 0; i < levels.length; i++) {
                      var level = levels[i];
                      var levelNodes = hier.distributionOrdering[level];
                      if (levelNodes.length > 1) {
                        for (var j = 0; j < levelNodes.length - 1; j++) {
                          var node1 = levelNodes[j];
                          var node2 = levelNodes[j + 1];
                          if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {
                            callback(node1, node2, centerParents);
                          }
                        }
                      }
                    }
                  };
                  var branchShiftCallback = function branchShiftCallback2(node1, node2) {
                    var centerParent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    var pos1 = _this3.direction.getPosition(node1);
                    var pos2 = _this3.direction.getPosition(node2);
                    var diffAbs = Math.abs(pos2 - pos1);
                    var nodeSpacing = _this3.options.hierarchical.nodeSpacing;
                    if (diffAbs > nodeSpacing) {
                      var branchNodes1 = {};
                      var branchNodes2 = {};
                      getBranchNodes(node1, branchNodes1);
                      getBranchNodes(node2, branchNodes2);
                      var maxLevel = getCollisionLevel(node1, node2);
                      var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);
                      var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);
                      var max1 = branchNodeBoundary1[1];
                      var min2 = branchNodeBoundary2[0];
                      var minSpace2 = branchNodeBoundary2[2];
                      var diffBranch = Math.abs(max1 - min2);
                      if (diffBranch > nodeSpacing) {
                        var offset = max1 - min2 + nodeSpacing;
                        if (offset < -minSpace2 + nodeSpacing) {
                          offset = -minSpace2 + nodeSpacing;
                        }
                        if (offset < 0) {
                          _this3._shiftBlock(node2.id, offset);
                          stillShifting = true;
                          if (centerParent === true)
                            _this3._centerParent(node2);
                        }
                      }
                    }
                  };
                  var minimizeEdgeLength = function minimizeEdgeLength2(iterations, node) {
                    var nodeId = node.id;
                    var allEdges = node.edges;
                    var nodeLevel = _this3.hierarchical.levels[node.id];
                    var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;
                    var referenceNodes = {};
                    var aboveEdges = [];
                    for (var i = 0; i < allEdges.length; i++) {
                      var edge = allEdges[i];
                      if (edge.toId != edge.fromId) {
                        var otherNode = edge.toId == nodeId ? edge.from : edge.to;
                        referenceNodes[allEdges[i].id] = otherNode;
                        if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {
                          aboveEdges.push(edge);
                        }
                      }
                    }
                    var getFx = function getFx2(point, edges2) {
                      var sum = 0;
                      for (var _i2 = 0; _i2 < edges2.length; _i2++) {
                        if (referenceNodes[edges2[_i2].id] !== void 0) {
                          var a = _this3.direction.getPosition(referenceNodes[edges2[_i2].id]) - point;
                          sum += a / Math.sqrt(a * a + C2);
                        }
                      }
                      return sum;
                    };
                    var getDFx = function getDFx2(point, edges2) {
                      var sum = 0;
                      for (var _i3 = 0; _i3 < edges2.length; _i3++) {
                        if (referenceNodes[edges2[_i3].id] !== void 0) {
                          var a = _this3.direction.getPosition(referenceNodes[edges2[_i3].id]) - point;
                          sum -= C2 * Math.pow(a * a + C2, -1.5);
                        }
                      }
                      return sum;
                    };
                    var getGuess = function getGuess2(iterations2, edges2) {
                      var guess2 = _this3.direction.getPosition(node);
                      var guessMap = {};
                      for (var _i4 = 0; _i4 < iterations2; _i4++) {
                        var fx = getFx(guess2, edges2);
                        var dfx = getDFx(guess2, edges2);
                        var limit = 40;
                        var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
                        guess2 = guess2 - ratio;
                        if (guessMap[guess2] !== void 0) {
                          break;
                        }
                        guessMap[guess2] = _i4;
                      }
                      return guess2;
                    };
                    var moveBranch = function moveBranch2(guess2) {
                      var nodePosition = _this3.direction.getPosition(node);
                      if (branches[node.id] === void 0) {
                        var branchNodes = {};
                        getBranchNodes(node, branchNodes);
                        branches[node.id] = branchNodes;
                      }
                      var branchBoundary = getBranchBoundary(branches[node.id]);
                      var minSpaceBranch = branchBoundary[2];
                      var maxSpaceBranch = branchBoundary[3];
                      var diff = guess2 - nodePosition;
                      var branchOffset = 0;
                      if (diff > 0) {
                        branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);
                      } else if (diff < 0) {
                        branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);
                      }
                      if (branchOffset != 0) {
                        _this3._shiftBlock(node.id, branchOffset);
                        stillShifting = true;
                      }
                    };
                    var moveNode = function moveNode2(guess2) {
                      var nodePosition = _this3.direction.getPosition(node);
                      var _getSpaceAroundNode4 = _this3._getSpaceAroundNode(node), _getSpaceAroundNode5 = (0, _slicedToArray3["default"])(_getSpaceAroundNode4, 2), minSpace = _getSpaceAroundNode5[0], maxSpace = _getSpaceAroundNode5[1];
                      var diff = guess2 - nodePosition;
                      var newPosition = nodePosition;
                      if (diff > 0) {
                        newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess2);
                      } else if (diff < 0) {
                        newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess2);
                      }
                      if (newPosition !== nodePosition) {
                        _this3.direction.setPosition(node, newPosition);
                        stillShifting = true;
                      }
                    };
                    var guess = getGuess(iterations, aboveEdges);
                    moveBranch(guess);
                    guess = getGuess(iterations, allEdges);
                    moveNode(guess);
                  };
                  var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp2(iterations) {
                    var levels = _this3.hierarchical.getLevels();
                    levels = levels.reverse();
                    for (var i = 0; i < iterations; i++) {
                      stillShifting = false;
                      for (var j = 0; j < levels.length; j++) {
                        var level = levels[j];
                        var levelNodes = _this3.hierarchical.distributionOrdering[level];
                        for (var k = 0; k < levelNodes.length; k++) {
                          minimizeEdgeLength(1e3, levelNodes[k]);
                        }
                      }
                      if (stillShifting !== true) {
                        break;
                      }
                    }
                  };
                  var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp2(iterations) {
                    var levels = _this3.hierarchical.getLevels();
                    levels = levels.reverse();
                    for (var i = 0; i < iterations; i++) {
                      stillShifting = false;
                      shiftElementsCloser(branchShiftCallback, levels, true);
                      if (stillShifting !== true) {
                        break;
                      }
                    }
                  };
                  var centerAllParents = function centerAllParents2() {
                    for (var nodeId in _this3.body.nodes) {
                      if (_this3.body.nodes.hasOwnProperty(nodeId))
                        _this3._centerParent(_this3.body.nodes[nodeId]);
                    }
                  };
                  var centerAllParentsBottomUp = function centerAllParentsBottomUp2() {
                    var levels = _this3.hierarchical.getLevels();
                    levels = levels.reverse();
                    for (var i = 0; i < levels.length; i++) {
                      var level = levels[i];
                      var levelNodes = _this3.hierarchical.distributionOrdering[level];
                      for (var j = 0; j < levelNodes.length; j++) {
                        _this3._centerParent(levelNodes[j]);
                      }
                    }
                  };
                  if (this.options.hierarchical.blockShifting === true) {
                    shiftBranchesCloserBottomUp(5);
                    centerAllParents();
                  }
                  if (this.options.hierarchical.edgeMinimization === true) {
                    minimizeEdgeLengthBottomUp(20);
                  }
                  if (this.options.hierarchical.parentCentralization === true) {
                    centerAllParentsBottomUp();
                  }
                  shiftTrees();
                }
              }, {
                key: "_getSpaceAroundNode",
                value: function _getSpaceAroundNode(node, map2) {
                  var useMap = true;
                  if (map2 === void 0) {
                    useMap = false;
                  }
                  var level = this.hierarchical.levels[node.id];
                  if (level !== void 0) {
                    var index = this.hierarchical.distributionIndex[node.id];
                    var position = this.direction.getPosition(node);
                    var ordering = this.hierarchical.distributionOrdering[level];
                    var minSpace = 1e9;
                    var maxSpace = 1e9;
                    if (index !== 0) {
                      var prevNode = ordering[index - 1];
                      if (useMap === true && map2[prevNode.id] === void 0 || useMap === false) {
                        var prevPos = this.direction.getPosition(prevNode);
                        minSpace = position - prevPos;
                      }
                    }
                    if (index != ordering.length - 1) {
                      var nextNode = ordering[index + 1];
                      if (useMap === true && map2[nextNode.id] === void 0 || useMap === false) {
                        var nextPos = this.direction.getPosition(nextNode);
                        maxSpace = Math.min(maxSpace, nextPos - position);
                      }
                    }
                    return [minSpace, maxSpace];
                  } else {
                    return [0, 0];
                  }
                }
              }, {
                key: "_centerParent",
                value: function _centerParent(node) {
                  if (this.hierarchical.parentReference[node.id]) {
                    var parents = this.hierarchical.parentReference[node.id];
                    for (var i = 0; i < parents.length; i++) {
                      var parentId = parents[i];
                      var parentNode = this.body.nodes[parentId];
                      var children = this.hierarchical.childrenReference[parentId];
                      if (children !== void 0) {
                        var newPosition = this._getCenterPosition(children);
                        var position = this.direction.getPosition(parentNode);
                        var _getSpaceAroundNode6 = this._getSpaceAroundNode(parentNode), _getSpaceAroundNode7 = (0, _slicedToArray3["default"])(_getSpaceAroundNode6, 2), minSpace = _getSpaceAroundNode7[0], maxSpace = _getSpaceAroundNode7[1];
                        var diff = position - newPosition;
                        if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
                          this.direction.setPosition(parentNode, newPosition);
                        }
                      }
                    }
                  }
                }
              }, {
                key: "_placeNodesByHierarchy",
                value: function _placeNodesByHierarchy(distribution) {
                  this.positionedNodes = {};
                  for (var level in distribution) {
                    if (distribution.hasOwnProperty(level)) {
                      var nodeArray = (0, _keys2["default"])(distribution[level]);
                      nodeArray = this._indexArrayToNodes(nodeArray);
                      this.direction.sort(nodeArray);
                      var handledNodeCount = 0;
                      for (var i = 0; i < nodeArray.length; i++) {
                        var node = nodeArray[i];
                        if (this.positionedNodes[node.id] === void 0) {
                          var spacing = this.options.hierarchical.nodeSpacing;
                          var pos = spacing * handledNodeCount;
                          if (handledNodeCount > 0) {
                            pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;
                          }
                          this.direction.setPosition(node, pos, level);
                          this._validatePositionAndContinue(node, level, pos);
                          handledNodeCount++;
                        }
                      }
                    }
                  }
                }
              }, {
                key: "_placeBranchNodes",
                value: function _placeBranchNodes(parentId, parentLevel) {
                  var childRef = this.hierarchical.childrenReference[parentId];
                  if (childRef === void 0) {
                    return;
                  }
                  var childNodes = [];
                  for (var i = 0; i < childRef.length; i++) {
                    childNodes.push(this.body.nodes[childRef[i]]);
                  }
                  this.direction.sort(childNodes);
                  for (var _i5 = 0; _i5 < childNodes.length; _i5++) {
                    var childNode = childNodes[_i5];
                    var childNodeLevel = this.hierarchical.levels[childNode.id];
                    if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === void 0) {
                      var spacing = this.options.hierarchical.nodeSpacing;
                      var pos = void 0;
                      if (_i5 === 0) {
                        pos = this.direction.getPosition(this.body.nodes[parentId]);
                      } else {
                        pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;
                      }
                      this.direction.setPosition(childNode, pos, childNodeLevel);
                      this._validatePositionAndContinue(childNode, childNodeLevel, pos);
                    } else {
                      return;
                    }
                  }
                  var center = this._getCenterPosition(childNodes);
                  this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);
                }
              }, {
                key: "_validatePositionAndContinue",
                value: function _validatePositionAndContinue(node, level, pos) {
                  if (!this.hierarchical.isTree)
                    return;
                  if (this.lastNodeOnLevel[level] !== void 0) {
                    var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);
                    if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
                      var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;
                      var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);
                      this._shiftBlock(sharedParent.withChild, diff);
                    }
                  }
                  this.lastNodeOnLevel[level] = node.id;
                  this.positionedNodes[node.id] = true;
                  this._placeBranchNodes(node.id, level);
                }
              }, {
                key: "_indexArrayToNodes",
                value: function _indexArrayToNodes(idArray) {
                  var array = [];
                  for (var i = 0; i < idArray.length; i++) {
                    array.push(this.body.nodes[idArray[i]]);
                  }
                  return array;
                }
              }, {
                key: "_getDistribution",
                value: function _getDistribution() {
                  var distribution = {};
                  var nodeId = void 0, node = void 0;
                  for (nodeId in this.body.nodes) {
                    if (this.body.nodes.hasOwnProperty(nodeId)) {
                      node = this.body.nodes[nodeId];
                      var level = this.hierarchical.levels[nodeId] === void 0 ? 0 : this.hierarchical.levels[nodeId];
                      this.direction.fix(node, level);
                      if (distribution[level] === void 0) {
                        distribution[level] = {};
                      }
                      distribution[level][nodeId] = node;
                    }
                  }
                  return distribution;
                }
              }, {
                key: "_getActiveEdges",
                value: function _getActiveEdges(node) {
                  var _this4 = this;
                  var result2 = [];
                  util.forEach(node.edges, function(edge) {
                    if (_this4.body.edgeIndices.indexOf(edge.id) !== -1) {
                      result2.push(edge);
                    }
                  });
                  return result2;
                }
              }, {
                key: "_getHubSizes",
                value: function _getHubSizes() {
                  var _this5 = this;
                  var hubSizes = {};
                  var nodeIds = this.body.nodeIndices;
                  util.forEach(nodeIds, function(nodeId) {
                    var node = _this5.body.nodes[nodeId];
                    var hubSize = _this5._getActiveEdges(node).length;
                    hubSizes[hubSize] = true;
                  });
                  var result2 = [];
                  util.forEach(hubSizes, function(size) {
                    result2.push(Number(size));
                  });
                  TimSort.sort(result2, function(a, b) {
                    return b - a;
                  });
                  return result2;
                }
              }, {
                key: "_determineLevelsByHubsize",
                value: function _determineLevelsByHubsize() {
                  var _this6 = this;
                  var levelDownstream = function levelDownstream2(nodeA, nodeB) {
                    _this6.hierarchical.levelDownstream(nodeA, nodeB);
                  };
                  var hubSizes = this._getHubSizes();
                  var _loop = function _loop2(i2) {
                    var hubSize = hubSizes[i2];
                    if (hubSize === 0)
                      return "break";
                    util.forEach(_this6.body.nodeIndices, function(nodeId) {
                      var node = _this6.body.nodes[nodeId];
                      if (hubSize === _this6._getActiveEdges(node).length) {
                        _this6._crawlNetwork(levelDownstream, nodeId);
                      }
                    });
                  };
                  for (var i = 0; i < hubSizes.length; ++i) {
                    var _ret = _loop(i);
                    if (_ret === "break")
                      break;
                  }
                }
              }, {
                key: "_determineLevelsCustomCallback",
                value: function _determineLevelsCustomCallback() {
                  var _this7 = this;
                  var minLevel = 1e5;
                  var customCallback = function customCallback2(nodeA, nodeB, edge) {
                  };
                  var levelByDirection = function levelByDirection2(nodeA, nodeB, edge) {
                    var levelA = _this7.hierarchical.levels[nodeA.id];
                    if (levelA === void 0) {
                      levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;
                    }
                    var diff = customCallback(NetworkUtil.cloneOptions(nodeA, "node"), NetworkUtil.cloneOptions(nodeB, "node"), NetworkUtil.cloneOptions(edge, "edge"));
                    _this7.hierarchical.levels[nodeB.id] = levelA + diff;
                  };
                  this._crawlNetwork(levelByDirection);
                  this.hierarchical.setMinLevelToZero(this.body.nodes);
                }
              }, {
                key: "_determineLevelsDirected",
                value: function _determineLevelsDirected() {
                  var _this8 = this;
                  var minLevel = 1e4;
                  var isBidirectional = function isBidirectional2(edge) {
                    util.forEach(_this8.body.edges, function(otherEdge) {
                      if (otherEdge.toId === edge.fromId && otherEdge.fromId === edge.toId) {
                        return true;
                      }
                    });
                    return false;
                  };
                  var levelByDirection = function levelByDirection2(nodeA, nodeB, edge) {
                    var levelA = _this8.hierarchical.levels[nodeA.id];
                    var levelB = _this8.hierarchical.levels[nodeB.id];
                    if (isBidirectional(edge) && levelA !== void 0 && levelB !== void 0) {
                      return;
                    }
                    if (levelA === void 0) {
                      levelA = _this8.hierarchical.levels[nodeA.id] = minLevel;
                    }
                    if (edge.toId == nodeB.id) {
                      _this8.hierarchical.levels[nodeB.id] = levelA + 1;
                    } else {
                      _this8.hierarchical.levels[nodeB.id] = levelA - 1;
                    }
                  };
                  this._crawlNetwork(levelByDirection);
                  this.hierarchical.setMinLevelToZero(this.body.nodes);
                }
              }, {
                key: "_generateMap",
                value: function _generateMap() {
                  var _this9 = this;
                  var fillInRelations = function fillInRelations2(parentNode, childNode) {
                    if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {
                      _this9.hierarchical.addRelation(parentNode.id, childNode.id);
                    }
                  };
                  this._crawlNetwork(fillInRelations);
                  this.hierarchical.checkIfTree();
                }
              }, {
                key: "_crawlNetwork",
                value: function _crawlNetwork() {
                  var _this10 = this;
                  var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
                  };
                  var startingNodeId = arguments[1];
                  var progress = {};
                  var crawler = function crawler2(node2, tree) {
                    if (progress[node2.id] === void 0) {
                      _this10.hierarchical.setTreeIndex(node2, tree);
                      progress[node2.id] = true;
                      var childNode = void 0;
                      var edges2 = _this10._getActiveEdges(node2);
                      for (var i2 = 0; i2 < edges2.length; i2++) {
                        var edge = edges2[i2];
                        if (edge.connected === true) {
                          if (edge.toId == node2.id) {
                            childNode = edge.from;
                          } else {
                            childNode = edge.to;
                          }
                          if (node2.id != childNode.id) {
                            callback(node2, childNode, edge);
                            crawler2(childNode, tree);
                          }
                        }
                      }
                    }
                  };
                  if (startingNodeId === void 0) {
                    var treeIndex = 0;
                    for (var i = 0; i < this.body.nodeIndices.length; i++) {
                      var nodeId = this.body.nodeIndices[i];
                      if (progress[nodeId] === void 0) {
                        var node = this.body.nodes[nodeId];
                        crawler(node, treeIndex);
                        treeIndex += 1;
                      }
                    }
                  } else {
                    var _node2 = this.body.nodes[startingNodeId];
                    if (_node2 === void 0) {
                      console.error("Node not found:", startingNodeId);
                      return;
                    }
                    crawler(_node2);
                  }
                }
              }, {
                key: "_shiftBlock",
                value: function _shiftBlock(parentId, diff) {
                  var _this11 = this;
                  var progress = {};
                  var shifter = function shifter2(parentId2) {
                    if (progress[parentId2]) {
                      return;
                    }
                    progress[parentId2] = true;
                    _this11.direction.shift(parentId2, diff);
                    var childRef = _this11.hierarchical.childrenReference[parentId2];
                    if (childRef !== void 0) {
                      for (var i = 0; i < childRef.length; i++) {
                        shifter2(childRef[i]);
                      }
                    }
                  };
                  shifter(parentId);
                }
              }, {
                key: "_findCommonParent",
                value: function _findCommonParent(childA, childB) {
                  var _this12 = this;
                  var parents = {};
                  var iterateParents = function iterateParents2(parents2, child) {
                    var parentRef = _this12.hierarchical.parentReference[child];
                    if (parentRef !== void 0) {
                      for (var i = 0; i < parentRef.length; i++) {
                        var parent = parentRef[i];
                        parents2[parent] = true;
                        iterateParents2(parents2, parent);
                      }
                    }
                  };
                  var findParent = function findParent2(parents2, child) {
                    var parentRef = _this12.hierarchical.parentReference[child];
                    if (parentRef !== void 0) {
                      for (var i = 0; i < parentRef.length; i++) {
                        var parent = parentRef[i];
                        if (parents2[parent] !== void 0) {
                          return { foundParent: parent, withChild: child };
                        }
                        var branch = findParent2(parents2, parent);
                        if (branch.foundParent !== null) {
                          return branch;
                        }
                      }
                    }
                    return { foundParent: null, withChild: child };
                  };
                  iterateParents(parents, childA);
                  return findParent(parents, childB);
                }
              }, {
                key: "setDirectionStrategy",
                value: function setDirectionStrategy() {
                  var isVertical = this.options.hierarchical.direction === "UD" || this.options.hierarchical.direction === "DU";
                  if (isVertical) {
                    this.direction = new VerticalStrategy(this);
                  } else {
                    this.direction = new HorizontalStrategy(this);
                  }
                }
              }, {
                key: "_getCenterPosition",
                value: function _getCenterPosition(childNodes) {
                  var minPos = 1e9;
                  var maxPos = -1e9;
                  for (var i = 0; i < childNodes.length; i++) {
                    var childNode = void 0;
                    if (childNodes[i].id !== void 0) {
                      childNode = childNodes[i];
                    } else {
                      var childNodeId = childNodes[i];
                      childNode = this.body.nodes[childNodeId];
                    }
                    var position = this.direction.getPosition(childNode);
                    minPos = Math.min(minPos, position);
                    maxPos = Math.max(maxPos, position);
                  }
                  return 0.5 * (minPos + maxPos);
                }
              }]);
              return LayoutEngine2;
            }();
            exports2["default"] = LayoutEngine;
          },
          function(module2, exports2, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(global, factory) {
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports2], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof exports2 !== "undefined") {
                factory(exports2);
              } else {
                var mod = {
                  exports: {}
                };
                factory(mod.exports);
                global.timsort = mod.exports;
              }
            })(this, function(exports3) {
              "use strict";
              exports3.__esModule = true;
              exports3.sort = sort;
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var DEFAULT_MIN_MERGE = 32;
              var DEFAULT_MIN_GALLOPING = 7;
              var DEFAULT_TMP_STORAGE_LENGTH = 256;
              var POWERS_OF_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
              function log10(x) {
                if (x < 1e5) {
                  if (x < 100) {
                    return x < 10 ? 0 : 1;
                  }
                  if (x < 1e4) {
                    return x < 1e3 ? 2 : 3;
                  }
                  return 4;
                }
                if (x < 1e7) {
                  return x < 1e6 ? 5 : 6;
                }
                if (x < 1e9) {
                  return x < 1e8 ? 7 : 8;
                }
                return 9;
              }
              function alphabeticalCompare(a, b) {
                if (a === b) {
                  return 0;
                }
                if (~~a === a && ~~b === b) {
                  if (a === 0 || b === 0) {
                    return a < b ? -1 : 1;
                  }
                  if (a < 0 || b < 0) {
                    if (b >= 0) {
                      return -1;
                    }
                    if (a >= 0) {
                      return 1;
                    }
                    a = -a;
                    b = -b;
                  }
                  var al = log10(a);
                  var bl = log10(b);
                  var t = 0;
                  if (al < bl) {
                    a *= POWERS_OF_TEN[bl - al - 1];
                    b /= 10;
                    t = -1;
                  } else if (al > bl) {
                    b *= POWERS_OF_TEN[al - bl - 1];
                    a /= 10;
                    t = 1;
                  }
                  if (a === b) {
                    return t;
                  }
                  return a < b ? -1 : 1;
                }
                var aStr = String(a);
                var bStr = String(b);
                if (aStr === bStr) {
                  return 0;
                }
                return aStr < bStr ? -1 : 1;
              }
              function minRunLength(n) {
                var r = 0;
                while (n >= DEFAULT_MIN_MERGE) {
                  r |= n & 1;
                  n >>= 1;
                }
                return n + r;
              }
              function makeAscendingRun(array, lo, hi, compare) {
                var runHi = lo + 1;
                if (runHi === hi) {
                  return 1;
                }
                if (compare(array[runHi++], array[lo]) < 0) {
                  while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
                    runHi++;
                  }
                  reverseRun(array, lo, runHi);
                } else {
                  while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
                    runHi++;
                  }
                }
                return runHi - lo;
              }
              function reverseRun(array, lo, hi) {
                hi--;
                while (lo < hi) {
                  var t = array[lo];
                  array[lo++] = array[hi];
                  array[hi--] = t;
                }
              }
              function binaryInsertionSort(array, lo, hi, start, compare) {
                if (start === lo) {
                  start++;
                }
                for (; start < hi; start++) {
                  var pivot = array[start];
                  var left = lo;
                  var right = start;
                  while (left < right) {
                    var mid = left + right >>> 1;
                    if (compare(pivot, array[mid]) < 0) {
                      right = mid;
                    } else {
                      left = mid + 1;
                    }
                  }
                  var n = start - left;
                  switch (n) {
                    case 3:
                      array[left + 3] = array[left + 2];
                    case 2:
                      array[left + 2] = array[left + 1];
                    case 1:
                      array[left + 1] = array[left];
                      break;
                    default:
                      while (n > 0) {
                        array[left + n] = array[left + n - 1];
                        n--;
                      }
                  }
                  array[left] = pivot;
                }
              }
              function gallopLeft(value, array, start, length2, hint, compare) {
                var lastOffset = 0;
                var maxOffset = 0;
                var offset = 1;
                if (compare(value, array[start + hint]) > 0) {
                  maxOffset = length2 - hint;
                  while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
                    lastOffset = offset;
                    offset = (offset << 1) + 1;
                    if (offset <= 0) {
                      offset = maxOffset;
                    }
                  }
                  if (offset > maxOffset) {
                    offset = maxOffset;
                  }
                  lastOffset += hint;
                  offset += hint;
                } else {
                  maxOffset = hint + 1;
                  while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
                    lastOffset = offset;
                    offset = (offset << 1) + 1;
                    if (offset <= 0) {
                      offset = maxOffset;
                    }
                  }
                  if (offset > maxOffset) {
                    offset = maxOffset;
                  }
                  var tmp = lastOffset;
                  lastOffset = hint - offset;
                  offset = hint - tmp;
                }
                lastOffset++;
                while (lastOffset < offset) {
                  var m = lastOffset + (offset - lastOffset >>> 1);
                  if (compare(value, array[start + m]) > 0) {
                    lastOffset = m + 1;
                  } else {
                    offset = m;
                  }
                }
                return offset;
              }
              function gallopRight(value, array, start, length2, hint, compare) {
                var lastOffset = 0;
                var maxOffset = 0;
                var offset = 1;
                if (compare(value, array[start + hint]) < 0) {
                  maxOffset = hint + 1;
                  while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
                    lastOffset = offset;
                    offset = (offset << 1) + 1;
                    if (offset <= 0) {
                      offset = maxOffset;
                    }
                  }
                  if (offset > maxOffset) {
                    offset = maxOffset;
                  }
                  var tmp = lastOffset;
                  lastOffset = hint - offset;
                  offset = hint - tmp;
                } else {
                  maxOffset = length2 - hint;
                  while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
                    lastOffset = offset;
                    offset = (offset << 1) + 1;
                    if (offset <= 0) {
                      offset = maxOffset;
                    }
                  }
                  if (offset > maxOffset) {
                    offset = maxOffset;
                  }
                  lastOffset += hint;
                  offset += hint;
                }
                lastOffset++;
                while (lastOffset < offset) {
                  var m = lastOffset + (offset - lastOffset >>> 1);
                  if (compare(value, array[start + m]) < 0) {
                    offset = m;
                  } else {
                    lastOffset = m + 1;
                  }
                }
                return offset;
              }
              var TimSort = function() {
                function TimSort2(array, compare) {
                  _classCallCheck(this, TimSort2);
                  this.array = null;
                  this.compare = null;
                  this.minGallop = DEFAULT_MIN_GALLOPING;
                  this.length = 0;
                  this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
                  this.stackLength = 0;
                  this.runStart = null;
                  this.runLength = null;
                  this.stackSize = 0;
                  this.array = array;
                  this.compare = compare;
                  this.length = array.length;
                  if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
                    this.tmpStorageLength = this.length >>> 1;
                  }
                  this.tmp = new Array(this.tmpStorageLength);
                  this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;
                  this.runStart = new Array(this.stackLength);
                  this.runLength = new Array(this.stackLength);
                }
                TimSort2.prototype.pushRun = function pushRun(runStart, runLength) {
                  this.runStart[this.stackSize] = runStart;
                  this.runLength[this.stackSize] = runLength;
                  this.stackSize += 1;
                };
                TimSort2.prototype.mergeRuns = function mergeRuns() {
                  while (this.stackSize > 1) {
                    var n = this.stackSize - 2;
                    if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
                      if (this.runLength[n - 1] < this.runLength[n + 1]) {
                        n--;
                      }
                    } else if (this.runLength[n] > this.runLength[n + 1]) {
                      break;
                    }
                    this.mergeAt(n);
                  }
                };
                TimSort2.prototype.forceMergeRuns = function forceMergeRuns() {
                  while (this.stackSize > 1) {
                    var n = this.stackSize - 2;
                    if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
                      n--;
                    }
                    this.mergeAt(n);
                  }
                };
                TimSort2.prototype.mergeAt = function mergeAt(i) {
                  var compare = this.compare;
                  var array = this.array;
                  var start1 = this.runStart[i];
                  var length1 = this.runLength[i];
                  var start2 = this.runStart[i + 1];
                  var length2 = this.runLength[i + 1];
                  this.runLength[i] = length1 + length2;
                  if (i === this.stackSize - 3) {
                    this.runStart[i + 1] = this.runStart[i + 2];
                    this.runLength[i + 1] = this.runLength[i + 2];
                  }
                  this.stackSize--;
                  var k = gallopRight(array[start2], array, start1, length1, 0, compare);
                  start1 += k;
                  length1 -= k;
                  if (length1 === 0) {
                    return;
                  }
                  length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
                  if (length2 === 0) {
                    return;
                  }
                  if (length1 <= length2) {
                    this.mergeLow(start1, length1, start2, length2);
                  } else {
                    this.mergeHigh(start1, length1, start2, length2);
                  }
                };
                TimSort2.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {
                  var compare = this.compare;
                  var array = this.array;
                  var tmp = this.tmp;
                  var i = 0;
                  for (i = 0; i < length1; i++) {
                    tmp[i] = array[start1 + i];
                  }
                  var cursor1 = 0;
                  var cursor2 = start2;
                  var dest = start1;
                  array[dest++] = array[cursor2++];
                  if (--length2 === 0) {
                    for (i = 0; i < length1; i++) {
                      array[dest + i] = tmp[cursor1 + i];
                    }
                    return;
                  }
                  if (length1 === 1) {
                    for (i = 0; i < length2; i++) {
                      array[dest + i] = array[cursor2 + i];
                    }
                    array[dest + length2] = tmp[cursor1];
                    return;
                  }
                  var minGallop = this.minGallop;
                  while (true) {
                    var count1 = 0;
                    var count2 = 0;
                    var exit = false;
                    do {
                      if (compare(array[cursor2], tmp[cursor1]) < 0) {
                        array[dest++] = array[cursor2++];
                        count2++;
                        count1 = 0;
                        if (--length2 === 0) {
                          exit = true;
                          break;
                        }
                      } else {
                        array[dest++] = tmp[cursor1++];
                        count1++;
                        count2 = 0;
                        if (--length1 === 1) {
                          exit = true;
                          break;
                        }
                      }
                    } while ((count1 | count2) < minGallop);
                    if (exit) {
                      break;
                    }
                    do {
                      count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
                      if (count1 !== 0) {
                        for (i = 0; i < count1; i++) {
                          array[dest + i] = tmp[cursor1 + i];
                        }
                        dest += count1;
                        cursor1 += count1;
                        length1 -= count1;
                        if (length1 <= 1) {
                          exit = true;
                          break;
                        }
                      }
                      array[dest++] = array[cursor2++];
                      if (--length2 === 0) {
                        exit = true;
                        break;
                      }
                      count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
                      if (count2 !== 0) {
                        for (i = 0; i < count2; i++) {
                          array[dest + i] = array[cursor2 + i];
                        }
                        dest += count2;
                        cursor2 += count2;
                        length2 -= count2;
                        if (length2 === 0) {
                          exit = true;
                          break;
                        }
                      }
                      array[dest++] = tmp[cursor1++];
                      if (--length1 === 1) {
                        exit = true;
                        break;
                      }
                      minGallop--;
                    } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
                    if (exit) {
                      break;
                    }
                    if (minGallop < 0) {
                      minGallop = 0;
                    }
                    minGallop += 2;
                  }
                  this.minGallop = minGallop;
                  if (minGallop < 1) {
                    this.minGallop = 1;
                  }
                  if (length1 === 1) {
                    for (i = 0; i < length2; i++) {
                      array[dest + i] = array[cursor2 + i];
                    }
                    array[dest + length2] = tmp[cursor1];
                  } else if (length1 === 0) {
                    throw new Error("mergeLow preconditions were not respected");
                  } else {
                    for (i = 0; i < length1; i++) {
                      array[dest + i] = tmp[cursor1 + i];
                    }
                  }
                };
                TimSort2.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
                  var compare = this.compare;
                  var array = this.array;
                  var tmp = this.tmp;
                  var i = 0;
                  for (i = 0; i < length2; i++) {
                    tmp[i] = array[start2 + i];
                  }
                  var cursor1 = start1 + length1 - 1;
                  var cursor2 = length2 - 1;
                  var dest = start2 + length2 - 1;
                  var customCursor = 0;
                  var customDest = 0;
                  array[dest--] = array[cursor1--];
                  if (--length1 === 0) {
                    customCursor = dest - (length2 - 1);
                    for (i = 0; i < length2; i++) {
                      array[customCursor + i] = tmp[i];
                    }
                    return;
                  }
                  if (length2 === 1) {
                    dest -= length1;
                    cursor1 -= length1;
                    customDest = dest + 1;
                    customCursor = cursor1 + 1;
                    for (i = length1 - 1; i >= 0; i--) {
                      array[customDest + i] = array[customCursor + i];
                    }
                    array[dest] = tmp[cursor2];
                    return;
                  }
                  var minGallop = this.minGallop;
                  while (true) {
                    var count1 = 0;
                    var count2 = 0;
                    var exit = false;
                    do {
                      if (compare(tmp[cursor2], array[cursor1]) < 0) {
                        array[dest--] = array[cursor1--];
                        count1++;
                        count2 = 0;
                        if (--length1 === 0) {
                          exit = true;
                          break;
                        }
                      } else {
                        array[dest--] = tmp[cursor2--];
                        count2++;
                        count1 = 0;
                        if (--length2 === 1) {
                          exit = true;
                          break;
                        }
                      }
                    } while ((count1 | count2) < minGallop);
                    if (exit) {
                      break;
                    }
                    do {
                      count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
                      if (count1 !== 0) {
                        dest -= count1;
                        cursor1 -= count1;
                        length1 -= count1;
                        customDest = dest + 1;
                        customCursor = cursor1 + 1;
                        for (i = count1 - 1; i >= 0; i--) {
                          array[customDest + i] = array[customCursor + i];
                        }
                        if (length1 === 0) {
                          exit = true;
                          break;
                        }
                      }
                      array[dest--] = tmp[cursor2--];
                      if (--length2 === 1) {
                        exit = true;
                        break;
                      }
                      count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
                      if (count2 !== 0) {
                        dest -= count2;
                        cursor2 -= count2;
                        length2 -= count2;
                        customDest = dest + 1;
                        customCursor = cursor2 + 1;
                        for (i = 0; i < count2; i++) {
                          array[customDest + i] = tmp[customCursor + i];
                        }
                        if (length2 <= 1) {
                          exit = true;
                          break;
                        }
                      }
                      array[dest--] = array[cursor1--];
                      if (--length1 === 0) {
                        exit = true;
                        break;
                      }
                      minGallop--;
                    } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
                    if (exit) {
                      break;
                    }
                    if (minGallop < 0) {
                      minGallop = 0;
                    }
                    minGallop += 2;
                  }
                  this.minGallop = minGallop;
                  if (minGallop < 1) {
                    this.minGallop = 1;
                  }
                  if (length2 === 1) {
                    dest -= length1;
                    cursor1 -= length1;
                    customDest = dest + 1;
                    customCursor = cursor1 + 1;
                    for (i = length1 - 1; i >= 0; i--) {
                      array[customDest + i] = array[customCursor + i];
                    }
                    array[dest] = tmp[cursor2];
                  } else if (length2 === 0) {
                    throw new Error("mergeHigh preconditions were not respected");
                  } else {
                    customCursor = dest - (length2 - 1);
                    for (i = 0; i < length2; i++) {
                      array[customCursor + i] = tmp[i];
                    }
                  }
                };
                return TimSort2;
              }();
              function sort(array, compare, lo, hi) {
                if (!Array.isArray(array)) {
                  throw new TypeError("Can only sort arrays");
                }
                if (!compare) {
                  compare = alphabeticalCompare;
                } else if (typeof compare !== "function") {
                  hi = lo;
                  lo = compare;
                  compare = alphabeticalCompare;
                }
                if (!lo) {
                  lo = 0;
                }
                if (!hi) {
                  hi = array.length;
                }
                var remaining = hi - lo;
                if (remaining < 2) {
                  return;
                }
                var runLength = 0;
                if (remaining < DEFAULT_MIN_MERGE) {
                  runLength = makeAscendingRun(array, lo, hi, compare);
                  binaryInsertionSort(array, lo, hi, lo + runLength, compare);
                  return;
                }
                var ts = new TimSort(array, compare);
                var minRun = minRunLength(remaining);
                do {
                  runLength = makeAscendingRun(array, lo, hi, compare);
                  if (runLength < minRun) {
                    var force = remaining;
                    if (force > minRun) {
                      force = minRun;
                    }
                    binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
                    runLength = force;
                  }
                  ts.pushRun(lo, runLength);
                  ts.mergeRuns();
                  remaining -= runLength;
                  lo += runLength;
                } while (remaining !== 0);
                ts.forceMergeRuns();
              }
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.VerticalStrategy = exports2.HorizontalStrategy = void 0;
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var TimSort = __webpack_require__(83);
            var DirectionInterface = function() {
              function DirectionInterface2() {
                (0, _classCallCheck3["default"])(this, DirectionInterface2);
              }
              (0, _createClass3["default"])(DirectionInterface2, [{
                key: "abstract",
                value: function abstract() {
                  throw new Error("Can't instantiate abstract class!");
                }
              }, {
                key: "fake_use",
                value: function fake_use() {
                }
              }, {
                key: "curveType",
                value: function curveType() {
                  return this.abstract();
                }
              }, {
                key: "getPosition",
                value: function getPosition(node) {
                  this.fake_use(node);
                  return this.abstract();
                }
              }, {
                key: "setPosition",
                value: function setPosition(node, position) {
                  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                  this.fake_use(node, position, level);
                  this.abstract();
                }
              }, {
                key: "getTreeSize",
                value: function getTreeSize(index) {
                  this.fake_use(index);
                  return this.abstract();
                }
              }, {
                key: "sort",
                value: function sort(nodeArray) {
                  this.fake_use(nodeArray);
                  this.abstract();
                }
              }, {
                key: "fix",
                value: function fix(node, level) {
                  this.fake_use(node, level);
                  this.abstract();
                }
              }, {
                key: "shift",
                value: function shift(nodeId, diff) {
                  this.fake_use(nodeId, diff);
                  this.abstract();
                }
              }]);
              return DirectionInterface2;
            }();
            var VerticalStrategy = function(_DirectionInterface) {
              (0, _inherits3["default"])(VerticalStrategy2, _DirectionInterface);
              function VerticalStrategy2(layout) {
                (0, _classCallCheck3["default"])(this, VerticalStrategy2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (VerticalStrategy2.__proto__ || (0, _getPrototypeOf2["default"])(VerticalStrategy2)).call(this));
                _this.layout = layout;
                return _this;
              }
              (0, _createClass3["default"])(VerticalStrategy2, [{
                key: "curveType",
                value: function curveType() {
                  return "horizontal";
                }
              }, {
                key: "getPosition",
                value: function getPosition(node) {
                  return node.x;
                }
              }, {
                key: "setPosition",
                value: function setPosition(node, position) {
                  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                  if (level !== void 0) {
                    this.layout.hierarchical.addToOrdering(node, level);
                  }
                  node.x = position;
                }
              }, {
                key: "getTreeSize",
                value: function getTreeSize(index) {
                  var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
                  return { min: res.min_x, max: res.max_x };
                }
              }, {
                key: "sort",
                value: function sort(nodeArray) {
                  TimSort.sort(nodeArray, function(a, b) {
                    return a.x - b.x;
                  });
                }
              }, {
                key: "fix",
                value: function fix(node, level) {
                  node.y = this.layout.options.hierarchical.levelSeparation * level;
                  node.options.fixed.y = true;
                }
              }, {
                key: "shift",
                value: function shift(nodeId, diff) {
                  this.layout.body.nodes[nodeId].x += diff;
                }
              }]);
              return VerticalStrategy2;
            }(DirectionInterface);
            var HorizontalStrategy = function(_DirectionInterface2) {
              (0, _inherits3["default"])(HorizontalStrategy2, _DirectionInterface2);
              function HorizontalStrategy2(layout) {
                (0, _classCallCheck3["default"])(this, HorizontalStrategy2);
                var _this2 = (0, _possibleConstructorReturn3["default"])(this, (HorizontalStrategy2.__proto__ || (0, _getPrototypeOf2["default"])(HorizontalStrategy2)).call(this));
                _this2.layout = layout;
                return _this2;
              }
              (0, _createClass3["default"])(HorizontalStrategy2, [{
                key: "curveType",
                value: function curveType() {
                  return "vertical";
                }
              }, {
                key: "getPosition",
                value: function getPosition(node) {
                  return node.y;
                }
              }, {
                key: "setPosition",
                value: function setPosition(node, position) {
                  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                  if (level !== void 0) {
                    this.layout.hierarchical.addToOrdering(node, level);
                  }
                  node.y = position;
                }
              }, {
                key: "getTreeSize",
                value: function getTreeSize(index) {
                  var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
                  return { min: res.min_y, max: res.max_y };
                }
              }, {
                key: "sort",
                value: function sort(nodeArray) {
                  TimSort.sort(nodeArray, function(a, b) {
                    return a.y - b.y;
                  });
                }
              }, {
                key: "fix",
                value: function fix(node, level) {
                  node.x = this.layout.options.hierarchical.levelSeparation * level;
                  node.options.fixed.x = true;
                }
              }, {
                key: "shift",
                value: function shift(nodeId, diff) {
                  this.layout.body.nodes[nodeId].y += diff;
                }
              }]);
              return HorizontalStrategy2;
            }(DirectionInterface);
            exports2.HorizontalStrategy = HorizontalStrategy;
            exports2.VerticalStrategy = VerticalStrategy;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _keys = __webpack_require__(9);
            var _keys2 = _interopRequireDefault(_keys);
            var _stringify = __webpack_require__(23);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Hammer = __webpack_require__(24);
            var hammerUtil = __webpack_require__(36);
            var ManipulationSystem = function() {
              function ManipulationSystem2(body, canvas, selectionHandler) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, ManipulationSystem2);
                this.body = body;
                this.canvas = canvas;
                this.selectionHandler = selectionHandler;
                this.editMode = false;
                this.manipulationDiv = void 0;
                this.editModeDiv = void 0;
                this.closeDiv = void 0;
                this.manipulationHammers = [];
                this.temporaryUIFunctions = {};
                this.temporaryEventFunctions = [];
                this.touchTime = 0;
                this.temporaryIds = { nodes: [], edges: [] };
                this.guiEnabled = false;
                this.inMode = false;
                this.selectedControlNode = void 0;
                this.options = {};
                this.defaultOptions = {
                  enabled: false,
                  initiallyActive: false,
                  addNode: true,
                  addEdge: true,
                  editNode: void 0,
                  editEdge: true,
                  deleteNode: true,
                  deleteEdge: true,
                  controlNodeStyle: {
                    shape: "dot",
                    size: 6,
                    color: {
                      background: "#ff0000",
                      border: "#3c3c3c",
                      highlight: { background: "#07f968", border: "#3c3c3c" }
                    },
                    borderWidth: 2,
                    borderWidthSelected: 2
                  }
                };
                util.extend(this.options, this.defaultOptions);
                this.body.emitter.on("destroy", function() {
                  _this._clean();
                });
                this.body.emitter.on("_dataChanged", this._restore.bind(this));
                this.body.emitter.on("_resetData", this._restore.bind(this));
              }
              (0, _createClass3["default"])(ManipulationSystem2, [{
                key: "_restore",
                value: function _restore() {
                  if (this.inMode !== false) {
                    if (this.options.initiallyActive === true) {
                      this.enableEditMode();
                    } else {
                      this.disableEditMode();
                    }
                  }
                }
              }, {
                key: "setOptions",
                value: function setOptions(options, allOptions, globalOptions) {
                  if (allOptions !== void 0) {
                    if (allOptions.locale !== void 0) {
                      this.options.locale = allOptions.locale;
                    } else {
                      this.options.locale = globalOptions.locale;
                    }
                    if (allOptions.locales !== void 0) {
                      this.options.locales = allOptions.locales;
                    } else {
                      this.options.locales = globalOptions.locales;
                    }
                  }
                  if (options !== void 0) {
                    if (typeof options === "boolean") {
                      this.options.enabled = options;
                    } else {
                      this.options.enabled = true;
                      util.deepExtend(this.options, options);
                    }
                    if (this.options.initiallyActive === true) {
                      this.editMode = true;
                    }
                    this._setup();
                  }
                }
              }, {
                key: "toggleEditMode",
                value: function toggleEditMode() {
                  if (this.editMode === true) {
                    this.disableEditMode();
                  } else {
                    this.enableEditMode();
                  }
                }
              }, {
                key: "enableEditMode",
                value: function enableEditMode() {
                  this.editMode = true;
                  this._clean();
                  if (this.guiEnabled === true) {
                    this.manipulationDiv.style.display = "block";
                    this.closeDiv.style.display = "block";
                    this.editModeDiv.style.display = "none";
                    this.showManipulatorToolbar();
                  }
                }
              }, {
                key: "disableEditMode",
                value: function disableEditMode() {
                  this.editMode = false;
                  this._clean();
                  if (this.guiEnabled === true) {
                    this.manipulationDiv.style.display = "none";
                    this.closeDiv.style.display = "none";
                    this.editModeDiv.style.display = "block";
                    this._createEditButton();
                  }
                }
              }, {
                key: "showManipulatorToolbar",
                value: function showManipulatorToolbar() {
                  this._clean();
                  this.manipulationDOM = {};
                  if (this.guiEnabled === true) {
                    this.editMode = true;
                    this.manipulationDiv.style.display = "block";
                    this.closeDiv.style.display = "block";
                    var selectedNodeCount = this.selectionHandler._getSelectedNodeCount();
                    var selectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
                    var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
                    var locale = this.options.locales[this.options.locale];
                    var needSeperator = false;
                    if (this.options.addNode !== false) {
                      this._createAddNodeButton(locale);
                      needSeperator = true;
                    }
                    if (this.options.addEdge !== false) {
                      if (needSeperator === true) {
                        this._createSeperator(1);
                      } else {
                        needSeperator = true;
                      }
                      this._createAddEdgeButton(locale);
                    }
                    if (selectedNodeCount === 1 && typeof this.options.editNode === "function") {
                      if (needSeperator === true) {
                        this._createSeperator(2);
                      } else {
                        needSeperator = true;
                      }
                      this._createEditNodeButton(locale);
                    } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
                      if (needSeperator === true) {
                        this._createSeperator(3);
                      } else {
                        needSeperator = true;
                      }
                      this._createEditEdgeButton(locale);
                    }
                    if (selectedTotalCount !== 0) {
                      if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
                        if (needSeperator === true) {
                          this._createSeperator(4);
                        }
                        this._createDeleteButton(locale);
                      } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
                        if (needSeperator === true) {
                          this._createSeperator(4);
                        }
                        this._createDeleteButton(locale);
                      }
                    }
                    this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
                    this._temporaryBindEvent("select", this.showManipulatorToolbar.bind(this));
                  }
                  this.body.emitter.emit("_redraw");
                }
              }, {
                key: "addNodeMode",
                value: function addNodeMode() {
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  this.inMode = "addNode";
                  if (this.guiEnabled === true) {
                    var locale = this.options.locales[this.options.locale];
                    this.manipulationDOM = {};
                    this._createBackButton(locale);
                    this._createSeperator();
                    this._createDescription(locale["addDescription"] || this.options.locales["en"]["addDescription"]);
                    this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
                  }
                  this._temporaryBindEvent("click", this._performAddNode.bind(this));
                }
              }, {
                key: "editNode",
                value: function editNode() {
                  var _this2 = this;
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  var node = this.selectionHandler._getSelectedNode();
                  if (node !== void 0) {
                    this.inMode = "editNode";
                    if (typeof this.options.editNode === "function") {
                      if (node.isCluster !== true) {
                        var data = util.deepExtend({}, node.options, false);
                        data.x = node.x;
                        data.y = node.y;
                        if (this.options.editNode.length === 2) {
                          this.options.editNode(data, function(finalizedData) {
                            if (finalizedData !== null && finalizedData !== void 0 && _this2.inMode === "editNode") {
                              _this2.body.data.nodes.getDataSet().update(finalizedData);
                            }
                            _this2.showManipulatorToolbar();
                          });
                        } else {
                          throw new Error("The function for edit does not support two arguments (data, callback)");
                        }
                      } else {
                        alert(this.options.locales[this.options.locale]["editClusterError"] || this.options.locales["en"]["editClusterError"]);
                      }
                    } else {
                      throw new Error("No function has been configured to handle the editing of nodes.");
                    }
                  } else {
                    this.showManipulatorToolbar();
                  }
                }
              }, {
                key: "addEdgeMode",
                value: function addEdgeMode() {
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  this.inMode = "addEdge";
                  if (this.guiEnabled === true) {
                    var locale = this.options.locales[this.options.locale];
                    this.manipulationDOM = {};
                    this._createBackButton(locale);
                    this._createSeperator();
                    this._createDescription(locale["edgeDescription"] || this.options.locales["en"]["edgeDescription"]);
                    this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
                  }
                  this._temporaryBindUI("onTouch", this._handleConnect.bind(this));
                  this._temporaryBindUI("onDragEnd", this._finishConnect.bind(this));
                  this._temporaryBindUI("onDrag", this._dragControlNode.bind(this));
                  this._temporaryBindUI("onRelease", this._finishConnect.bind(this));
                  this._temporaryBindUI("onDragStart", this._dragStartEdge.bind(this));
                  this._temporaryBindUI("onHold", function() {
                  });
                }
              }, {
                key: "editEdgeMode",
                value: function editEdgeMode() {
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  this.inMode = "editEdge";
                  if ((0, _typeof3["default"])(this.options.editEdge) === "object" && typeof this.options.editEdge.editWithoutDrag === "function") {
                    this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
                    if (this.edgeBeingEditedId !== void 0) {
                      var edge = this.body.edges[this.edgeBeingEditedId];
                      this._performEditEdge(edge.from, edge.to);
                      return;
                    }
                  }
                  if (this.guiEnabled === true) {
                    var locale = this.options.locales[this.options.locale];
                    this.manipulationDOM = {};
                    this._createBackButton(locale);
                    this._createSeperator();
                    this._createDescription(locale["editEdgeDescription"] || this.options.locales["en"]["editEdgeDescription"]);
                    this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
                  }
                  this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
                  if (this.edgeBeingEditedId !== void 0) {
                    var _edge = this.body.edges[this.edgeBeingEditedId];
                    var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);
                    var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);
                    this.temporaryIds.nodes.push(controlNodeFrom.id);
                    this.temporaryIds.nodes.push(controlNodeTo.id);
                    this.body.nodes[controlNodeFrom.id] = controlNodeFrom;
                    this.body.nodeIndices.push(controlNodeFrom.id);
                    this.body.nodes[controlNodeTo.id] = controlNodeTo;
                    this.body.nodeIndices.push(controlNodeTo.id);
                    this._temporaryBindUI("onTouch", this._controlNodeTouch.bind(this));
                    this._temporaryBindUI("onTap", function() {
                    });
                    this._temporaryBindUI("onHold", function() {
                    });
                    this._temporaryBindUI("onDragStart", this._controlNodeDragStart.bind(this));
                    this._temporaryBindUI("onDrag", this._controlNodeDrag.bind(this));
                    this._temporaryBindUI("onDragEnd", this._controlNodeDragEnd.bind(this));
                    this._temporaryBindUI("onMouseMove", function() {
                    });
                    this._temporaryBindEvent("beforeDrawing", function(ctx) {
                      var positions = _edge.edgeType.findBorderPositions(ctx);
                      if (controlNodeFrom.selected === false) {
                        controlNodeFrom.x = positions.from.x;
                        controlNodeFrom.y = positions.from.y;
                      }
                      if (controlNodeTo.selected === false) {
                        controlNodeTo.x = positions.to.x;
                        controlNodeTo.y = positions.to.y;
                      }
                    });
                    this.body.emitter.emit("_redraw");
                  } else {
                    this.showManipulatorToolbar();
                  }
                }
              }, {
                key: "deleteSelected",
                value: function deleteSelected() {
                  var _this3 = this;
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  this.inMode = "delete";
                  var selectedNodes = this.selectionHandler.getSelectedNodes();
                  var selectedEdges = this.selectionHandler.getSelectedEdges();
                  var deleteFunction = void 0;
                  if (selectedNodes.length > 0) {
                    for (var i = 0; i < selectedNodes.length; i++) {
                      if (this.body.nodes[selectedNodes[i]].isCluster === true) {
                        alert(this.options.locales[this.options.locale]["deleteClusterError"] || this.options.locales["en"]["deleteClusterError"]);
                        return;
                      }
                    }
                    if (typeof this.options.deleteNode === "function") {
                      deleteFunction = this.options.deleteNode;
                    }
                  } else if (selectedEdges.length > 0) {
                    if (typeof this.options.deleteEdge === "function") {
                      deleteFunction = this.options.deleteEdge;
                    }
                  }
                  if (typeof deleteFunction === "function") {
                    var data = { nodes: selectedNodes, edges: selectedEdges };
                    if (deleteFunction.length === 2) {
                      deleteFunction(data, function(finalizedData) {
                        if (finalizedData !== null && finalizedData !== void 0 && _this3.inMode === "delete") {
                          _this3.body.data.edges.getDataSet().remove(finalizedData.edges);
                          _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);
                          _this3.body.emitter.emit("startSimulation");
                          _this3.showManipulatorToolbar();
                        } else {
                          _this3.body.emitter.emit("startSimulation");
                          _this3.showManipulatorToolbar();
                        }
                      });
                    } else {
                      throw new Error("The function for delete does not support two arguments (data, callback)");
                    }
                  } else {
                    this.body.data.edges.getDataSet().remove(selectedEdges);
                    this.body.data.nodes.getDataSet().remove(selectedNodes);
                    this.body.emitter.emit("startSimulation");
                    this.showManipulatorToolbar();
                  }
                }
              }, {
                key: "_setup",
                value: function _setup() {
                  if (this.options.enabled === true) {
                    this.guiEnabled = true;
                    this._createWrappers();
                    if (this.editMode === false) {
                      this._createEditButton();
                    } else {
                      this.showManipulatorToolbar();
                    }
                  } else {
                    this._removeManipulationDOM();
                    this.guiEnabled = false;
                  }
                }
              }, {
                key: "_createWrappers",
                value: function _createWrappers() {
                  if (this.manipulationDiv === void 0) {
                    this.manipulationDiv = document.createElement("div");
                    this.manipulationDiv.className = "vis-manipulation";
                    if (this.editMode === true) {
                      this.manipulationDiv.style.display = "block";
                    } else {
                      this.manipulationDiv.style.display = "none";
                    }
                    this.canvas.frame.appendChild(this.manipulationDiv);
                  }
                  if (this.editModeDiv === void 0) {
                    this.editModeDiv = document.createElement("div");
                    this.editModeDiv.className = "vis-edit-mode";
                    if (this.editMode === true) {
                      this.editModeDiv.style.display = "none";
                    } else {
                      this.editModeDiv.style.display = "block";
                    }
                    this.canvas.frame.appendChild(this.editModeDiv);
                  }
                  if (this.closeDiv === void 0) {
                    this.closeDiv = document.createElement("div");
                    this.closeDiv.className = "vis-close";
                    this.closeDiv.style.display = this.manipulationDiv.style.display;
                    this.canvas.frame.appendChild(this.closeDiv);
                  }
                }
              }, {
                key: "_getNewTargetNode",
                value: function _getNewTargetNode(x, y) {
                  var controlNodeStyle = util.deepExtend({}, this.options.controlNodeStyle);
                  controlNodeStyle.id = "targetNode" + util.randomUUID();
                  controlNodeStyle.hidden = false;
                  controlNodeStyle.physics = false;
                  controlNodeStyle.x = x;
                  controlNodeStyle.y = y;
                  var node = this.body.functions.createNode(controlNodeStyle);
                  node.shape.boundingBox = { left: x, right: x, top: y, bottom: y };
                  return node;
                }
              }, {
                key: "_createEditButton",
                value: function _createEditButton() {
                  this._clean();
                  this.manipulationDOM = {};
                  util.recursiveDOMDelete(this.editModeDiv);
                  var locale = this.options.locales[this.options.locale];
                  var button = this._createButton("editMode", "vis-button vis-edit vis-edit-mode", locale["edit"] || this.options.locales["en"]["edit"]);
                  this.editModeDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.toggleEditMode.bind(this));
                }
              }, {
                key: "_clean",
                value: function _clean() {
                  this.inMode = false;
                  if (this.guiEnabled === true) {
                    util.recursiveDOMDelete(this.editModeDiv);
                    util.recursiveDOMDelete(this.manipulationDiv);
                    this._cleanManipulatorHammers();
                  }
                  this._cleanupTemporaryNodesAndEdges();
                  this._unbindTemporaryUIs();
                  this._unbindTemporaryEvents();
                  this.body.emitter.emit("restorePhysics");
                }
              }, {
                key: "_cleanManipulatorHammers",
                value: function _cleanManipulatorHammers() {
                  if (this.manipulationHammers.length != 0) {
                    for (var i = 0; i < this.manipulationHammers.length; i++) {
                      this.manipulationHammers[i].destroy();
                    }
                    this.manipulationHammers = [];
                  }
                }
              }, {
                key: "_removeManipulationDOM",
                value: function _removeManipulationDOM() {
                  this._clean();
                  util.recursiveDOMDelete(this.manipulationDiv);
                  util.recursiveDOMDelete(this.editModeDiv);
                  util.recursiveDOMDelete(this.closeDiv);
                  if (this.manipulationDiv) {
                    this.canvas.frame.removeChild(this.manipulationDiv);
                  }
                  if (this.editModeDiv) {
                    this.canvas.frame.removeChild(this.editModeDiv);
                  }
                  if (this.closeDiv) {
                    this.canvas.frame.removeChild(this.closeDiv);
                  }
                  this.manipulationDiv = void 0;
                  this.editModeDiv = void 0;
                  this.closeDiv = void 0;
                }
              }, {
                key: "_createSeperator",
                value: function _createSeperator() {
                  var index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                  this.manipulationDOM["seperatorLineDiv" + index] = document.createElement("div");
                  this.manipulationDOM["seperatorLineDiv" + index].className = "vis-separator-line";
                  this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv" + index]);
                }
              }, {
                key: "_createAddNodeButton",
                value: function _createAddNodeButton(locale) {
                  var button = this._createButton("addNode", "vis-button vis-add", locale["addNode"] || this.options.locales["en"]["addNode"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.addNodeMode.bind(this));
                }
              }, {
                key: "_createAddEdgeButton",
                value: function _createAddEdgeButton(locale) {
                  var button = this._createButton("addEdge", "vis-button vis-connect", locale["addEdge"] || this.options.locales["en"]["addEdge"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.addEdgeMode.bind(this));
                }
              }, {
                key: "_createEditNodeButton",
                value: function _createEditNodeButton(locale) {
                  var button = this._createButton("editNode", "vis-button vis-edit", locale["editNode"] || this.options.locales["en"]["editNode"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.editNode.bind(this));
                }
              }, {
                key: "_createEditEdgeButton",
                value: function _createEditEdgeButton(locale) {
                  var button = this._createButton("editEdge", "vis-button vis-edit", locale["editEdge"] || this.options.locales["en"]["editEdge"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.editEdgeMode.bind(this));
                }
              }, {
                key: "_createDeleteButton",
                value: function _createDeleteButton(locale) {
                  var deleteBtnClass;
                  if (this.options.rtl) {
                    deleteBtnClass = "vis-button vis-delete-rtl";
                  } else {
                    deleteBtnClass = "vis-button vis-delete";
                  }
                  var button = this._createButton("delete", deleteBtnClass, locale["del"] || this.options.locales["en"]["del"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.deleteSelected.bind(this));
                }
              }, {
                key: "_createBackButton",
                value: function _createBackButton(locale) {
                  var button = this._createButton("back", "vis-button vis-back", locale["back"] || this.options.locales["en"]["back"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.showManipulatorToolbar.bind(this));
                }
              }, {
                key: "_createButton",
                value: function _createButton(id2, className, label) {
                  var labelClassName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "vis-label";
                  this.manipulationDOM[id2 + "Div"] = document.createElement("div");
                  this.manipulationDOM[id2 + "Div"].className = className;
                  this.manipulationDOM[id2 + "Label"] = document.createElement("div");
                  this.manipulationDOM[id2 + "Label"].className = labelClassName;
                  this.manipulationDOM[id2 + "Label"].innerHTML = label;
                  this.manipulationDOM[id2 + "Div"].appendChild(this.manipulationDOM[id2 + "Label"]);
                  return this.manipulationDOM[id2 + "Div"];
                }
              }, {
                key: "_createDescription",
                value: function _createDescription(label) {
                  this.manipulationDiv.appendChild(this._createButton("description", "vis-button vis-none", label));
                }
              }, {
                key: "_temporaryBindEvent",
                value: function _temporaryBindEvent(event, newFunction) {
                  this.temporaryEventFunctions.push({
                    event,
                    boundFunction: newFunction
                  });
                  this.body.emitter.on(event, newFunction);
                }
              }, {
                key: "_temporaryBindUI",
                value: function _temporaryBindUI(UIfunctionName, newFunction) {
                  if (this.body.eventListeners[UIfunctionName] !== void 0) {
                    this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
                    this.body.eventListeners[UIfunctionName] = newFunction;
                  } else {
                    throw new Error("This UI function does not exist. Typo? You tried: " + UIfunctionName + " possible are: " + (0, _stringify2["default"])((0, _keys2["default"])(this.body.eventListeners)));
                  }
                }
              }, {
                key: "_unbindTemporaryUIs",
                value: function _unbindTemporaryUIs() {
                  for (var functionName in this.temporaryUIFunctions) {
                    if (this.temporaryUIFunctions.hasOwnProperty(functionName)) {
                      this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
                      delete this.temporaryUIFunctions[functionName];
                    }
                  }
                  this.temporaryUIFunctions = {};
                }
              }, {
                key: "_unbindTemporaryEvents",
                value: function _unbindTemporaryEvents() {
                  for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
                    var eventName = this.temporaryEventFunctions[i].event;
                    var boundFunction = this.temporaryEventFunctions[i].boundFunction;
                    this.body.emitter.off(eventName, boundFunction);
                  }
                  this.temporaryEventFunctions = [];
                }
              }, {
                key: "_bindHammerToDiv",
                value: function _bindHammerToDiv(domElement, boundFunction) {
                  var hammer = new Hammer(domElement, {});
                  hammerUtil.onTouch(hammer, boundFunction);
                  this.manipulationHammers.push(hammer);
                }
              }, {
                key: "_cleanupTemporaryNodesAndEdges",
                value: function _cleanupTemporaryNodesAndEdges() {
                  for (var i = 0; i < this.temporaryIds.edges.length; i++) {
                    this.body.edges[this.temporaryIds.edges[i]].disconnect();
                    delete this.body.edges[this.temporaryIds.edges[i]];
                    var indexTempEdge = this.body.edgeIndices.indexOf(this.temporaryIds.edges[i]);
                    if (indexTempEdge !== -1) {
                      this.body.edgeIndices.splice(indexTempEdge, 1);
                    }
                  }
                  for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
                    delete this.body.nodes[this.temporaryIds.nodes[_i]];
                    var indexTempNode = this.body.nodeIndices.indexOf(this.temporaryIds.nodes[_i]);
                    if (indexTempNode !== -1) {
                      this.body.nodeIndices.splice(indexTempNode, 1);
                    }
                  }
                  this.temporaryIds = { nodes: [], edges: [] };
                }
              }, {
                key: "_controlNodeTouch",
                value: function _controlNodeTouch(event) {
                  this.selectionHandler.unselectAll();
                  this.lastTouch = this.body.functions.getPointer(event.center);
                  this.lastTouch.translation = util.extend({}, this.body.view.translation);
                }
              }, {
                key: "_controlNodeDragStart",
                value: function _controlNodeDragStart() {
                  var pointer = this.lastTouch;
                  var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
                  var from = this.body.nodes[this.temporaryIds.nodes[0]];
                  var to = this.body.nodes[this.temporaryIds.nodes[1]];
                  var edge = this.body.edges[this.edgeBeingEditedId];
                  this.selectedControlNode = void 0;
                  var fromSelect = from.isOverlappingWith(pointerObj);
                  var toSelect = to.isOverlappingWith(pointerObj);
                  if (fromSelect === true) {
                    this.selectedControlNode = from;
                    edge.edgeType.from = from;
                  } else if (toSelect === true) {
                    this.selectedControlNode = to;
                    edge.edgeType.to = to;
                  }
                  if (this.selectedControlNode !== void 0) {
                    this.selectionHandler.selectObject(this.selectedControlNode);
                  }
                  this.body.emitter.emit("_redraw");
                }
              }, {
                key: "_controlNodeDrag",
                value: function _controlNodeDrag(event) {
                  this.body.emitter.emit("disablePhysics");
                  var pointer = this.body.functions.getPointer(event.center);
                  var pos = this.canvas.DOMtoCanvas(pointer);
                  if (this.selectedControlNode !== void 0) {
                    this.selectedControlNode.x = pos.x;
                    this.selectedControlNode.y = pos.y;
                  } else {
                    var diffX = pointer.x - this.lastTouch.x;
                    var diffY = pointer.y - this.lastTouch.y;
                    this.body.view.translation = {
                      x: this.lastTouch.translation.x + diffX,
                      y: this.lastTouch.translation.y + diffY
                    };
                  }
                  this.body.emitter.emit("_redraw");
                }
              }, {
                key: "_controlNodeDragEnd",
                value: function _controlNodeDragEnd(event) {
                  var pointer = this.body.functions.getPointer(event.center);
                  var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
                  var edge = this.body.edges[this.edgeBeingEditedId];
                  if (this.selectedControlNode === void 0) {
                    return;
                  }
                  this.selectionHandler.unselectAll();
                  var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
                  var node = void 0;
                  for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
                    if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
                      node = this.body.nodes[overlappingNodeIds[i]];
                      break;
                    }
                  }
                  if (node !== void 0 && this.selectedControlNode !== void 0) {
                    if (node.isCluster === true) {
                      alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
                    } else {
                      var from = this.body.nodes[this.temporaryIds.nodes[0]];
                      if (this.selectedControlNode.id === from.id) {
                        this._performEditEdge(node.id, edge.to.id);
                      } else {
                        this._performEditEdge(edge.from.id, node.id);
                      }
                    }
                  } else {
                    edge.updateEdgeType();
                    this.body.emitter.emit("restorePhysics");
                  }
                  this.body.emitter.emit("_redraw");
                }
              }, {
                key: "_handleConnect",
                value: function _handleConnect(event) {
                  if (new Date().valueOf() - this.touchTime > 100) {
                    this.lastTouch = this.body.functions.getPointer(event.center);
                    this.lastTouch.translation = util.extend({}, this.body.view.translation);
                    var pointer = this.lastTouch;
                    var node = this.selectionHandler.getNodeAt(pointer);
                    if (node !== void 0) {
                      if (node.isCluster === true) {
                        alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
                      } else {
                        var targetNode = this._getNewTargetNode(node.x, node.y);
                        this.body.nodes[targetNode.id] = targetNode;
                        this.body.nodeIndices.push(targetNode.id);
                        var connectionEdge = this.body.functions.createEdge({
                          id: "connectionEdge" + util.randomUUID(),
                          from: node.id,
                          to: targetNode.id,
                          physics: false,
                          smooth: {
                            enabled: true,
                            type: "continuous",
                            roundness: 0.5
                          }
                        });
                        this.body.edges[connectionEdge.id] = connectionEdge;
                        this.body.edgeIndices.push(connectionEdge.id);
                        this.temporaryIds.nodes.push(targetNode.id);
                        this.temporaryIds.edges.push(connectionEdge.id);
                      }
                    }
                    this.touchTime = new Date().valueOf();
                  }
                }
              }, {
                key: "_dragControlNode",
                value: function _dragControlNode(event) {
                  var pointer = this.body.functions.getPointer(event.center);
                  var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
                  var connectFromId = void 0;
                  if (this.temporaryIds.edges[0] !== void 0) {
                    connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
                  }
                  var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
                  var node = void 0;
                  for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
                    if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {
                      node = this.body.nodes[overlappingNodeIds[i]];
                      break;
                    }
                  }
                  event.controlEdge = { from: connectFromId, to: node ? node.id : void 0 };
                  this.selectionHandler._generateClickEvent("controlNodeDragging", event, pointer);
                  if (this.temporaryIds.nodes[0] !== void 0) {
                    var targetNode = this.body.nodes[this.temporaryIds.nodes[0]];
                    targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
                    targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
                    this.body.emitter.emit("_redraw");
                  } else {
                    var diffX = pointer.x - this.lastTouch.x;
                    var diffY = pointer.y - this.lastTouch.y;
                    this.body.view.translation = {
                      x: this.lastTouch.translation.x + diffX,
                      y: this.lastTouch.translation.y + diffY
                    };
                  }
                }
              }, {
                key: "_finishConnect",
                value: function _finishConnect(event) {
                  var pointer = this.body.functions.getPointer(event.center);
                  var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
                  var connectFromId = void 0;
                  if (this.temporaryIds.edges[0] !== void 0) {
                    connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
                  }
                  var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
                  var node = void 0;
                  for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
                    if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {
                      node = this.body.nodes[overlappingNodeIds[i]];
                      break;
                    }
                  }
                  this._cleanupTemporaryNodesAndEdges();
                  if (node !== void 0) {
                    if (node.isCluster === true) {
                      alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
                    } else {
                      if (this.body.nodes[connectFromId] !== void 0 && this.body.nodes[node.id] !== void 0) {
                        this._performAddEdge(connectFromId, node.id);
                      }
                    }
                  }
                  event.controlEdge = { from: connectFromId, to: node ? node.id : void 0 };
                  this.selectionHandler._generateClickEvent("controlNodeDragEnd", event, pointer);
                  this.body.emitter.emit("_redraw");
                }
              }, {
                key: "_dragStartEdge",
                value: function _dragStartEdge(event) {
                  var pointer = this.lastTouch;
                  this.selectionHandler._generateClickEvent("dragStart", event, pointer, void 0, true);
                }
              }, {
                key: "_performAddNode",
                value: function _performAddNode(clickData) {
                  var _this4 = this;
                  var defaultData = {
                    id: util.randomUUID(),
                    x: clickData.pointer.canvas.x,
                    y: clickData.pointer.canvas.y,
                    label: "new"
                  };
                  if (typeof this.options.addNode === "function") {
                    if (this.options.addNode.length === 2) {
                      this.options.addNode(defaultData, function(finalizedData) {
                        if (finalizedData !== null && finalizedData !== void 0 && _this4.inMode === "addNode") {
                          _this4.body.data.nodes.getDataSet().add(finalizedData);
                        }
                        _this4.showManipulatorToolbar();
                      });
                    } else {
                      this.showManipulatorToolbar();
                      throw new Error("The function for add does not support two arguments (data,callback)");
                    }
                  } else {
                    this.body.data.nodes.getDataSet().add(defaultData);
                    this.showManipulatorToolbar();
                  }
                }
              }, {
                key: "_performAddEdge",
                value: function _performAddEdge(sourceNodeId, targetNodeId) {
                  var _this5 = this;
                  var defaultData = { from: sourceNodeId, to: targetNodeId };
                  if (typeof this.options.addEdge === "function") {
                    if (this.options.addEdge.length === 2) {
                      this.options.addEdge(defaultData, function(finalizedData) {
                        if (finalizedData !== null && finalizedData !== void 0 && _this5.inMode === "addEdge") {
                          _this5.body.data.edges.getDataSet().add(finalizedData);
                          _this5.selectionHandler.unselectAll();
                          _this5.showManipulatorToolbar();
                        }
                      });
                    } else {
                      throw new Error("The function for connect does not support two arguments (data,callback)");
                    }
                  } else {
                    this.body.data.edges.getDataSet().add(defaultData);
                    this.selectionHandler.unselectAll();
                    this.showManipulatorToolbar();
                  }
                }
              }, {
                key: "_performEditEdge",
                value: function _performEditEdge(sourceNodeId, targetNodeId) {
                  var _this6 = this;
                  var defaultData = {
                    id: this.edgeBeingEditedId,
                    from: sourceNodeId,
                    to: targetNodeId,
                    label: this.body.data.edges._data[this.edgeBeingEditedId].label
                  };
                  var eeFunct = this.options.editEdge;
                  if ((typeof eeFunct === "undefined" ? "undefined" : (0, _typeof3["default"])(eeFunct)) === "object") {
                    eeFunct = eeFunct.editWithoutDrag;
                  }
                  if (typeof eeFunct === "function") {
                    if (eeFunct.length === 2) {
                      eeFunct(defaultData, function(finalizedData) {
                        if (finalizedData === null || finalizedData === void 0 || _this6.inMode !== "editEdge") {
                          _this6.body.edges[defaultData.id].updateEdgeType();
                          _this6.body.emitter.emit("_redraw");
                          _this6.showManipulatorToolbar();
                        } else {
                          _this6.body.data.edges.getDataSet().update(finalizedData);
                          _this6.selectionHandler.unselectAll();
                          _this6.showManipulatorToolbar();
                        }
                      });
                    } else {
                      throw new Error("The function for edit does not support two arguments (data, callback)");
                    }
                  } else {
                    this.body.data.edges.getDataSet().update(defaultData);
                    this.selectionHandler.unselectAll();
                    this.showManipulatorToolbar();
                  }
                }
              }]);
              return ManipulationSystem2;
            }();
            exports2["default"] = ManipulationSystem;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _stringify = __webpack_require__(23);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(7);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var ColorPicker = __webpack_require__(192)["default"];
            var Configurator = function() {
              function Configurator2(parentModule, defaultContainer, configureOptions) {
                var pixelRatio = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
                (0, _classCallCheck3["default"])(this, Configurator2);
                this.parent = parentModule;
                this.changedOptions = [];
                this.container = defaultContainer;
                this.allowCreation = false;
                this.options = {};
                this.initialized = false;
                this.popupCounter = 0;
                this.defaultOptions = {
                  enabled: false,
                  filter: true,
                  container: void 0,
                  showButton: true
                };
                util.extend(this.options, this.defaultOptions);
                this.configureOptions = configureOptions;
                this.moduleOptions = {};
                this.domElements = [];
                this.popupDiv = {};
                this.popupLimit = 5;
                this.popupHistory = {};
                this.colorPicker = new ColorPicker(pixelRatio);
                this.wrapper = void 0;
              }
              (0, _createClass3["default"])(Configurator2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    this.popupHistory = {};
                    this._removePopup();
                    var enabled = true;
                    if (typeof options === "string") {
                      this.options.filter = options;
                    } else if (options instanceof Array) {
                      this.options.filter = options.join();
                    } else if ((typeof options === "undefined" ? "undefined" : (0, _typeof3["default"])(options)) === "object") {
                      if (options == null) {
                        throw new TypeError("options cannot be null");
                      }
                      if (options.container !== void 0) {
                        this.options.container = options.container;
                      }
                      if (options.filter !== void 0) {
                        this.options.filter = options.filter;
                      }
                      if (options.showButton !== void 0) {
                        this.options.showButton = options.showButton;
                      }
                      if (options.enabled !== void 0) {
                        enabled = options.enabled;
                      }
                    } else if (typeof options === "boolean") {
                      this.options.filter = true;
                      enabled = options;
                    } else if (typeof options === "function") {
                      this.options.filter = options;
                      enabled = true;
                    }
                    if (this.options.filter === false) {
                      enabled = false;
                    }
                    this.options.enabled = enabled;
                  }
                  this._clean();
                }
              }, {
                key: "setModuleOptions",
                value: function setModuleOptions(moduleOptions) {
                  this.moduleOptions = moduleOptions;
                  if (this.options.enabled === true) {
                    this._clean();
                    if (this.options.container !== void 0) {
                      this.container = this.options.container;
                    }
                    this._create();
                  }
                }
              }, {
                key: "_create",
                value: function _create() {
                  this._clean();
                  this.changedOptions = [];
                  var filter = this.options.filter;
                  var counter = 0;
                  var show2 = false;
                  for (var option in this.configureOptions) {
                    if (this.configureOptions.hasOwnProperty(option)) {
                      this.allowCreation = false;
                      show2 = false;
                      if (typeof filter === "function") {
                        show2 = filter(option, []);
                        show2 = show2 || this._handleObject(this.configureOptions[option], [option], true);
                      } else if (filter === true || filter.indexOf(option) !== -1) {
                        show2 = true;
                      }
                      if (show2 !== false) {
                        this.allowCreation = true;
                        if (counter > 0) {
                          this._makeItem([]);
                        }
                        this._makeHeader(option);
                        this._handleObject(this.configureOptions[option], [option]);
                      }
                      counter++;
                    }
                  }
                  this._makeButton();
                  this._push();
                }
              }, {
                key: "_push",
                value: function _push() {
                  this.wrapper = document.createElement("div");
                  this.wrapper.className = "vis-configuration-wrapper";
                  this.container.appendChild(this.wrapper);
                  for (var i = 0; i < this.domElements.length; i++) {
                    this.wrapper.appendChild(this.domElements[i]);
                  }
                  this._showPopupIfNeeded();
                }
              }, {
                key: "_clean",
                value: function _clean() {
                  for (var i = 0; i < this.domElements.length; i++) {
                    this.wrapper.removeChild(this.domElements[i]);
                  }
                  if (this.wrapper !== void 0) {
                    this.container.removeChild(this.wrapper);
                    this.wrapper = void 0;
                  }
                  this.domElements = [];
                  this._removePopup();
                }
              }, {
                key: "_getValue",
                value: function _getValue(path) {
                  var base = this.moduleOptions;
                  for (var i = 0; i < path.length; i++) {
                    if (base[path[i]] !== void 0) {
                      base = base[path[i]];
                    } else {
                      base = void 0;
                      break;
                    }
                  }
                  return base;
                }
              }, {
                key: "_makeItem",
                value: function _makeItem(path) {
                  if (this.allowCreation === true) {
                    var item = document.createElement("div");
                    item.className = "vis-configuration vis-config-item vis-config-s" + path.length;
                    for (var _len = arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      domElements[_key - 1] = arguments[_key];
                    }
                    domElements.forEach(function(element) {
                      item.appendChild(element);
                    });
                    this.domElements.push(item);
                    return this.domElements.length;
                  }
                  return 0;
                }
              }, {
                key: "_makeHeader",
                value: function _makeHeader(name) {
                  var div = document.createElement("div");
                  div.className = "vis-configuration vis-config-header";
                  div.innerHTML = name;
                  this._makeItem([], div);
                }
              }, {
                key: "_makeLabel",
                value: function _makeLabel(name, path) {
                  var objectLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var div = document.createElement("div");
                  div.className = "vis-configuration vis-config-label vis-config-s" + path.length;
                  if (objectLabel === true) {
                    div.innerHTML = "<i><b>" + name + ":</b></i>";
                  } else {
                    div.innerHTML = name + ":";
                  }
                  return div;
                }
              }, {
                key: "_makeDropdown",
                value: function _makeDropdown(arr, value, path) {
                  var select = document.createElement("select");
                  select.className = "vis-configuration vis-config-select";
                  var selectedValue = 0;
                  if (value !== void 0) {
                    if (arr.indexOf(value) !== -1) {
                      selectedValue = arr.indexOf(value);
                    }
                  }
                  for (var i = 0; i < arr.length; i++) {
                    var option = document.createElement("option");
                    option.value = arr[i];
                    if (i === selectedValue) {
                      option.selected = "selected";
                    }
                    option.innerHTML = arr[i];
                    select.appendChild(option);
                  }
                  var me = this;
                  select.onchange = function() {
                    me._update(this.value, path);
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  this._makeItem(path, label, select);
                }
              }, {
                key: "_makeRange",
                value: function _makeRange(arr, value, path) {
                  var defaultValue = arr[0];
                  var min = arr[1];
                  var max = arr[2];
                  var step = arr[3];
                  var range = document.createElement("input");
                  range.className = "vis-configuration vis-config-range";
                  try {
                    range.type = "range";
                    range.min = min;
                    range.max = max;
                  } catch (err) {
                  }
                  range.step = step;
                  var popupString = "";
                  var popupValue = 0;
                  if (value !== void 0) {
                    var factor = 1.2;
                    if (value < 0 && value * factor < min) {
                      range.min = Math.ceil(value * factor);
                      popupValue = range.min;
                      popupString = "range increased";
                    } else if (value / factor < min) {
                      range.min = Math.ceil(value / factor);
                      popupValue = range.min;
                      popupString = "range increased";
                    }
                    if (value * factor > max && max !== 1) {
                      range.max = Math.ceil(value * factor);
                      popupValue = range.max;
                      popupString = "range increased";
                    }
                    range.value = value;
                  } else {
                    range.value = defaultValue;
                  }
                  var input = document.createElement("input");
                  input.className = "vis-configuration vis-config-rangeinput";
                  input.value = range.value;
                  var me = this;
                  range.onchange = function() {
                    input.value = this.value;
                    me._update(Number(this.value), path);
                  };
                  range.oninput = function() {
                    input.value = this.value;
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  var itemIndex = this._makeItem(path, label, range, input);
                  if (popupString !== "" && this.popupHistory[itemIndex] !== popupValue) {
                    this.popupHistory[itemIndex] = popupValue;
                    this._setupPopup(popupString, itemIndex);
                  }
                }
              }, {
                key: "_makeButton",
                value: function _makeButton() {
                  var _this = this;
                  if (this.options.showButton === true) {
                    var generateButton = document.createElement("div");
                    generateButton.className = "vis-configuration vis-config-button";
                    generateButton.innerHTML = "generate options";
                    generateButton.onclick = function() {
                      _this._printOptions();
                    };
                    generateButton.onmouseover = function() {
                      generateButton.className = "vis-configuration vis-config-button hover";
                    };
                    generateButton.onmouseout = function() {
                      generateButton.className = "vis-configuration vis-config-button";
                    };
                    this.optionsContainer = document.createElement("div");
                    this.optionsContainer.className = "vis-configuration vis-config-option-container";
                    this.domElements.push(this.optionsContainer);
                    this.domElements.push(generateButton);
                  }
                }
              }, {
                key: "_setupPopup",
                value: function _setupPopup(string, index) {
                  var _this2 = this;
                  if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
                    var div = document.createElement("div");
                    div.id = "vis-configuration-popup";
                    div.className = "vis-configuration-popup";
                    div.innerHTML = string;
                    div.onclick = function() {
                      _this2._removePopup();
                    };
                    this.popupCounter += 1;
                    this.popupDiv = { html: div, index };
                  }
                }
              }, {
                key: "_removePopup",
                value: function _removePopup() {
                  if (this.popupDiv.html !== void 0) {
                    this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
                    clearTimeout(this.popupDiv.hideTimeout);
                    clearTimeout(this.popupDiv.deleteTimeout);
                    this.popupDiv = {};
                  }
                }
              }, {
                key: "_showPopupIfNeeded",
                value: function _showPopupIfNeeded() {
                  var _this3 = this;
                  if (this.popupDiv.html !== void 0) {
                    var correspondingElement = this.domElements[this.popupDiv.index];
                    var rect = correspondingElement.getBoundingClientRect();
                    this.popupDiv.html.style.left = rect.left + "px";
                    this.popupDiv.html.style.top = rect.top - 30 + "px";
                    document.body.appendChild(this.popupDiv.html);
                    this.popupDiv.hideTimeout = setTimeout(function() {
                      _this3.popupDiv.html.style.opacity = 0;
                    }, 1500);
                    this.popupDiv.deleteTimeout = setTimeout(function() {
                      _this3._removePopup();
                    }, 1800);
                  }
                }
              }, {
                key: "_makeCheckbox",
                value: function _makeCheckbox(defaultValue, value, path) {
                  var checkbox = document.createElement("input");
                  checkbox.type = "checkbox";
                  checkbox.className = "vis-configuration vis-config-checkbox";
                  checkbox.checked = defaultValue;
                  if (value !== void 0) {
                    checkbox.checked = value;
                    if (value !== defaultValue) {
                      if ((typeof defaultValue === "undefined" ? "undefined" : (0, _typeof3["default"])(defaultValue)) === "object") {
                        if (value !== defaultValue.enabled) {
                          this.changedOptions.push({ path, value });
                        }
                      } else {
                        this.changedOptions.push({ path, value });
                      }
                    }
                  }
                  var me = this;
                  checkbox.onchange = function() {
                    me._update(this.checked, path);
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  this._makeItem(path, label, checkbox);
                }
              }, {
                key: "_makeTextInput",
                value: function _makeTextInput(defaultValue, value, path) {
                  var checkbox = document.createElement("input");
                  checkbox.type = "text";
                  checkbox.className = "vis-configuration vis-config-text";
                  checkbox.value = value;
                  if (value !== defaultValue) {
                    this.changedOptions.push({ path, value });
                  }
                  var me = this;
                  checkbox.onchange = function() {
                    me._update(this.value, path);
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  this._makeItem(path, label, checkbox);
                }
              }, {
                key: "_makeColorField",
                value: function _makeColorField(arr, value, path) {
                  var _this4 = this;
                  var defaultColor = arr[1];
                  var div = document.createElement("div");
                  value = value === void 0 ? defaultColor : value;
                  if (value !== "none") {
                    div.className = "vis-configuration vis-config-colorBlock";
                    div.style.backgroundColor = value;
                  } else {
                    div.className = "vis-configuration vis-config-colorBlock none";
                  }
                  value = value === void 0 ? defaultColor : value;
                  div.onclick = function() {
                    _this4._showColorPicker(value, div, path);
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  this._makeItem(path, label, div);
                }
              }, {
                key: "_showColorPicker",
                value: function _showColorPicker(value, div, path) {
                  var _this5 = this;
                  div.onclick = function() {
                  };
                  this.colorPicker.insertTo(div);
                  this.colorPicker.show();
                  this.colorPicker.setColor(value);
                  this.colorPicker.setUpdateCallback(function(color) {
                    var colorString = "rgba(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
                    div.style.backgroundColor = colorString;
                    _this5._update(colorString, path);
                  });
                  this.colorPicker.setCloseCallback(function() {
                    div.onclick = function() {
                      _this5._showColorPicker(value, div, path);
                    };
                  });
                }
              }, {
                key: "_handleObject",
                value: function _handleObject(obj) {
                  var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                  var checkOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var show2 = false;
                  var filter = this.options.filter;
                  var visibleInSet = false;
                  for (var subObj in obj) {
                    if (obj.hasOwnProperty(subObj)) {
                      show2 = true;
                      var item = obj[subObj];
                      var newPath = util.copyAndExtendArray(path, subObj);
                      if (typeof filter === "function") {
                        show2 = filter(subObj, path);
                        if (show2 === false) {
                          if (!(item instanceof Array) && typeof item !== "string" && typeof item !== "boolean" && item instanceof Object) {
                            this.allowCreation = false;
                            show2 = this._handleObject(item, newPath, true);
                            this.allowCreation = checkOnly === false;
                          }
                        }
                      }
                      if (show2 !== false) {
                        visibleInSet = true;
                        var value = this._getValue(newPath);
                        if (item instanceof Array) {
                          this._handleArray(item, value, newPath);
                        } else if (typeof item === "string") {
                          this._makeTextInput(item, value, newPath);
                        } else if (typeof item === "boolean") {
                          this._makeCheckbox(item, value, newPath);
                        } else if (item instanceof Object) {
                          var draw = true;
                          if (path.indexOf("physics") !== -1) {
                            if (this.moduleOptions.physics.solver !== subObj) {
                              draw = false;
                            }
                          }
                          if (draw === true) {
                            if (item.enabled !== void 0) {
                              var enabledPath = util.copyAndExtendArray(newPath, "enabled");
                              var enabledValue = this._getValue(enabledPath);
                              if (enabledValue === true) {
                                var label = this._makeLabel(subObj, newPath, true);
                                this._makeItem(newPath, label);
                                visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                              } else {
                                this._makeCheckbox(item, enabledValue, newPath);
                              }
                            } else {
                              var _label = this._makeLabel(subObj, newPath, true);
                              this._makeItem(newPath, _label);
                              visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                            }
                          }
                        } else {
                          console.error("dont know how to handle", item, subObj, newPath);
                        }
                      }
                    }
                  }
                  return visibleInSet;
                }
              }, {
                key: "_handleArray",
                value: function _handleArray(arr, value, path) {
                  if (typeof arr[0] === "string" && arr[0] === "color") {
                    this._makeColorField(arr, value, path);
                    if (arr[1] !== value) {
                      this.changedOptions.push({ path, value });
                    }
                  } else if (typeof arr[0] === "string") {
                    this._makeDropdown(arr, value, path);
                    if (arr[0] !== value) {
                      this.changedOptions.push({ path, value });
                    }
                  } else if (typeof arr[0] === "number") {
                    this._makeRange(arr, value, path);
                    if (arr[0] !== value) {
                      this.changedOptions.push({ path, value: Number(value) });
                    }
                  }
                }
              }, {
                key: "_update",
                value: function _update(value, path) {
                  var options = this._constructOptions(value, path);
                  if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
                    this.parent.body.emitter.emit("configChange", options);
                  }
                  this.initialized = true;
                  this.parent.setOptions(options);
                }
              }, {
                key: "_constructOptions",
                value: function _constructOptions(value, path) {
                  var optionsObj = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  var pointer = optionsObj;
                  value = value === "true" ? true : value;
                  value = value === "false" ? false : value;
                  for (var i = 0; i < path.length; i++) {
                    if (path[i] !== "global") {
                      if (pointer[path[i]] === void 0) {
                        pointer[path[i]] = {};
                      }
                      if (i !== path.length - 1) {
                        pointer = pointer[path[i]];
                      } else {
                        pointer[path[i]] = value;
                      }
                    }
                  }
                  return optionsObj;
                }
              }, {
                key: "_printOptions",
                value: function _printOptions() {
                  var options = this.getOptions();
                  this.optionsContainer.innerHTML = "<pre>var options = " + (0, _stringify2["default"])(options, null, 2) + "</pre>";
                }
              }, {
                key: "getOptions",
                value: function getOptions() {
                  var options = {};
                  for (var i = 0; i < this.changedOptions.length; i++) {
                    this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
                  }
                  return options;
                }
              }]);
              return Configurator2;
            }();
            exports2["default"] = Configurator;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _stringify = __webpack_require__(23);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hammer = __webpack_require__(24);
            var hammerUtil = __webpack_require__(36);
            var util = __webpack_require__(2);
            var htmlColors = {
              black: "#000000",
              navy: "#000080",
              darkblue: "#00008B",
              mediumblue: "#0000CD",
              blue: "#0000FF",
              darkgreen: "#006400",
              green: "#008000",
              teal: "#008080",
              darkcyan: "#008B8B",
              deepskyblue: "#00BFFF",
              darkturquoise: "#00CED1",
              mediumspringgreen: "#00FA9A",
              lime: "#00FF00",
              springgreen: "#00FF7F",
              aqua: "#00FFFF",
              cyan: "#00FFFF",
              midnightblue: "#191970",
              dodgerblue: "#1E90FF",
              lightseagreen: "#20B2AA",
              forestgreen: "#228B22",
              seagreen: "#2E8B57",
              darkslategray: "#2F4F4F",
              limegreen: "#32CD32",
              mediumseagreen: "#3CB371",
              turquoise: "#40E0D0",
              royalblue: "#4169E1",
              steelblue: "#4682B4",
              darkslateblue: "#483D8B",
              mediumturquoise: "#48D1CC",
              indigo: "#4B0082",
              darkolivegreen: "#556B2F",
              cadetblue: "#5F9EA0",
              cornflowerblue: "#6495ED",
              mediumaquamarine: "#66CDAA",
              dimgray: "#696969",
              slateblue: "#6A5ACD",
              olivedrab: "#6B8E23",
              slategray: "#708090",
              lightslategray: "#778899",
              mediumslateblue: "#7B68EE",
              lawngreen: "#7CFC00",
              chartreuse: "#7FFF00",
              aquamarine: "#7FFFD4",
              maroon: "#800000",
              purple: "#800080",
              olive: "#808000",
              gray: "#808080",
              skyblue: "#87CEEB",
              lightskyblue: "#87CEFA",
              blueviolet: "#8A2BE2",
              darkred: "#8B0000",
              darkmagenta: "#8B008B",
              saddlebrown: "#8B4513",
              darkseagreen: "#8FBC8F",
              lightgreen: "#90EE90",
              mediumpurple: "#9370D8",
              darkviolet: "#9400D3",
              palegreen: "#98FB98",
              darkorchid: "#9932CC",
              yellowgreen: "#9ACD32",
              sienna: "#A0522D",
              brown: "#A52A2A",
              darkgray: "#A9A9A9",
              lightblue: "#ADD8E6",
              greenyellow: "#ADFF2F",
              paleturquoise: "#AFEEEE",
              lightsteelblue: "#B0C4DE",
              powderblue: "#B0E0E6",
              firebrick: "#B22222",
              darkgoldenrod: "#B8860B",
              mediumorchid: "#BA55D3",
              rosybrown: "#BC8F8F",
              darkkhaki: "#BDB76B",
              silver: "#C0C0C0",
              mediumvioletred: "#C71585",
              indianred: "#CD5C5C",
              peru: "#CD853F",
              chocolate: "#D2691E",
              tan: "#D2B48C",
              lightgrey: "#D3D3D3",
              palevioletred: "#D87093",
              thistle: "#D8BFD8",
              orchid: "#DA70D6",
              goldenrod: "#DAA520",
              crimson: "#DC143C",
              gainsboro: "#DCDCDC",
              plum: "#DDA0DD",
              burlywood: "#DEB887",
              lightcyan: "#E0FFFF",
              lavender: "#E6E6FA",
              darksalmon: "#E9967A",
              violet: "#EE82EE",
              palegoldenrod: "#EEE8AA",
              lightcoral: "#F08080",
              khaki: "#F0E68C",
              aliceblue: "#F0F8FF",
              honeydew: "#F0FFF0",
              azure: "#F0FFFF",
              sandybrown: "#F4A460",
              wheat: "#F5DEB3",
              beige: "#F5F5DC",
              whitesmoke: "#F5F5F5",
              mintcream: "#F5FFFA",
              ghostwhite: "#F8F8FF",
              salmon: "#FA8072",
              antiquewhite: "#FAEBD7",
              linen: "#FAF0E6",
              lightgoldenrodyellow: "#FAFAD2",
              oldlace: "#FDF5E6",
              red: "#FF0000",
              fuchsia: "#FF00FF",
              magenta: "#FF00FF",
              deeppink: "#FF1493",
              orangered: "#FF4500",
              tomato: "#FF6347",
              hotpink: "#FF69B4",
              coral: "#FF7F50",
              darkorange: "#FF8C00",
              lightsalmon: "#FFA07A",
              orange: "#FFA500",
              lightpink: "#FFB6C1",
              pink: "#FFC0CB",
              gold: "#FFD700",
              peachpuff: "#FFDAB9",
              navajowhite: "#FFDEAD",
              moccasin: "#FFE4B5",
              bisque: "#FFE4C4",
              mistyrose: "#FFE4E1",
              blanchedalmond: "#FFEBCD",
              papayawhip: "#FFEFD5",
              lavenderblush: "#FFF0F5",
              seashell: "#FFF5EE",
              cornsilk: "#FFF8DC",
              lemonchiffon: "#FFFACD",
              floralwhite: "#FFFAF0",
              snow: "#FFFAFA",
              yellow: "#FFFF00",
              lightyellow: "#FFFFE0",
              ivory: "#FFFFF0",
              white: "#FFFFFF"
            };
            var ColorPicker = function() {
              function ColorPicker2() {
                var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                (0, _classCallCheck3["default"])(this, ColorPicker2);
                this.pixelRatio = pixelRatio;
                this.generated = false;
                this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
                this.r = 289 * 0.49;
                this.color = { r: 255, g: 255, b: 255, a: 1 };
                this.hueCircle = void 0;
                this.initialColor = { r: 255, g: 255, b: 255, a: 1 };
                this.previousColor = void 0;
                this.applied = false;
                this.updateCallback = function() {
                };
                this.closeCallback = function() {
                };
                this._create();
              }
              (0, _createClass3["default"])(ColorPicker2, [{
                key: "insertTo",
                value: function insertTo(container) {
                  if (this.hammer !== void 0) {
                    this.hammer.destroy();
                    this.hammer = void 0;
                  }
                  this.container = container;
                  this.container.appendChild(this.frame);
                  this._bindHammer();
                  this._setSize();
                }
              }, {
                key: "setUpdateCallback",
                value: function setUpdateCallback(callback) {
                  if (typeof callback === "function") {
                    this.updateCallback = callback;
                  } else {
                    throw new Error("Function attempted to set as colorPicker update callback is not a function.");
                  }
                }
              }, {
                key: "setCloseCallback",
                value: function setCloseCallback(callback) {
                  if (typeof callback === "function") {
                    this.closeCallback = callback;
                  } else {
                    throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
                  }
                }
              }, {
                key: "_isColorString",
                value: function _isColorString(color) {
                  if (typeof color === "string") {
                    return htmlColors[color];
                  }
                }
              }, {
                key: "setColor",
                value: function setColor(color) {
                  var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (color === "none") {
                    return;
                  }
                  var rgba = void 0;
                  var htmlColor = this._isColorString(color);
                  if (htmlColor !== void 0) {
                    color = htmlColor;
                  }
                  if (util.isString(color) === true) {
                    if (util.isValidRGB(color) === true) {
                      var rgbaArray = color.substr(4).substr(0, color.length - 5).split(",");
                      rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1 };
                    } else if (util.isValidRGBA(color) === true) {
                      var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(",");
                      rgba = {
                        r: _rgbaArray[0],
                        g: _rgbaArray[1],
                        b: _rgbaArray[2],
                        a: _rgbaArray[3]
                      };
                    } else if (util.isValidHex(color) === true) {
                      var rgbObj = util.hexToRGB(color);
                      rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1 };
                    }
                  } else {
                    if (color instanceof Object) {
                      if (color.r !== void 0 && color.g !== void 0 && color.b !== void 0) {
                        var alpha = color.a !== void 0 ? color.a : "1.0";
                        rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
                      }
                    }
                  }
                  if (rgba === void 0) {
                    throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + (0, _stringify2["default"])(color));
                  } else {
                    this._setColor(rgba, setInitial);
                  }
                }
              }, {
                key: "show",
                value: function show2() {
                  if (this.closeCallback !== void 0) {
                    this.closeCallback();
                    this.closeCallback = void 0;
                  }
                  this.applied = false;
                  this.frame.style.display = "block";
                  this._generateHueCircle();
                }
              }, {
                key: "_hide",
                value: function _hide() {
                  var _this = this;
                  var storePrevious = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                  if (storePrevious === true) {
                    this.previousColor = util.extend({}, this.color);
                  }
                  if (this.applied === true) {
                    this.updateCallback(this.initialColor);
                  }
                  this.frame.style.display = "none";
                  setTimeout(function() {
                    if (_this.closeCallback !== void 0) {
                      _this.closeCallback();
                      _this.closeCallback = void 0;
                    }
                  }, 0);
                }
              }, {
                key: "_save",
                value: function _save() {
                  this.updateCallback(this.color);
                  this.applied = false;
                  this._hide();
                }
              }, {
                key: "_apply",
                value: function _apply() {
                  this.applied = true;
                  this.updateCallback(this.color);
                  this._updatePicker(this.color);
                }
              }, {
                key: "_loadLast",
                value: function _loadLast() {
                  if (this.previousColor !== void 0) {
                    this.setColor(this.previousColor, false);
                  } else {
                    alert("There is no last color to load...");
                  }
                }
              }, {
                key: "_setColor",
                value: function _setColor(rgba) {
                  var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (setInitial === true) {
                    this.initialColor = util.extend({}, rgba);
                  }
                  this.color = rgba;
                  var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
                  var angleConvert = 2 * Math.PI;
                  var radius = this.r * hsv.s;
                  var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
                  var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
                  this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + "px";
                  this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + "px";
                  this._updatePicker(rgba);
                }
              }, {
                key: "_setOpacity",
                value: function _setOpacity(value) {
                  this.color.a = value / 100;
                  this._updatePicker(this.color);
                }
              }, {
                key: "_setBrightness",
                value: function _setBrightness(value) {
                  var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
                  hsv.v = value / 100;
                  var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
                  rgba["a"] = this.color.a;
                  this.color = rgba;
                  this._updatePicker();
                }
              }, {
                key: "_updatePicker",
                value: function _updatePicker() {
                  var rgba = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.color;
                  var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
                  var ctx = this.colorPickerCanvas.getContext("2d");
                  if (this.pixelRation === void 0) {
                    this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
                  }
                  ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                  var w = this.colorPickerCanvas.clientWidth;
                  var h = this.colorPickerCanvas.clientHeight;
                  ctx.clearRect(0, 0, w, h);
                  ctx.putImageData(this.hueCircle, 0, 0);
                  ctx.fillStyle = "rgba(0,0,0," + (1 - hsv.v) + ")";
                  ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
                  ctx.fill();
                  this.brightnessRange.value = 100 * hsv.v;
                  this.opacityRange.value = 100 * rgba.a;
                  this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
                  this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
                }
              }, {
                key: "_setSize",
                value: function _setSize() {
                  this.colorPickerCanvas.style.width = "100%";
                  this.colorPickerCanvas.style.height = "100%";
                  this.colorPickerCanvas.width = 289 * this.pixelRatio;
                  this.colorPickerCanvas.height = 289 * this.pixelRatio;
                }
              }, {
                key: "_create",
                value: function _create() {
                  this.frame = document.createElement("div");
                  this.frame.className = "vis-color-picker";
                  this.colorPickerDiv = document.createElement("div");
                  this.colorPickerSelector = document.createElement("div");
                  this.colorPickerSelector.className = "vis-selector";
                  this.colorPickerDiv.appendChild(this.colorPickerSelector);
                  this.colorPickerCanvas = document.createElement("canvas");
                  this.colorPickerDiv.appendChild(this.colorPickerCanvas);
                  if (!this.colorPickerCanvas.getContext) {
                    var noCanvas = document.createElement("DIV");
                    noCanvas.style.color = "red";
                    noCanvas.style.fontWeight = "bold";
                    noCanvas.style.padding = "10px";
                    noCanvas.innerHTML = "Error: your browser does not support HTML canvas";
                    this.colorPickerCanvas.appendChild(noCanvas);
                  } else {
                    var ctx = this.colorPickerCanvas.getContext("2d");
                    this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
                    this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                  }
                  this.colorPickerDiv.className = "vis-color";
                  this.opacityDiv = document.createElement("div");
                  this.opacityDiv.className = "vis-opacity";
                  this.brightnessDiv = document.createElement("div");
                  this.brightnessDiv.className = "vis-brightness";
                  this.arrowDiv = document.createElement("div");
                  this.arrowDiv.className = "vis-arrow";
                  this.opacityRange = document.createElement("input");
                  try {
                    this.opacityRange.type = "range";
                    this.opacityRange.min = "0";
                    this.opacityRange.max = "100";
                  } catch (err) {
                  }
                  this.opacityRange.value = "100";
                  this.opacityRange.className = "vis-range";
                  this.brightnessRange = document.createElement("input");
                  try {
                    this.brightnessRange.type = "range";
                    this.brightnessRange.min = "0";
                    this.brightnessRange.max = "100";
                  } catch (err) {
                  }
                  this.brightnessRange.value = "100";
                  this.brightnessRange.className = "vis-range";
                  this.opacityDiv.appendChild(this.opacityRange);
                  this.brightnessDiv.appendChild(this.brightnessRange);
                  var me = this;
                  this.opacityRange.onchange = function() {
                    me._setOpacity(this.value);
                  };
                  this.opacityRange.oninput = function() {
                    me._setOpacity(this.value);
                  };
                  this.brightnessRange.onchange = function() {
                    me._setBrightness(this.value);
                  };
                  this.brightnessRange.oninput = function() {
                    me._setBrightness(this.value);
                  };
                  this.brightnessLabel = document.createElement("div");
                  this.brightnessLabel.className = "vis-label vis-brightness";
                  this.brightnessLabel.innerHTML = "brightness:";
                  this.opacityLabel = document.createElement("div");
                  this.opacityLabel.className = "vis-label vis-opacity";
                  this.opacityLabel.innerHTML = "opacity:";
                  this.newColorDiv = document.createElement("div");
                  this.newColorDiv.className = "vis-new-color";
                  this.newColorDiv.innerHTML = "new";
                  this.initialColorDiv = document.createElement("div");
                  this.initialColorDiv.className = "vis-initial-color";
                  this.initialColorDiv.innerHTML = "initial";
                  this.cancelButton = document.createElement("div");
                  this.cancelButton.className = "vis-button vis-cancel";
                  this.cancelButton.innerHTML = "cancel";
                  this.cancelButton.onclick = this._hide.bind(this, false);
                  this.applyButton = document.createElement("div");
                  this.applyButton.className = "vis-button vis-apply";
                  this.applyButton.innerHTML = "apply";
                  this.applyButton.onclick = this._apply.bind(this);
                  this.saveButton = document.createElement("div");
                  this.saveButton.className = "vis-button vis-save";
                  this.saveButton.innerHTML = "save";
                  this.saveButton.onclick = this._save.bind(this);
                  this.loadButton = document.createElement("div");
                  this.loadButton.className = "vis-button vis-load";
                  this.loadButton.innerHTML = "load last";
                  this.loadButton.onclick = this._loadLast.bind(this);
                  this.frame.appendChild(this.colorPickerDiv);
                  this.frame.appendChild(this.arrowDiv);
                  this.frame.appendChild(this.brightnessLabel);
                  this.frame.appendChild(this.brightnessDiv);
                  this.frame.appendChild(this.opacityLabel);
                  this.frame.appendChild(this.opacityDiv);
                  this.frame.appendChild(this.newColorDiv);
                  this.frame.appendChild(this.initialColorDiv);
                  this.frame.appendChild(this.cancelButton);
                  this.frame.appendChild(this.applyButton);
                  this.frame.appendChild(this.saveButton);
                  this.frame.appendChild(this.loadButton);
                }
              }, {
                key: "_bindHammer",
                value: function _bindHammer() {
                  var _this2 = this;
                  this.drag = {};
                  this.pinch = {};
                  this.hammer = new Hammer(this.colorPickerCanvas);
                  this.hammer.get("pinch").set({ enable: true });
                  hammerUtil.onTouch(this.hammer, function(event) {
                    _this2._moveSelector(event);
                  });
                  this.hammer.on("tap", function(event) {
                    _this2._moveSelector(event);
                  });
                  this.hammer.on("panstart", function(event) {
                    _this2._moveSelector(event);
                  });
                  this.hammer.on("panmove", function(event) {
                    _this2._moveSelector(event);
                  });
                  this.hammer.on("panend", function(event) {
                    _this2._moveSelector(event);
                  });
                }
              }, {
                key: "_generateHueCircle",
                value: function _generateHueCircle() {
                  if (this.generated === false) {
                    var ctx = this.colorPickerCanvas.getContext("2d");
                    if (this.pixelRation === void 0) {
                      this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
                    }
                    ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                    var w = this.colorPickerCanvas.clientWidth;
                    var h = this.colorPickerCanvas.clientHeight;
                    ctx.clearRect(0, 0, w, h);
                    var x = void 0, y = void 0, hue = void 0, sat = void 0;
                    this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
                    this.r = 0.49 * w;
                    var angleConvert = 2 * Math.PI / 360;
                    var hfac = 1 / 360;
                    var sfac = 1 / this.r;
                    var rgb = void 0;
                    for (hue = 0; hue < 360; hue++) {
                      for (sat = 0; sat < this.r; sat++) {
                        x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
                        y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
                        rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
                        ctx.fillStyle = "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
                        ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
                      }
                    }
                    ctx.strokeStyle = "rgba(0,0,0,1)";
                    ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
                    ctx.stroke();
                    this.hueCircle = ctx.getImageData(0, 0, w, h);
                  }
                  this.generated = true;
                }
              }, {
                key: "_moveSelector",
                value: function _moveSelector(event) {
                  var rect = this.colorPickerDiv.getBoundingClientRect();
                  var left = event.center.x - rect.left;
                  var top = event.center.y - rect.top;
                  var centerY = 0.5 * this.colorPickerDiv.clientHeight;
                  var centerX = 0.5 * this.colorPickerDiv.clientWidth;
                  var x = left - centerX;
                  var y = top - centerY;
                  var angle = Math.atan2(x, y);
                  var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);
                  var newTop = Math.cos(angle) * radius + centerY;
                  var newLeft = Math.sin(angle) * radius + centerX;
                  this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + "px";
                  this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + "px";
                  var h = angle / (2 * Math.PI);
                  h = h < 0 ? h + 1 : h;
                  var s = radius / this.r;
                  var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
                  hsv.h = h;
                  hsv.s = s;
                  var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
                  rgba["a"] = this.color.a;
                  this.color = rgba;
                  this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
                  this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
                }
              }]);
              return ColorPicker2;
            }();
            exports2["default"] = ColorPicker;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(15);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _FloydWarshall = __webpack_require__(194);
            var _FloydWarshall2 = _interopRequireDefault(_FloydWarshall);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var KamadaKawai = function() {
              function KamadaKawai2(body, edgeLength, edgeStrength) {
                (0, _classCallCheck3["default"])(this, KamadaKawai2);
                this.body = body;
                this.springLength = edgeLength;
                this.springConstant = edgeStrength;
                this.distanceSolver = new _FloydWarshall2["default"]();
              }
              (0, _createClass3["default"])(KamadaKawai2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (options) {
                    if (options.springLength) {
                      this.springLength = options.springLength;
                    }
                    if (options.springConstant) {
                      this.springConstant = options.springConstant;
                    }
                  }
                }
              }, {
                key: "solve",
                value: function solve(nodesArray, edgesArray) {
                  var ignoreClusters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray);
                  this._createL_matrix(D_matrix);
                  this._createK_matrix(D_matrix);
                  this._createE_matrix();
                  var threshold = 0.01;
                  var innerThreshold = 1;
                  var iterations = 0;
                  var maxIterations = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3));
                  var maxInnerIterations = 5;
                  var maxEnergy = 1e9;
                  var highE_nodeId = 0, dE_dx = 0, dE_dy = 0, delta_m = 0, subIterations = 0;
                  while (maxEnergy > threshold && iterations < maxIterations) {
                    iterations += 1;
                    var _getHighestEnergyNode2 = this._getHighestEnergyNode(ignoreClusters);
                    var _getHighestEnergyNode3 = (0, _slicedToArray3["default"])(_getHighestEnergyNode2, 4);
                    highE_nodeId = _getHighestEnergyNode3[0];
                    maxEnergy = _getHighestEnergyNode3[1];
                    dE_dx = _getHighestEnergyNode3[2];
                    dE_dy = _getHighestEnergyNode3[3];
                    delta_m = maxEnergy;
                    subIterations = 0;
                    while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
                      subIterations += 1;
                      this._moveNode(highE_nodeId, dE_dx, dE_dy);
                      var _getEnergy2 = this._getEnergy(highE_nodeId);
                      var _getEnergy3 = (0, _slicedToArray3["default"])(_getEnergy2, 3);
                      delta_m = _getEnergy3[0];
                      dE_dx = _getEnergy3[1];
                      dE_dy = _getEnergy3[2];
                    }
                  }
                }
              }, {
                key: "_getHighestEnergyNode",
                value: function _getHighestEnergyNode(ignoreClusters) {
                  var nodesArray = this.body.nodeIndices;
                  var nodes2 = this.body.nodes;
                  var maxEnergy = 0;
                  var maxEnergyNodeId = nodesArray[0];
                  var dE_dx_max = 0, dE_dy_max = 0;
                  for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
                    var m = nodesArray[nodeIdx];
                    if (nodes2[m].predefinedPosition === false || nodes2[m].isCluster === true && ignoreClusters === true || nodes2[m].options.fixed.x === true || nodes2[m].options.fixed.y === true) {
                      var _getEnergy4 = this._getEnergy(m), _getEnergy5 = (0, _slicedToArray3["default"])(_getEnergy4, 3), delta_m = _getEnergy5[0], dE_dx = _getEnergy5[1], dE_dy = _getEnergy5[2];
                      if (maxEnergy < delta_m) {
                        maxEnergy = delta_m;
                        maxEnergyNodeId = m;
                        dE_dx_max = dE_dx;
                        dE_dy_max = dE_dy;
                      }
                    }
                  }
                  return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
                }
              }, {
                key: "_getEnergy",
                value: function _getEnergy(m) {
                  var _E_sums$m = (0, _slicedToArray3["default"])(this.E_sums[m], 2), dE_dx = _E_sums$m[0], dE_dy = _E_sums$m[1];
                  var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
                  return [delta_m, dE_dx, dE_dy];
                }
              }, {
                key: "_moveNode",
                value: function _moveNode(m, dE_dx, dE_dy) {
                  var nodesArray = this.body.nodeIndices;
                  var nodes2 = this.body.nodes;
                  var d2E_dx2 = 0;
                  var d2E_dxdy = 0;
                  var d2E_dy2 = 0;
                  var x_m = nodes2[m].x;
                  var y_m = nodes2[m].y;
                  var km = this.K_matrix[m];
                  var lm = this.L_matrix[m];
                  for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
                    var i = nodesArray[iIdx];
                    if (i !== m) {
                      var x_i = nodes2[i].x;
                      var y_i = nodes2[i].y;
                      var kmat = km[i];
                      var lmat = lm[i];
                      var denominator = 1 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
                      d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);
                      d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);
                      d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);
                    }
                  }
                  var A = d2E_dx2, B = d2E_dxdy, C = dE_dx, D = d2E_dy2, E = dE_dy;
                  var dy = (C / A + E / B) / (B / A - D / B);
                  var dx = -(B * dy + C) / A;
                  nodes2[m].x += dx;
                  nodes2[m].y += dy;
                  this._updateE_matrix(m);
                }
              }, {
                key: "_createL_matrix",
                value: function _createL_matrix(D_matrix) {
                  var nodesArray = this.body.nodeIndices;
                  var edgeLength = this.springLength;
                  this.L_matrix = [];
                  for (var i = 0; i < nodesArray.length; i++) {
                    this.L_matrix[nodesArray[i]] = {};
                    for (var j = 0; j < nodesArray.length; j++) {
                      this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
                    }
                  }
                }
              }, {
                key: "_createK_matrix",
                value: function _createK_matrix(D_matrix) {
                  var nodesArray = this.body.nodeIndices;
                  var edgeStrength = this.springConstant;
                  this.K_matrix = [];
                  for (var i = 0; i < nodesArray.length; i++) {
                    this.K_matrix[nodesArray[i]] = {};
                    for (var j = 0; j < nodesArray.length; j++) {
                      this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
                    }
                  }
                }
              }, {
                key: "_createE_matrix",
                value: function _createE_matrix() {
                  var nodesArray = this.body.nodeIndices;
                  var nodes2 = this.body.nodes;
                  this.E_matrix = {};
                  this.E_sums = {};
                  for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {
                    this.E_matrix[nodesArray[mIdx]] = [];
                  }
                  for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {
                    var m = nodesArray[_mIdx];
                    var x_m = nodes2[m].x;
                    var y_m = nodes2[m].y;
                    var dE_dx = 0;
                    var dE_dy = 0;
                    for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {
                      var i = nodesArray[iIdx];
                      if (i !== m) {
                        var x_i = nodes2[i].x;
                        var y_i = nodes2[i].y;
                        var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
                        this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];
                        this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];
                        dE_dx += this.E_matrix[m][iIdx][0];
                        dE_dy += this.E_matrix[m][iIdx][1];
                      }
                    }
                    this.E_sums[m] = [dE_dx, dE_dy];
                  }
                }
              }, {
                key: "_updateE_matrix",
                value: function _updateE_matrix(m) {
                  var nodesArray = this.body.nodeIndices;
                  var nodes2 = this.body.nodes;
                  var colm = this.E_matrix[m];
                  var kcolm = this.K_matrix[m];
                  var lcolm = this.L_matrix[m];
                  var x_m = nodes2[m].x;
                  var y_m = nodes2[m].y;
                  var dE_dx = 0;
                  var dE_dy = 0;
                  for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
                    var i = nodesArray[iIdx];
                    if (i !== m) {
                      var cell = colm[iIdx];
                      var oldDx = cell[0];
                      var oldDy = cell[1];
                      var x_i = nodes2[i].x;
                      var y_i = nodes2[i].y;
                      var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
                      var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);
                      var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);
                      colm[iIdx] = [dx, dy];
                      dE_dx += dx;
                      dE_dy += dy;
                      var sum = this.E_sums[i];
                      sum[0] += dx - oldDx;
                      sum[1] += dy - oldDy;
                    }
                  }
                  this.E_sums[m] = [dE_dx, dE_dy];
                }
              }]);
              return KamadaKawai2;
            }();
            exports2["default"] = KamadaKawai;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var FloydWarshall = function() {
              function FloydWarshall2() {
                (0, _classCallCheck3["default"])(this, FloydWarshall2);
              }
              (0, _createClass3["default"])(FloydWarshall2, [{
                key: "getDistances",
                value: function getDistances(body, nodesArray, edgesArray) {
                  var D_matrix = {};
                  var edges2 = body.edges;
                  for (var i = 0; i < nodesArray.length; i++) {
                    var node = nodesArray[i];
                    var cell = {};
                    D_matrix[node] = cell;
                    for (var j = 0; j < nodesArray.length; j++) {
                      cell[nodesArray[j]] = i == j ? 0 : 1e9;
                    }
                  }
                  for (var _i = 0; _i < edgesArray.length; _i++) {
                    var edge = edges2[edgesArray[_i]];
                    if (edge.connected === true && D_matrix[edge.fromId] !== void 0 && D_matrix[edge.toId] !== void 0) {
                      D_matrix[edge.fromId][edge.toId] = 1;
                      D_matrix[edge.toId][edge.fromId] = 1;
                    }
                  }
                  var nodeCount = nodesArray.length;
                  for (var k = 0; k < nodeCount; k++) {
                    var knode = nodesArray[k];
                    var kcolm = D_matrix[knode];
                    for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
                      var inode = nodesArray[_i2];
                      var icolm = D_matrix[inode];
                      for (var _j = _i2 + 1; _j < nodeCount; _j++) {
                        var jnode = nodesArray[_j];
                        var jcolm = D_matrix[jnode];
                        var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);
                        icolm[jnode] = val;
                        jcolm[inode] = val;
                      }
                    }
                  }
                  return D_matrix;
                }
              }]);
              return FloydWarshall2;
            }();
            exports2["default"] = FloydWarshall;
          }
        ]);
      });
    }
  });

  // node_modules/dat.gui/build/dat.gui.module.js
  function ___$insertStyle(css2) {
    if (!css2) {
      return;
    }
    if (typeof window === "undefined") {
      return;
    }
    var style = document.createElement("style");
    style.setAttribute("type", "text/css");
    style.innerHTML = css2;
    document.head.appendChild(style);
    return css2;
  }
  function colorToString(color, forceCSSHex) {
    var colorFormat = color.__state.conversionName.toString();
    var r = Math.round(color.r);
    var g = Math.round(color.g);
    var b = Math.round(color.b);
    var a = color.a;
    var h = Math.round(color.h);
    var s = color.s.toFixed(1);
    var v = color.v.toFixed(1);
    if (forceCSSHex || colorFormat === "THREE_CHAR_HEX" || colorFormat === "SIX_CHAR_HEX") {
      var str = color.hex.toString(16);
      while (str.length < 6) {
        str = "0" + str;
      }
      return "#" + str;
    } else if (colorFormat === "CSS_RGB") {
      return "rgb(" + r + "," + g + "," + b + ")";
    } else if (colorFormat === "CSS_RGBA") {
      return "rgba(" + r + "," + g + "," + b + "," + a + ")";
    } else if (colorFormat === "HEX") {
      return "0x" + color.hex.toString(16);
    } else if (colorFormat === "RGB_ARRAY") {
      return "[" + r + "," + g + "," + b + "]";
    } else if (colorFormat === "RGBA_ARRAY") {
      return "[" + r + "," + g + "," + b + "," + a + "]";
    } else if (colorFormat === "RGB_OBJ") {
      return "{r:" + r + ",g:" + g + ",b:" + b + "}";
    } else if (colorFormat === "RGBA_OBJ") {
      return "{r:" + r + ",g:" + g + ",b:" + b + ",a:" + a + "}";
    } else if (colorFormat === "HSV_OBJ") {
      return "{h:" + h + ",s:" + s + ",v:" + v + "}";
    } else if (colorFormat === "HSVA_OBJ") {
      return "{h:" + h + ",s:" + s + ",v:" + v + ",a:" + a + "}";
    }
    return "unknown format";
  }
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;
  var Common = {
    BREAK: {},
    extend: function extend(target) {
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : [];
        keys.forEach(function(key) {
          if (!this.isUndefined(obj[key])) {
            target[key] = obj[key];
          }
        }.bind(this));
      }, this);
      return target;
    },
    defaults: function defaults(target) {
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : [];
        keys.forEach(function(key) {
          if (this.isUndefined(target[key])) {
            target[key] = obj[key];
          }
        }.bind(this));
      }, this);
      return target;
    },
    compose: function compose() {
      var toCall = ARR_SLICE.call(arguments);
      return function() {
        var args = ARR_SLICE.call(arguments);
        for (var i = toCall.length - 1; i >= 0; i--) {
          args = [toCall[i].apply(this, args)];
        }
        return args[0];
      };
    },
    each: function each(obj, itr, scope) {
      if (!obj) {
        return;
      }
      if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
        obj.forEach(itr, scope);
      } else if (obj.length === obj.length + 0) {
        var key = void 0;
        var l = void 0;
        for (key = 0, l = obj.length; key < l; key++) {
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
            return;
          }
        }
      } else {
        for (var _key in obj) {
          if (itr.call(scope, obj[_key], _key) === this.BREAK) {
            return;
          }
        }
      }
    },
    defer: function defer(fnc) {
      setTimeout(fnc, 0);
    },
    debounce: function debounce(func, threshold, callImmediately) {
      var timeout = void 0;
      return function() {
        var obj = this;
        var args = arguments;
        function delayed() {
          timeout = null;
          if (!callImmediately)
            func.apply(obj, args);
        }
        var callNow = callImmediately || !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(delayed, threshold);
        if (callNow) {
          func.apply(obj, args);
        }
      };
    },
    toArray: function toArray(obj) {
      if (obj.toArray)
        return obj.toArray();
      return ARR_SLICE.call(obj);
    },
    isUndefined: function isUndefined(obj) {
      return obj === void 0;
    },
    isNull: function isNull(obj) {
      return obj === null;
    },
    isNaN: function(_isNaN) {
      function isNaN2(_x) {
        return _isNaN.apply(this, arguments);
      }
      isNaN2.toString = function() {
        return _isNaN.toString();
      };
      return isNaN2;
    }(function(obj) {
      return isNaN(obj);
    }),
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    isObject: function isObject(obj) {
      return obj === Object(obj);
    },
    isNumber: function isNumber(obj) {
      return obj === obj + 0;
    },
    isString: function isString(obj) {
      return obj === obj + "";
    },
    isBoolean: function isBoolean(obj) {
      return obj === false || obj === true;
    },
    isFunction: function isFunction(obj) {
      return obj instanceof Function;
    }
  };
  var INTERPRETATIONS = [
    {
      litmus: Common.isString,
      conversions: {
        THREE_CHAR_HEX: {
          read: function read(original) {
            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) {
              return false;
            }
            return {
              space: "HEX",
              hex: parseInt("0x" + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
            };
          },
          write: colorToString
        },
        SIX_CHAR_HEX: {
          read: function read2(original) {
            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) {
              return false;
            }
            return {
              space: "HEX",
              hex: parseInt("0x" + test[1].toString(), 0)
            };
          },
          write: colorToString
        },
        CSS_RGB: {
          read: function read3(original) {
            var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
            if (test === null) {
              return false;
            }
            return {
              space: "RGB",
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };
          },
          write: colorToString
        },
        CSS_RGBA: {
          read: function read4(original) {
            var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
            if (test === null) {
              return false;
            }
            return {
              space: "RGB",
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };
          },
          write: colorToString
        }
      }
    },
    {
      litmus: Common.isNumber,
      conversions: {
        HEX: {
          read: function read5(original) {
            return {
              space: "HEX",
              hex: original,
              conversionName: "HEX"
            };
          },
          write: function write(color) {
            return color.hex;
          }
        }
      }
    },
    {
      litmus: Common.isArray,
      conversions: {
        RGB_ARRAY: {
          read: function read6(original) {
            if (original.length !== 3) {
              return false;
            }
            return {
              space: "RGB",
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },
          write: function write2(color) {
            return [color.r, color.g, color.b];
          }
        },
        RGBA_ARRAY: {
          read: function read7(original) {
            if (original.length !== 4)
              return false;
            return {
              space: "RGB",
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },
          write: function write3(color) {
            return [color.r, color.g, color.b, color.a];
          }
        }
      }
    },
    {
      litmus: Common.isObject,
      conversions: {
        RGBA_OBJ: {
          read: function read8(original) {
            if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
              return {
                space: "RGB",
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              };
            }
            return false;
          },
          write: function write4(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            };
          }
        },
        RGB_OBJ: {
          read: function read9(original) {
            if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
              return {
                space: "RGB",
                r: original.r,
                g: original.g,
                b: original.b
              };
            }
            return false;
          },
          write: function write5(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            };
          }
        },
        HSVA_OBJ: {
          read: function read10(original) {
            if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
              return {
                space: "HSV",
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              };
            }
            return false;
          },
          write: function write6(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            };
          }
        },
        HSV_OBJ: {
          read: function read11(original) {
            if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
              return {
                space: "HSV",
                h: original.h,
                s: original.s,
                v: original.v
              };
            }
            return false;
          },
          write: function write7(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            };
          }
        }
      }
    }
  ];
  var result = void 0;
  var toReturn = void 0;
  var interpret = function interpret2() {
    toReturn = false;
    var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
    Common.each(INTERPRETATIONS, function(family) {
      if (family.litmus(original)) {
        Common.each(family.conversions, function(conversion, conversionName) {
          result = conversion.read(original);
          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return Common.BREAK;
          }
        });
        return Common.BREAK;
      }
    });
    return toReturn;
  };
  var tmpComponent = void 0;
  var ColorMath = {
    hsv_to_rgb: function hsv_to_rgb(h, s, v) {
      var hi = Math.floor(h / 60) % 6;
      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1 - s);
      var q = v * (1 - f * s);
      var t = v * (1 - (1 - f) * s);
      var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };
    },
    rgb_to_hsv: function rgb_to_hsv(r, g, b) {
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h = void 0;
      var s = void 0;
      if (max !== 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }
      if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }
      return {
        h: h * 360,
        s,
        v: max / 255
      };
    },
    rgb_to_hex: function rgb_to_hex(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },
    component_from_hex: function component_from_hex(hex, componentIndex) {
      return hex >> componentIndex * 8 & 255;
    },
    hex_with_component: function hex_with_component(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | hex & ~(255 << tmpComponent);
    }
  };
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var get = function get2(object, property, receiver) {
    if (object === null)
      object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === void 0) {
      var parent = Object.getPrototypeOf(object);
      if (parent === null) {
        return void 0;
      } else {
        return get2(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;
      if (getter === void 0) {
        return void 0;
      }
      return getter.call(receiver);
    }
  };
  var inherits = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  var possibleConstructorReturn = function(self2, call) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self2;
  };
  var Color = function() {
    function Color2() {
      classCallCheck(this, Color2);
      this.__state = interpret.apply(this, arguments);
      if (this.__state === false) {
        throw new Error("Failed to interpret color arguments");
      }
      this.__state.a = this.__state.a || 1;
    }
    createClass(Color2, [{
      key: "toString",
      value: function toString() {
        return colorToString(this);
      }
    }, {
      key: "toHexString",
      value: function toHexString() {
        return colorToString(this, true);
      }
    }, {
      key: "toOriginal",
      value: function toOriginal() {
        return this.__state.conversion.write(this);
      }
    }]);
    return Color2;
  }();
  function defineRGBComponent(target, component, componentHexIndex) {
    Object.defineProperty(target, component, {
      get: function get$$13() {
        if (this.__state.space === "RGB") {
          return this.__state[component];
        }
        Color.recalculateRGB(this, component, componentHexIndex);
        return this.__state[component];
      },
      set: function set$$13(v) {
        if (this.__state.space !== "RGB") {
          Color.recalculateRGB(this, component, componentHexIndex);
          this.__state.space = "RGB";
        }
        this.__state[component] = v;
      }
    });
  }
  function defineHSVComponent(target, component) {
    Object.defineProperty(target, component, {
      get: function get$$13() {
        if (this.__state.space === "HSV") {
          return this.__state[component];
        }
        Color.recalculateHSV(this);
        return this.__state[component];
      },
      set: function set$$13(v) {
        if (this.__state.space !== "HSV") {
          Color.recalculateHSV(this);
          this.__state.space = "HSV";
        }
        this.__state[component] = v;
      }
    });
  }
  Color.recalculateRGB = function(color, component, componentHexIndex) {
    if (color.__state.space === "HEX") {
      color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
    } else if (color.__state.space === "HSV") {
      Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
    } else {
      throw new Error("Corrupted color state");
    }
  };
  Color.recalculateHSV = function(color) {
    var result2 = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
    Common.extend(color.__state, {
      s: result2.s,
      v: result2.v
    });
    if (!Common.isNaN(result2.h)) {
      color.__state.h = result2.h;
    } else if (Common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }
  };
  Color.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"];
  defineRGBComponent(Color.prototype, "r", 2);
  defineRGBComponent(Color.prototype, "g", 1);
  defineRGBComponent(Color.prototype, "b", 0);
  defineHSVComponent(Color.prototype, "h");
  defineHSVComponent(Color.prototype, "s");
  defineHSVComponent(Color.prototype, "v");
  Object.defineProperty(Color.prototype, "a", {
    get: function get$$1() {
      return this.__state.a;
    },
    set: function set$$1(v) {
      this.__state.a = v;
    }
  });
  Object.defineProperty(Color.prototype, "hex", {
    get: function get$$12() {
      if (this.__state.space !== "HEX") {
        this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
        this.__state.space = "HEX";
      }
      return this.__state.hex;
    },
    set: function set$$12(v) {
      this.__state.space = "HEX";
      this.__state.hex = v;
    }
  });
  var Controller = function() {
    function Controller2(object, property) {
      classCallCheck(this, Controller2);
      this.initialValue = object[property];
      this.domElement = document.createElement("div");
      this.object = object;
      this.property = property;
      this.__onChange = void 0;
      this.__onFinishChange = void 0;
    }
    createClass(Controller2, [{
      key: "onChange",
      value: function onChange(fnc) {
        this.__onChange = fnc;
        return this;
      }
    }, {
      key: "onFinishChange",
      value: function onFinishChange(fnc) {
        this.__onFinishChange = fnc;
        return this;
      }
    }, {
      key: "setValue",
      value: function setValue(newValue) {
        this.object[this.property] = newValue;
        if (this.__onChange) {
          this.__onChange.call(this, newValue);
        }
        this.updateDisplay();
        return this;
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this.object[this.property];
      }
    }, {
      key: "updateDisplay",
      value: function updateDisplay2() {
        return this;
      }
    }, {
      key: "isModified",
      value: function isModified() {
        return this.initialValue !== this.getValue();
      }
    }]);
    return Controller2;
  }();
  var EVENT_MAP = {
    HTMLEvents: ["change"],
    MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
    KeyboardEvents: ["keydown"]
  };
  var EVENT_MAP_INV = {};
  Common.each(EVENT_MAP, function(v, k) {
    Common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });
  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
  function cssValueToPixels(val) {
    if (val === "0" || Common.isUndefined(val)) {
      return 0;
    }
    var match = val.match(CSS_VALUE_PIXELS);
    if (!Common.isNull(match)) {
      return parseFloat(match[1]);
    }
    return 0;
  }
  var dom = {
    makeSelectable: function makeSelectable(elem, selectable) {
      if (elem === void 0 || elem.style === void 0)
        return;
      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };
      elem.style.MozUserSelect = selectable ? "auto" : "none";
      elem.style.KhtmlUserSelect = selectable ? "auto" : "none";
      elem.unselectable = selectable ? "on" : "off";
    },
    makeFullscreen: function makeFullscreen(elem, hor, vert) {
      var vertical = vert;
      var horizontal = hor;
      if (Common.isUndefined(horizontal)) {
        horizontal = true;
      }
      if (Common.isUndefined(vertical)) {
        vertical = true;
      }
      elem.style.position = "absolute";
      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }
    },
    fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
      var params = pars || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error("Event type " + eventType + " not supported.");
      }
      var evt = document.createEvent(className);
      switch (className) {
        case "MouseEvents": {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(
            eventType,
            params.bubbles || false,
            params.cancelable || true,
            window,
            params.clickCount || 1,
            0,
            0,
            clientX,
            clientY,
            false,
            false,
            false,
            false,
            0,
            null
          );
          break;
        }
        case "KeyboardEvents": {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: void 0,
            charCode: void 0
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
        default: {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
      }
      Common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },
    bind: function bind(elem, event, func, newBool) {
      var bool = newBool || false;
      if (elem.addEventListener) {
        elem.addEventListener(event, func, bool);
      } else if (elem.attachEvent) {
        elem.attachEvent("on" + event, func);
      }
      return dom;
    },
    unbind: function unbind(elem, event, func, newBool) {
      var bool = newBool || false;
      if (elem.removeEventListener) {
        elem.removeEventListener(event, func, bool);
      } else if (elem.detachEvent) {
        elem.detachEvent("on" + event, func);
      }
      return dom;
    },
    addClass: function addClass(elem, className) {
      if (elem.className === void 0) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) === -1) {
          classes.push(className);
          elem.className = classes.join(" ").replace(/^\s+/, "").replace(/\s+$/, "");
        }
      }
      return dom;
    },
    removeClass: function removeClass(elem, className) {
      if (className) {
        if (elem.className === className) {
          elem.removeAttribute("class");
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index !== -1) {
            classes.splice(index, 1);
            elem.className = classes.join(" ");
          }
        }
      } else {
        elem.className = void 0;
      }
      return dom;
    },
    hasClass: function hasClass(elem, className) {
      return new RegExp("(?:^|\\s+)" + className + "(?:\\s+|$)").test(elem.className) || false;
    },
    getWidth: function getWidth(elem) {
      var style = getComputedStyle(elem);
      return cssValueToPixels(style["border-left-width"]) + cssValueToPixels(style["border-right-width"]) + cssValueToPixels(style["padding-left"]) + cssValueToPixels(style["padding-right"]) + cssValueToPixels(style.width);
    },
    getHeight: function getHeight(elem) {
      var style = getComputedStyle(elem);
      return cssValueToPixels(style["border-top-width"]) + cssValueToPixels(style["border-bottom-width"]) + cssValueToPixels(style["padding-top"]) + cssValueToPixels(style["padding-bottom"]) + cssValueToPixels(style.height);
    },
    getOffset: function getOffset(el) {
      var elem = el;
      var offset = { left: 0, top: 0 };
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
          elem = elem.offsetParent;
        } while (elem);
      }
      return offset;
    },
    isActive: function isActive(elem) {
      return elem === document.activeElement && (elem.type || elem.href);
    }
  };
  var BooleanController = function(_Controller) {
    inherits(BooleanController2, _Controller);
    function BooleanController2(object, property) {
      classCallCheck(this, BooleanController2);
      var _this2 = possibleConstructorReturn(this, (BooleanController2.__proto__ || Object.getPrototypeOf(BooleanController2)).call(this, object, property));
      var _this = _this2;
      _this2.__prev = _this2.getValue();
      _this2.__checkbox = document.createElement("input");
      _this2.__checkbox.setAttribute("type", "checkbox");
      function onChange() {
        _this.setValue(!_this.__prev);
      }
      dom.bind(_this2.__checkbox, "change", onChange, false);
      _this2.domElement.appendChild(_this2.__checkbox);
      _this2.updateDisplay();
      return _this2;
    }
    createClass(BooleanController2, [{
      key: "setValue",
      value: function setValue(v) {
        var toReturn2 = get(BooleanController2.prototype.__proto__ || Object.getPrototypeOf(BooleanController2.prototype), "setValue", this).call(this, v);
        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }
        this.__prev = this.getValue();
        return toReturn2;
      }
    }, {
      key: "updateDisplay",
      value: function updateDisplay2() {
        if (this.getValue() === true) {
          this.__checkbox.setAttribute("checked", "checked");
          this.__checkbox.checked = true;
          this.__prev = true;
        } else {
          this.__checkbox.checked = false;
          this.__prev = false;
        }
        return get(BooleanController2.prototype.__proto__ || Object.getPrototypeOf(BooleanController2.prototype), "updateDisplay", this).call(this);
      }
    }]);
    return BooleanController2;
  }(Controller);
  var OptionController = function(_Controller) {
    inherits(OptionController2, _Controller);
    function OptionController2(object, property, opts) {
      classCallCheck(this, OptionController2);
      var _this2 = possibleConstructorReturn(this, (OptionController2.__proto__ || Object.getPrototypeOf(OptionController2)).call(this, object, property));
      var options = opts;
      var _this = _this2;
      _this2.__select = document.createElement("select");
      if (Common.isArray(options)) {
        var map2 = {};
        Common.each(options, function(element) {
          map2[element] = element;
        });
        options = map2;
      }
      Common.each(options, function(value, key) {
        var opt = document.createElement("option");
        opt.innerHTML = key;
        opt.setAttribute("value", value);
        _this.__select.appendChild(opt);
      });
      _this2.updateDisplay();
      dom.bind(_this2.__select, "change", function() {
        var desiredValue = this.options[this.selectedIndex].value;
        _this.setValue(desiredValue);
      });
      _this2.domElement.appendChild(_this2.__select);
      return _this2;
    }
    createClass(OptionController2, [{
      key: "setValue",
      value: function setValue(v) {
        var toReturn2 = get(OptionController2.prototype.__proto__ || Object.getPrototypeOf(OptionController2.prototype), "setValue", this).call(this, v);
        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }
        return toReturn2;
      }
    }, {
      key: "updateDisplay",
      value: function updateDisplay2() {
        if (dom.isActive(this.__select))
          return this;
        this.__select.value = this.getValue();
        return get(OptionController2.prototype.__proto__ || Object.getPrototypeOf(OptionController2.prototype), "updateDisplay", this).call(this);
      }
    }]);
    return OptionController2;
  }(Controller);
  var StringController = function(_Controller) {
    inherits(StringController2, _Controller);
    function StringController2(object, property) {
      classCallCheck(this, StringController2);
      var _this2 = possibleConstructorReturn(this, (StringController2.__proto__ || Object.getPrototypeOf(StringController2)).call(this, object, property));
      var _this = _this2;
      function onChange() {
        _this.setValue(_this.__input.value);
      }
      function onBlur() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }
      _this2.__input = document.createElement("input");
      _this2.__input.setAttribute("type", "text");
      dom.bind(_this2.__input, "keyup", onChange);
      dom.bind(_this2.__input, "change", onChange);
      dom.bind(_this2.__input, "blur", onBlur);
      dom.bind(_this2.__input, "keydown", function(e) {
        if (e.keyCode === 13) {
          this.blur();
        }
      });
      _this2.updateDisplay();
      _this2.domElement.appendChild(_this2.__input);
      return _this2;
    }
    createClass(StringController2, [{
      key: "updateDisplay",
      value: function updateDisplay2() {
        if (!dom.isActive(this.__input)) {
          this.__input.value = this.getValue();
        }
        return get(StringController2.prototype.__proto__ || Object.getPrototypeOf(StringController2.prototype), "updateDisplay", this).call(this);
      }
    }]);
    return StringController2;
  }(Controller);
  function numDecimals(x) {
    var _x = x.toString();
    if (_x.indexOf(".") > -1) {
      return _x.length - _x.indexOf(".") - 1;
    }
    return 0;
  }
  var NumberController = function(_Controller) {
    inherits(NumberController2, _Controller);
    function NumberController2(object, property, params) {
      classCallCheck(this, NumberController2);
      var _this = possibleConstructorReturn(this, (NumberController2.__proto__ || Object.getPrototypeOf(NumberController2)).call(this, object, property));
      var _params = params || {};
      _this.__min = _params.min;
      _this.__max = _params.max;
      _this.__step = _params.step;
      if (Common.isUndefined(_this.__step)) {
        if (_this.initialValue === 0) {
          _this.__impliedStep = 1;
        } else {
          _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
        }
      } else {
        _this.__impliedStep = _this.__step;
      }
      _this.__precision = numDecimals(_this.__impliedStep);
      return _this;
    }
    createClass(NumberController2, [{
      key: "setValue",
      value: function setValue(v) {
        var _v = v;
        if (this.__min !== void 0 && _v < this.__min) {
          _v = this.__min;
        } else if (this.__max !== void 0 && _v > this.__max) {
          _v = this.__max;
        }
        if (this.__step !== void 0 && _v % this.__step !== 0) {
          _v = Math.round(_v / this.__step) * this.__step;
        }
        return get(NumberController2.prototype.__proto__ || Object.getPrototypeOf(NumberController2.prototype), "setValue", this).call(this, _v);
      }
    }, {
      key: "min",
      value: function min(minValue) {
        this.__min = minValue;
        return this;
      }
    }, {
      key: "max",
      value: function max(maxValue) {
        this.__max = maxValue;
        return this;
      }
    }, {
      key: "step",
      value: function step(stepValue) {
        this.__step = stepValue;
        this.__impliedStep = stepValue;
        this.__precision = numDecimals(stepValue);
        return this;
      }
    }]);
    return NumberController2;
  }(Controller);
  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }
  var NumberControllerBox = function(_NumberController) {
    inherits(NumberControllerBox2, _NumberController);
    function NumberControllerBox2(object, property, params) {
      classCallCheck(this, NumberControllerBox2);
      var _this2 = possibleConstructorReturn(this, (NumberControllerBox2.__proto__ || Object.getPrototypeOf(NumberControllerBox2)).call(this, object, property, params));
      _this2.__truncationSuspended = false;
      var _this = _this2;
      var prevY = void 0;
      function onChange() {
        var attempted = parseFloat(_this.__input.value);
        if (!Common.isNaN(attempted)) {
          _this.setValue(attempted);
        }
      }
      function onFinish() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }
      function onBlur() {
        onFinish();
      }
      function onMouseDrag(e) {
        var diff = prevY - e.clientY;
        _this.setValue(_this.getValue() + diff * _this.__impliedStep);
        prevY = e.clientY;
      }
      function onMouseUp() {
        dom.unbind(window, "mousemove", onMouseDrag);
        dom.unbind(window, "mouseup", onMouseUp);
        onFinish();
      }
      function onMouseDown(e) {
        dom.bind(window, "mousemove", onMouseDrag);
        dom.bind(window, "mouseup", onMouseUp);
        prevY = e.clientY;
      }
      _this2.__input = document.createElement("input");
      _this2.__input.setAttribute("type", "text");
      dom.bind(_this2.__input, "change", onChange);
      dom.bind(_this2.__input, "blur", onBlur);
      dom.bind(_this2.__input, "mousedown", onMouseDown);
      dom.bind(_this2.__input, "keydown", function(e) {
        if (e.keyCode === 13) {
          _this.__truncationSuspended = true;
          this.blur();
          _this.__truncationSuspended = false;
          onFinish();
        }
      });
      _this2.updateDisplay();
      _this2.domElement.appendChild(_this2.__input);
      return _this2;
    }
    createClass(NumberControllerBox2, [{
      key: "updateDisplay",
      value: function updateDisplay2() {
        this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
        return get(NumberControllerBox2.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox2.prototype), "updateDisplay", this).call(this);
      }
    }]);
    return NumberControllerBox2;
  }(NumberController);
  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }
  var NumberControllerSlider = function(_NumberController) {
    inherits(NumberControllerSlider2, _NumberController);
    function NumberControllerSlider2(object, property, min, max, step) {
      classCallCheck(this, NumberControllerSlider2);
      var _this2 = possibleConstructorReturn(this, (NumberControllerSlider2.__proto__ || Object.getPrototypeOf(NumberControllerSlider2)).call(this, object, property, { min, max, step }));
      var _this = _this2;
      _this2.__background = document.createElement("div");
      _this2.__foreground = document.createElement("div");
      dom.bind(_this2.__background, "mousedown", onMouseDown);
      dom.bind(_this2.__background, "touchstart", onTouchStart);
      dom.addClass(_this2.__background, "slider");
      dom.addClass(_this2.__foreground, "slider-fg");
      function onMouseDown(e) {
        document.activeElement.blur();
        dom.bind(window, "mousemove", onMouseDrag);
        dom.bind(window, "mouseup", onMouseUp);
        onMouseDrag(e);
      }
      function onMouseDrag(e) {
        e.preventDefault();
        var bgRect = _this.__background.getBoundingClientRect();
        _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
        return false;
      }
      function onMouseUp() {
        dom.unbind(window, "mousemove", onMouseDrag);
        dom.unbind(window, "mouseup", onMouseUp);
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }
      function onTouchStart(e) {
        if (e.touches.length !== 1) {
          return;
        }
        dom.bind(window, "touchmove", onTouchMove);
        dom.bind(window, "touchend", onTouchEnd);
        onTouchMove(e);
      }
      function onTouchMove(e) {
        var clientX = e.touches[0].clientX;
        var bgRect = _this.__background.getBoundingClientRect();
        _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      }
      function onTouchEnd() {
        dom.unbind(window, "touchmove", onTouchMove);
        dom.unbind(window, "touchend", onTouchEnd);
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }
      _this2.updateDisplay();
      _this2.__background.appendChild(_this2.__foreground);
      _this2.domElement.appendChild(_this2.__background);
      return _this2;
    }
    createClass(NumberControllerSlider2, [{
      key: "updateDisplay",
      value: function updateDisplay2() {
        var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
        this.__foreground.style.width = pct * 100 + "%";
        return get(NumberControllerSlider2.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider2.prototype), "updateDisplay", this).call(this);
      }
    }]);
    return NumberControllerSlider2;
  }(NumberController);
  var FunctionController = function(_Controller) {
    inherits(FunctionController2, _Controller);
    function FunctionController2(object, property, text) {
      classCallCheck(this, FunctionController2);
      var _this2 = possibleConstructorReturn(this, (FunctionController2.__proto__ || Object.getPrototypeOf(FunctionController2)).call(this, object, property));
      var _this = _this2;
      _this2.__button = document.createElement("div");
      _this2.__button.innerHTML = text === void 0 ? "Fire" : text;
      dom.bind(_this2.__button, "click", function(e) {
        e.preventDefault();
        _this.fire();
        return false;
      });
      dom.addClass(_this2.__button, "button");
      _this2.domElement.appendChild(_this2.__button);
      return _this2;
    }
    createClass(FunctionController2, [{
      key: "fire",
      value: function fire() {
        if (this.__onChange) {
          this.__onChange.call(this);
        }
        this.getValue().call(this.object);
        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }
      }
    }]);
    return FunctionController2;
  }(Controller);
  var ColorController = function(_Controller) {
    inherits(ColorController2, _Controller);
    function ColorController2(object, property) {
      classCallCheck(this, ColorController2);
      var _this2 = possibleConstructorReturn(this, (ColorController2.__proto__ || Object.getPrototypeOf(ColorController2)).call(this, object, property));
      _this2.__color = new Color(_this2.getValue());
      _this2.__temp = new Color(0);
      var _this = _this2;
      _this2.domElement = document.createElement("div");
      dom.makeSelectable(_this2.domElement, false);
      _this2.__selector = document.createElement("div");
      _this2.__selector.className = "selector";
      _this2.__saturation_field = document.createElement("div");
      _this2.__saturation_field.className = "saturation-field";
      _this2.__field_knob = document.createElement("div");
      _this2.__field_knob.className = "field-knob";
      _this2.__field_knob_border = "2px solid ";
      _this2.__hue_knob = document.createElement("div");
      _this2.__hue_knob.className = "hue-knob";
      _this2.__hue_field = document.createElement("div");
      _this2.__hue_field.className = "hue-field";
      _this2.__input = document.createElement("input");
      _this2.__input.type = "text";
      _this2.__input_textShadow = "0 1px 1px ";
      dom.bind(_this2.__input, "keydown", function(e) {
        if (e.keyCode === 13) {
          onBlur.call(this);
        }
      });
      dom.bind(_this2.__input, "blur", onBlur);
      dom.bind(_this2.__selector, "mousedown", function() {
        dom.addClass(this, "drag").bind(window, "mouseup", function() {
          dom.removeClass(_this.__selector, "drag");
        });
      });
      dom.bind(_this2.__selector, "touchstart", function() {
        dom.addClass(this, "drag").bind(window, "touchend", function() {
          dom.removeClass(_this.__selector, "drag");
        });
      });
      var valueField = document.createElement("div");
      Common.extend(_this2.__selector.style, {
        width: "122px",
        height: "102px",
        padding: "3px",
        backgroundColor: "#222",
        boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
      });
      Common.extend(_this2.__field_knob.style, {
        position: "absolute",
        width: "12px",
        height: "12px",
        border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? "#fff" : "#000"),
        boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
        borderRadius: "12px",
        zIndex: 1
      });
      Common.extend(_this2.__hue_knob.style, {
        position: "absolute",
        width: "15px",
        height: "2px",
        borderRight: "4px solid #fff",
        zIndex: 1
      });
      Common.extend(_this2.__saturation_field.style, {
        width: "100px",
        height: "100px",
        border: "1px solid #555",
        marginRight: "3px",
        display: "inline-block",
        cursor: "pointer"
      });
      Common.extend(valueField.style, {
        width: "100%",
        height: "100%",
        background: "none"
      });
      linearGradient(valueField, "top", "rgba(0,0,0,0)", "#000");
      Common.extend(_this2.__hue_field.style, {
        width: "15px",
        height: "100px",
        border: "1px solid #555",
        cursor: "ns-resize",
        position: "absolute",
        top: "3px",
        right: "3px"
      });
      hueGradient(_this2.__hue_field);
      Common.extend(_this2.__input.style, {
        outline: "none",
        textAlign: "center",
        color: "#fff",
        border: 0,
        fontWeight: "bold",
        textShadow: _this2.__input_textShadow + "rgba(0,0,0,0.7)"
      });
      dom.bind(_this2.__saturation_field, "mousedown", fieldDown);
      dom.bind(_this2.__saturation_field, "touchstart", fieldDown);
      dom.bind(_this2.__field_knob, "mousedown", fieldDown);
      dom.bind(_this2.__field_knob, "touchstart", fieldDown);
      dom.bind(_this2.__hue_field, "mousedown", fieldDownH);
      dom.bind(_this2.__hue_field, "touchstart", fieldDownH);
      function fieldDown(e) {
        setSV(e);
        dom.bind(window, "mousemove", setSV);
        dom.bind(window, "touchmove", setSV);
        dom.bind(window, "mouseup", fieldUpSV);
        dom.bind(window, "touchend", fieldUpSV);
      }
      function fieldDownH(e) {
        setH(e);
        dom.bind(window, "mousemove", setH);
        dom.bind(window, "touchmove", setH);
        dom.bind(window, "mouseup", fieldUpH);
        dom.bind(window, "touchend", fieldUpH);
      }
      function fieldUpSV() {
        dom.unbind(window, "mousemove", setSV);
        dom.unbind(window, "touchmove", setSV);
        dom.unbind(window, "mouseup", fieldUpSV);
        dom.unbind(window, "touchend", fieldUpSV);
        onFinish();
      }
      function fieldUpH() {
        dom.unbind(window, "mousemove", setH);
        dom.unbind(window, "touchmove", setH);
        dom.unbind(window, "mouseup", fieldUpH);
        dom.unbind(window, "touchend", fieldUpH);
        onFinish();
      }
      function onBlur() {
        var i = interpret(this.value);
        if (i !== false) {
          _this.__color.__state = i;
          _this.setValue(_this.__color.toOriginal());
        } else {
          this.value = _this.__color.toString();
        }
      }
      function onFinish() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.__color.toOriginal());
        }
      }
      _this2.__saturation_field.appendChild(valueField);
      _this2.__selector.appendChild(_this2.__field_knob);
      _this2.__selector.appendChild(_this2.__saturation_field);
      _this2.__selector.appendChild(_this2.__hue_field);
      _this2.__hue_field.appendChild(_this2.__hue_knob);
      _this2.domElement.appendChild(_this2.__input);
      _this2.domElement.appendChild(_this2.__selector);
      _this2.updateDisplay();
      function setSV(e) {
        if (e.type.indexOf("touch") === -1) {
          e.preventDefault();
        }
        var fieldRect = _this.__saturation_field.getBoundingClientRect();
        var _ref = e.touches && e.touches[0] || e, clientX = _ref.clientX, clientY = _ref.clientY;
        var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
        var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
        if (v > 1) {
          v = 1;
        } else if (v < 0) {
          v = 0;
        }
        if (s > 1) {
          s = 1;
        } else if (s < 0) {
          s = 0;
        }
        _this.__color.v = v;
        _this.__color.s = s;
        _this.setValue(_this.__color.toOriginal());
        return false;
      }
      function setH(e) {
        if (e.type.indexOf("touch") === -1) {
          e.preventDefault();
        }
        var fieldRect = _this.__hue_field.getBoundingClientRect();
        var _ref2 = e.touches && e.touches[0] || e, clientY = _ref2.clientY;
        var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
        if (h > 1) {
          h = 1;
        } else if (h < 0) {
          h = 0;
        }
        _this.__color.h = h * 360;
        _this.setValue(_this.__color.toOriginal());
        return false;
      }
      return _this2;
    }
    createClass(ColorController2, [{
      key: "updateDisplay",
      value: function updateDisplay2() {
        var i = interpret(this.getValue());
        if (i !== false) {
          var mismatch = false;
          Common.each(Color.COMPONENTS, function(component) {
            if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
              mismatch = true;
              return {};
            }
          }, this);
          if (mismatch) {
            Common.extend(this.__color.__state, i);
          }
        }
        Common.extend(this.__temp.__state, this.__color.__state);
        this.__temp.a = 1;
        var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
        var _flip = 255 - flip;
        Common.extend(this.__field_knob.style, {
          marginLeft: 100 * this.__color.s - 7 + "px",
          marginTop: 100 * (1 - this.__color.v) - 7 + "px",
          backgroundColor: this.__temp.toHexString(),
          border: this.__field_knob_border + "rgb(" + flip + "," + flip + "," + flip + ")"
        });
        this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + "px";
        this.__temp.s = 1;
        this.__temp.v = 1;
        linearGradient(this.__saturation_field, "left", "#fff", this.__temp.toHexString());
        this.__input.value = this.__color.toString();
        Common.extend(this.__input.style, {
          backgroundColor: this.__color.toHexString(),
          color: "rgb(" + flip + "," + flip + "," + flip + ")",
          textShadow: this.__input_textShadow + "rgba(" + _flip + "," + _flip + "," + _flip + ",.7)"
        });
      }
    }]);
    return ColorController2;
  }(Controller);
  var vendors = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
  function linearGradient(elem, x, a, b) {
    elem.style.background = "";
    Common.each(vendors, function(vendor) {
      elem.style.cssText += "background: " + vendor + "linear-gradient(" + x + ", " + a + " 0%, " + b + " 100%); ";
    });
  }
  function hueGradient(elem) {
    elem.style.background = "";
    elem.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);";
    elem.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
    elem.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
    elem.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
    elem.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
  }
  var css = {
    load: function load(url, indoc) {
      var doc = indoc || document;
      var link = doc.createElement("link");
      link.type = "text/css";
      link.rel = "stylesheet";
      link.href = url;
      doc.getElementsByTagName("head")[0].appendChild(link);
    },
    inject: function inject(cssContent, indoc) {
      var doc = indoc || document;
      var injected = document.createElement("style");
      injected.type = "text/css";
      injected.innerHTML = cssContent;
      var head = doc.getElementsByTagName("head")[0];
      try {
        head.appendChild(injected);
      } catch (e) {
      }
    }
  };
  var saveDialogContents = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`;
  var ControllerFactory = function ControllerFactory2(object, property) {
    var initialValue = object[property];
    if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
      return new OptionController(object, property, arguments[2]);
    }
    if (Common.isNumber(initialValue)) {
      if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
        if (Common.isNumber(arguments[4])) {
          return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
        }
        return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
      }
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
      }
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
    }
    if (Common.isString(initialValue)) {
      return new StringController(object, property);
    }
    if (Common.isFunction(initialValue)) {
      return new FunctionController(object, property, "");
    }
    if (Common.isBoolean(initialValue)) {
      return new BooleanController(object, property);
    }
    return null;
  };
  function requestAnimationFrame2(callback) {
    setTimeout(callback, 1e3 / 60);
  }
  var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame2;
  var CenteredDiv = function() {
    function CenteredDiv2() {
      classCallCheck(this, CenteredDiv2);
      this.backgroundElement = document.createElement("div");
      Common.extend(this.backgroundElement.style, {
        backgroundColor: "rgba(0,0,0,0.8)",
        top: 0,
        left: 0,
        display: "none",
        zIndex: "1000",
        opacity: 0,
        WebkitTransition: "opacity 0.2s linear",
        transition: "opacity 0.2s linear"
      });
      dom.makeFullscreen(this.backgroundElement);
      this.backgroundElement.style.position = "fixed";
      this.domElement = document.createElement("div");
      Common.extend(this.domElement.style, {
        position: "fixed",
        display: "none",
        zIndex: "1001",
        opacity: 0,
        WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
        transition: "transform 0.2s ease-out, opacity 0.2s linear"
      });
      document.body.appendChild(this.backgroundElement);
      document.body.appendChild(this.domElement);
      var _this = this;
      dom.bind(this.backgroundElement, "click", function() {
        _this.hide();
      });
    }
    createClass(CenteredDiv2, [{
      key: "show",
      value: function show2() {
        var _this = this;
        this.backgroundElement.style.display = "block";
        this.domElement.style.display = "block";
        this.domElement.style.opacity = 0;
        this.domElement.style.webkitTransform = "scale(1.1)";
        this.layout();
        Common.defer(function() {
          _this.backgroundElement.style.opacity = 1;
          _this.domElement.style.opacity = 1;
          _this.domElement.style.webkitTransform = "scale(1)";
        });
      }
    }, {
      key: "hide",
      value: function hide3() {
        var _this = this;
        var hide4 = function hide5() {
          _this.domElement.style.display = "none";
          _this.backgroundElement.style.display = "none";
          dom.unbind(_this.domElement, "webkitTransitionEnd", hide5);
          dom.unbind(_this.domElement, "transitionend", hide5);
          dom.unbind(_this.domElement, "oTransitionEnd", hide5);
        };
        dom.bind(this.domElement, "webkitTransitionEnd", hide4);
        dom.bind(this.domElement, "transitionend", hide4);
        dom.bind(this.domElement, "oTransitionEnd", hide4);
        this.backgroundElement.style.opacity = 0;
        this.domElement.style.opacity = 0;
        this.domElement.style.webkitTransform = "scale(1.1)";
      }
    }, {
      key: "layout",
      value: function layout() {
        this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + "px";
        this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + "px";
      }
    }]);
    return CenteredDiv2;
  }();
  var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");
  css.inject(styleSheet);
  var CSS_NAMESPACE = "dg";
  var HIDE_KEY_CODE = 72;
  var CLOSE_BUTTON_HEIGHT = 20;
  var DEFAULT_DEFAULT_PRESET_NAME = "Default";
  var SUPPORTS_LOCAL_STORAGE = function() {
    try {
      return !!window.localStorage;
    } catch (e) {
      return false;
    }
  }();
  var SAVE_DIALOGUE = void 0;
  var autoPlaceVirgin = true;
  var autoPlaceContainer = void 0;
  var hide = false;
  var hideableGuis = [];
  var GUI = function GUI2(pars) {
    var _this = this;
    var params = pars || {};
    this.domElement = document.createElement("div");
    this.__ul = document.createElement("ul");
    this.domElement.appendChild(this.__ul);
    dom.addClass(this.domElement, CSS_NAMESPACE);
    this.__folders = {};
    this.__controllers = [];
    this.__rememberedObjects = [];
    this.__rememberedObjectIndecesToControllers = [];
    this.__listening = [];
    params = Common.defaults(params, {
      closeOnTop: false,
      autoPlace: true,
      width: GUI2.DEFAULT_WIDTH
    });
    params = Common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });
    if (!Common.isUndefined(params.load)) {
      if (params.preset) {
        params.load.preset = params.preset;
      }
    } else {
      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
    }
    if (Common.isUndefined(params.parent) && params.hideable) {
      hideableGuis.push(this);
    }
    params.resizable = Common.isUndefined(params.parent) && params.resizable;
    if (params.autoPlace && Common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
    var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, "isLocal")) === "true";
    var saveToLocalStorage = void 0;
    var titleRow = void 0;
    Object.defineProperties(
      this,
      {
        parent: {
          get: function get$$13() {
            return params.parent;
          }
        },
        scrollable: {
          get: function get$$13() {
            return params.scrollable;
          }
        },
        autoPlace: {
          get: function get$$13() {
            return params.autoPlace;
          }
        },
        closeOnTop: {
          get: function get$$13() {
            return params.closeOnTop;
          }
        },
        preset: {
          get: function get$$13() {
            if (_this.parent) {
              return _this.getRoot().preset;
            }
            return params.load.preset;
          },
          set: function set$$13(v) {
            if (_this.parent) {
              _this.getRoot().preset = v;
            } else {
              params.load.preset = v;
            }
            setPresetSelectIndex(this);
            _this.revert();
          }
        },
        width: {
          get: function get$$13() {
            return params.width;
          },
          set: function set$$13(v) {
            params.width = v;
            setWidth(_this, v);
          }
        },
        name: {
          get: function get$$13() {
            return params.name;
          },
          set: function set$$13(v) {
            params.name = v;
            if (titleRow) {
              titleRow.innerHTML = params.name;
            }
          }
        },
        closed: {
          get: function get$$13() {
            return params.closed;
          },
          set: function set$$13(v) {
            params.closed = v;
            if (params.closed) {
              dom.addClass(_this.__ul, GUI2.CLASS_CLOSED);
            } else {
              dom.removeClass(_this.__ul, GUI2.CLASS_CLOSED);
            }
            this.onResize();
            if (_this.__closeButton) {
              _this.__closeButton.innerHTML = v ? GUI2.TEXT_OPEN : GUI2.TEXT_CLOSED;
            }
          }
        },
        load: {
          get: function get$$13() {
            return params.load;
          }
        },
        useLocalStorage: {
          get: function get$$13() {
            return useLocalStorage;
          },
          set: function set$$13(bool) {
            if (SUPPORTS_LOCAL_STORAGE) {
              useLocalStorage = bool;
              if (bool) {
                dom.bind(window, "unload", saveToLocalStorage);
              } else {
                dom.unbind(window, "unload", saveToLocalStorage);
              }
              localStorage.setItem(getLocalStorageHash(_this, "isLocal"), bool);
            }
          }
        }
      }
    );
    if (Common.isUndefined(params.parent)) {
      this.closed = params.closed || false;
      dom.addClass(this.domElement, GUI2.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);
      if (SUPPORTS_LOCAL_STORAGE) {
        if (useLocalStorage) {
          _this.useLocalStorage = true;
          var savedGui = localStorage.getItem(getLocalStorageHash(this, "gui"));
          if (savedGui) {
            params.load = JSON.parse(savedGui);
          }
        }
      }
      this.__closeButton = document.createElement("div");
      this.__closeButton.innerHTML = GUI2.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_BUTTON);
      if (params.closeOnTop) {
        dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_TOP);
        this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
      } else {
        dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_BOTTOM);
        this.domElement.appendChild(this.__closeButton);
      }
      dom.bind(this.__closeButton, "click", function() {
        _this.closed = !_this.closed;
      });
    } else {
      if (params.closed === void 0) {
        params.closed = true;
      }
      var titleRowName = document.createTextNode(params.name);
      dom.addClass(titleRowName, "controller-name");
      titleRow = addRow(_this, titleRowName);
      var onClickTitle = function onClickTitle2(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };
      dom.addClass(this.__ul, GUI2.CLASS_CLOSED);
      dom.addClass(titleRow, "title");
      dom.bind(titleRow, "click", onClickTitle);
      if (!params.closed) {
        this.closed = false;
      }
    }
    if (params.autoPlace) {
      if (Common.isUndefined(params.parent)) {
        if (autoPlaceVirgin) {
          autoPlaceContainer = document.createElement("div");
          dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
          dom.addClass(autoPlaceContainer, GUI2.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(autoPlaceContainer);
          autoPlaceVirgin = false;
        }
        autoPlaceContainer.appendChild(this.domElement);
        dom.addClass(this.domElement, GUI2.CLASS_AUTO_PLACE);
      }
      if (!this.parent) {
        setWidth(_this, params.width);
      }
    }
    this.__resizeHandler = function() {
      _this.onResizeDebounced();
    };
    dom.bind(window, "resize", this.__resizeHandler);
    dom.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler);
    dom.bind(this.__ul, "transitionend", this.__resizeHandler);
    dom.bind(this.__ul, "oTransitionEnd", this.__resizeHandler);
    this.onResize();
    if (params.resizable) {
      addResizeHandle(this);
    }
    saveToLocalStorage = function saveToLocalStorage2() {
      if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, "isLocal")) === "true") {
        localStorage.setItem(getLocalStorageHash(_this, "gui"), JSON.stringify(_this.getSaveObject()));
      }
    };
    this.saveToLocalStorageIfPossible = saveToLocalStorage;
    function resetWidth() {
      var root = _this.getRoot();
      root.width += 1;
      Common.defer(function() {
        root.width -= 1;
      });
    }
    if (!params.parent) {
      resetWidth();
    }
  };
  GUI.toggleHide = function() {
    hide = !hide;
    Common.each(hideableGuis, function(gui2) {
      gui2.domElement.style.display = hide ? "none" : "";
    });
  };
  GUI.CLASS_AUTO_PLACE = "a";
  GUI.CLASS_AUTO_PLACE_CONTAINER = "ac";
  GUI.CLASS_MAIN = "main";
  GUI.CLASS_CONTROLLER_ROW = "cr";
  GUI.CLASS_TOO_TALL = "taller-than-window";
  GUI.CLASS_CLOSED = "closed";
  GUI.CLASS_CLOSE_BUTTON = "close-button";
  GUI.CLASS_CLOSE_TOP = "close-top";
  GUI.CLASS_CLOSE_BOTTOM = "close-bottom";
  GUI.CLASS_DRAG = "drag";
  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = "Close Controls";
  GUI.TEXT_OPEN = "Open Controls";
  GUI._keydownHandler = function(e) {
    if (document.activeElement.type !== "text" && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }
  };
  dom.bind(window, "keydown", GUI._keydownHandler, false);
  Common.extend(
    GUI.prototype,
    {
      add: function add(object, property) {
        return _add(this, object, property, {
          factoryArgs: Array.prototype.slice.call(arguments, 2)
        });
      },
      addColor: function addColor(object, property) {
        return _add(this, object, property, {
          color: true
        });
      },
      remove: function remove(controller) {
        this.__ul.removeChild(controller.__li);
        this.__controllers.splice(this.__controllers.indexOf(controller), 1);
        var _this = this;
        Common.defer(function() {
          _this.onResize();
        });
      },
      destroy: function destroy() {
        if (this.parent) {
          throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
        }
        if (this.autoPlace) {
          autoPlaceContainer.removeChild(this.domElement);
        }
        var _this = this;
        Common.each(this.__folders, function(subfolder) {
          _this.removeFolder(subfolder);
        });
        dom.unbind(window, "keydown", GUI._keydownHandler, false);
        removeListeners(this);
      },
      addFolder: function addFolder(name) {
        if (this.__folders[name] !== void 0) {
          throw new Error('You already have a folder in this GUI by the name "' + name + '"');
        }
        var newGuiParams = { name, parent: this };
        newGuiParams.autoPlace = this.autoPlace;
        if (this.load && this.load.folders && this.load.folders[name]) {
          newGuiParams.closed = this.load.folders[name].closed;
          newGuiParams.load = this.load.folders[name];
        }
        var gui2 = new GUI(newGuiParams);
        this.__folders[name] = gui2;
        var li = addRow(this, gui2.domElement);
        dom.addClass(li, "folder");
        return gui2;
      },
      removeFolder: function removeFolder(folder) {
        this.__ul.removeChild(folder.domElement.parentElement);
        delete this.__folders[folder.name];
        if (this.load && this.load.folders && this.load.folders[folder.name]) {
          delete this.load.folders[folder.name];
        }
        removeListeners(folder);
        var _this = this;
        Common.each(folder.__folders, function(subfolder) {
          folder.removeFolder(subfolder);
        });
        Common.defer(function() {
          _this.onResize();
        });
      },
      open: function open() {
        this.closed = false;
      },
      close: function close() {
        this.closed = true;
      },
      hide: function hide2() {
        this.domElement.style.display = "none";
      },
      show: function show() {
        this.domElement.style.display = "";
      },
      onResize: function onResize() {
        var root = this.getRoot();
        if (root.scrollable) {
          var top = dom.getOffset(root.__ul).top;
          var h = 0;
          Common.each(root.__ul.childNodes, function(node) {
            if (!(root.autoPlace && node === root.__save_row)) {
              h += dom.getHeight(node);
            }
          });
          if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
            dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
            root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + "px";
          } else {
            dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
            root.__ul.style.height = "auto";
          }
        }
        if (root.__resize_handle) {
          Common.defer(function() {
            root.__resize_handle.style.height = root.__ul.offsetHeight + "px";
          });
        }
        if (root.__closeButton) {
          root.__closeButton.style.width = root.width + "px";
        }
      },
      onResizeDebounced: Common.debounce(function() {
        this.onResize();
      }, 50),
      remember: function remember() {
        if (Common.isUndefined(SAVE_DIALOGUE)) {
          SAVE_DIALOGUE = new CenteredDiv();
          SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
        }
        if (this.parent) {
          throw new Error("You can only call remember on a top level GUI.");
        }
        var _this = this;
        Common.each(Array.prototype.slice.call(arguments), function(object) {
          if (_this.__rememberedObjects.length === 0) {
            addSaveMenu(_this);
          }
          if (_this.__rememberedObjects.indexOf(object) === -1) {
            _this.__rememberedObjects.push(object);
          }
        });
        if (this.autoPlace) {
          setWidth(this, this.width);
        }
      },
      getRoot: function getRoot() {
        var gui2 = this;
        while (gui2.parent) {
          gui2 = gui2.parent;
        }
        return gui2;
      },
      getSaveObject: function getSaveObject() {
        var toReturn2 = this.load;
        toReturn2.closed = this.closed;
        if (this.__rememberedObjects.length > 0) {
          toReturn2.preset = this.preset;
          if (!toReturn2.remembered) {
            toReturn2.remembered = {};
          }
          toReturn2.remembered[this.preset] = getCurrentPreset(this);
        }
        toReturn2.folders = {};
        Common.each(this.__folders, function(element, key) {
          toReturn2.folders[key] = element.getSaveObject();
        });
        return toReturn2;
      },
      save: function save() {
        if (!this.load.remembered) {
          this.load.remembered = {};
        }
        this.load.remembered[this.preset] = getCurrentPreset(this);
        markPresetModified(this, false);
        this.saveToLocalStorageIfPossible();
      },
      saveAs: function saveAs(presetName) {
        if (!this.load.remembered) {
          this.load.remembered = {};
          this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
        }
        this.load.remembered[presetName] = getCurrentPreset(this);
        this.preset = presetName;
        addPresetOption(this, presetName, true);
        this.saveToLocalStorageIfPossible();
      },
      revert: function revert(gui2) {
        Common.each(this.__controllers, function(controller) {
          if (!this.getRoot().load.remembered) {
            controller.setValue(controller.initialValue);
          } else {
            recallSavedValue(gui2 || this.getRoot(), controller);
          }
          if (controller.__onFinishChange) {
            controller.__onFinishChange.call(controller, controller.getValue());
          }
        }, this);
        Common.each(this.__folders, function(folder) {
          folder.revert(folder);
        });
        if (!gui2) {
          markPresetModified(this.getRoot(), false);
        }
      },
      listen: function listen(controller) {
        var init = this.__listening.length === 0;
        this.__listening.push(controller);
        if (init) {
          updateDisplays(this.__listening);
        }
      },
      updateDisplay: function updateDisplay() {
        Common.each(this.__controllers, function(controller) {
          controller.updateDisplay();
        });
        Common.each(this.__folders, function(folder) {
          folder.updateDisplay();
        });
      }
    }
  );
  function addRow(gui2, newDom, liBefore) {
    var li = document.createElement("li");
    if (newDom) {
      li.appendChild(newDom);
    }
    if (liBefore) {
      gui2.__ul.insertBefore(li, liBefore);
    } else {
      gui2.__ul.appendChild(li);
    }
    gui2.onResize();
    return li;
  }
  function removeListeners(gui2) {
    dom.unbind(window, "resize", gui2.__resizeHandler);
    if (gui2.saveToLocalStorageIfPossible) {
      dom.unbind(window, "unload", gui2.saveToLocalStorageIfPossible);
    }
  }
  function markPresetModified(gui2, modified) {
    var opt = gui2.__preset_select[gui2.__preset_select.selectedIndex];
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }
  function augmentController(gui2, li, controller) {
    controller.__li = li;
    controller.__gui = gui2;
    Common.extend(controller, {
      options: function options(_options) {
        if (arguments.length > 1) {
          var nextSibling = controller.__li.nextElementSibling;
          controller.remove();
          return _add(gui2, controller.object, controller.property, {
            before: nextSibling,
            factoryArgs: [Common.toArray(arguments)]
          });
        }
        if (Common.isArray(_options) || Common.isObject(_options)) {
          var _nextSibling = controller.__li.nextElementSibling;
          controller.remove();
          return _add(gui2, controller.object, controller.property, {
            before: _nextSibling,
            factoryArgs: [_options]
          });
        }
      },
      name: function name(_name) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
        return controller;
      },
      listen: function listen2() {
        controller.__gui.listen(controller);
        return controller;
      },
      remove: function remove2() {
        controller.__gui.remove(controller);
        return controller;
      }
    });
    if (controller instanceof NumberControllerSlider) {
      var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
      Common.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pb.apply(box, args);
          return pc.apply(controller, args);
        };
      });
      dom.addClass(li, "has-slider");
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
    } else if (controller instanceof NumberControllerBox) {
      var r = function r2(returned) {
        if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
          var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
          var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
          controller.remove();
          var newController = _add(gui2, controller.object, controller.property, {
            before: controller.__li.nextElementSibling,
            factoryArgs: [controller.__min, controller.__max, controller.__step]
          });
          newController.name(oldName);
          if (wasListening)
            newController.listen();
          return newController;
        }
        return returned;
      };
      controller.min = Common.compose(r, controller.min);
      controller.max = Common.compose(r, controller.max);
    } else if (controller instanceof BooleanController) {
      dom.bind(li, "click", function() {
        dom.fakeEvent(controller.__checkbox, "click");
      });
      dom.bind(controller.__checkbox, "click", function(e) {
        e.stopPropagation();
      });
    } else if (controller instanceof FunctionController) {
      dom.bind(li, "click", function() {
        dom.fakeEvent(controller.__button, "click");
      });
      dom.bind(li, "mouseover", function() {
        dom.addClass(controller.__button, "hover");
      });
      dom.bind(li, "mouseout", function() {
        dom.removeClass(controller.__button, "hover");
      });
    } else if (controller instanceof ColorController) {
      dom.addClass(li, "color");
      controller.updateDisplay = Common.compose(function(val) {
        li.style.borderLeftColor = controller.__color.toString();
        return val;
      }, controller.updateDisplay);
      controller.updateDisplay();
    }
    controller.setValue = Common.compose(function(val) {
      if (gui2.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui2.getRoot(), true);
      }
      return val;
    }, controller.setValue);
  }
  function recallSavedValue(gui2, controller) {
    var root = gui2.getRoot();
    var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
    if (matchedIndex !== -1) {
      var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
      if (controllerMap === void 0) {
        controllerMap = {};
        root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
      }
      controllerMap[controller.property] = controller;
      if (root.load && root.load.remembered) {
        var presetMap = root.load.remembered;
        var preset = void 0;
        if (presetMap[gui2.preset]) {
          preset = presetMap[gui2.preset];
        } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
          preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
        } else {
          return;
        }
        if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== void 0) {
          var value = preset[matchedIndex][controller.property];
          controller.initialValue = value;
          controller.setValue(value);
        }
      }
    }
  }
  function _add(gui2, object, property, params) {
    if (object[property] === void 0) {
      throw new Error('Object "' + object + '" has no property "' + property + '"');
    }
    var controller = void 0;
    if (params.color) {
      controller = new ColorController(object, property);
    } else {
      var factoryArgs = [object, property].concat(params.factoryArgs);
      controller = ControllerFactory.apply(gui2, factoryArgs);
    }
    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }
    recallSavedValue(gui2, controller);
    dom.addClass(controller.domElement, "c");
    var name = document.createElement("span");
    dom.addClass(name, "property-name");
    name.innerHTML = controller.property;
    var container = document.createElement("div");
    container.appendChild(name);
    container.appendChild(controller.domElement);
    var li = addRow(gui2, container, params.before);
    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    if (controller instanceof ColorController) {
      dom.addClass(li, "color");
    } else {
      dom.addClass(li, _typeof(controller.getValue()));
    }
    augmentController(gui2, li, controller);
    gui2.__controllers.push(controller);
    return controller;
  }
  function getLocalStorageHash(gui2, key) {
    return document.location.href + "." + key;
  }
  function addPresetOption(gui2, name, setSelected) {
    var opt = document.createElement("option");
    opt.innerHTML = name;
    opt.value = name;
    gui2.__preset_select.appendChild(opt);
    if (setSelected) {
      gui2.__preset_select.selectedIndex = gui2.__preset_select.length - 1;
    }
  }
  function showHideExplain(gui2, explain) {
    explain.style.display = gui2.useLocalStorage ? "block" : "none";
  }
  function addSaveMenu(gui2) {
    var div = gui2.__save_row = document.createElement("li");
    dom.addClass(gui2.domElement, "has-save");
    gui2.__ul.insertBefore(div, gui2.__ul.firstChild);
    dom.addClass(div, "save-row");
    var gears = document.createElement("span");
    gears.innerHTML = "&nbsp;";
    dom.addClass(gears, "button gears");
    var button = document.createElement("span");
    button.innerHTML = "Save";
    dom.addClass(button, "button");
    dom.addClass(button, "save");
    var button2 = document.createElement("span");
    button2.innerHTML = "New";
    dom.addClass(button2, "button");
    dom.addClass(button2, "save-as");
    var button3 = document.createElement("span");
    button3.innerHTML = "Revert";
    dom.addClass(button3, "button");
    dom.addClass(button3, "revert");
    var select = gui2.__preset_select = document.createElement("select");
    if (gui2.load && gui2.load.remembered) {
      Common.each(gui2.load.remembered, function(value, key) {
        addPresetOption(gui2, key, key === gui2.preset);
      });
    } else {
      addPresetOption(gui2, DEFAULT_DEFAULT_PRESET_NAME, false);
    }
    dom.bind(select, "change", function() {
      for (var index = 0; index < gui2.__preset_select.length; index++) {
        gui2.__preset_select[index].innerHTML = gui2.__preset_select[index].value;
      }
      gui2.preset = this.value;
    });
    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);
    if (SUPPORTS_LOCAL_STORAGE) {
      var explain = document.getElementById("dg-local-explain");
      var localStorageCheckBox = document.getElementById("dg-local-storage");
      var saveLocally = document.getElementById("dg-save-locally");
      saveLocally.style.display = "block";
      if (localStorage.getItem(getLocalStorageHash(gui2, "isLocal")) === "true") {
        localStorageCheckBox.setAttribute("checked", "checked");
      }
      showHideExplain(gui2, explain);
      dom.bind(localStorageCheckBox, "change", function() {
        gui2.useLocalStorage = !gui2.useLocalStorage;
        showHideExplain(gui2, explain);
      });
    }
    var newConstructorTextArea = document.getElementById("dg-new-constructor");
    dom.bind(newConstructorTextArea, "keydown", function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
        SAVE_DIALOGUE.hide();
      }
    });
    dom.bind(gears, "click", function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui2.getSaveObject(), void 0, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });
    dom.bind(button, "click", function() {
      gui2.save();
    });
    dom.bind(button2, "click", function() {
      var presetName = prompt("Enter a new preset name.");
      if (presetName) {
        gui2.saveAs(presetName);
      }
    });
    dom.bind(button3, "click", function() {
      gui2.revert();
    });
  }
  function addResizeHandle(gui2) {
    var pmouseX = void 0;
    gui2.__resize_handle = document.createElement("div");
    Common.extend(gui2.__resize_handle.style, {
      width: "6px",
      marginLeft: "-3px",
      height: "200px",
      cursor: "ew-resize",
      position: "absolute"
    });
    function drag(e) {
      e.preventDefault();
      gui2.width += pmouseX - e.clientX;
      gui2.onResize();
      pmouseX = e.clientX;
      return false;
    }
    function dragStop() {
      dom.removeClass(gui2.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, "mousemove", drag);
      dom.unbind(window, "mouseup", dragStop);
    }
    function dragStart(e) {
      e.preventDefault();
      pmouseX = e.clientX;
      dom.addClass(gui2.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, "mousemove", drag);
      dom.bind(window, "mouseup", dragStop);
      return false;
    }
    dom.bind(gui2.__resize_handle, "mousedown", dragStart);
    dom.bind(gui2.__closeButton, "mousedown", dragStart);
    gui2.domElement.insertBefore(gui2.__resize_handle, gui2.domElement.firstElementChild);
  }
  function setWidth(gui2, w) {
    gui2.domElement.style.width = w + "px";
    if (gui2.__save_row && gui2.autoPlace) {
      gui2.__save_row.style.width = w + "px";
    }
    if (gui2.__closeButton) {
      gui2.__closeButton.style.width = w + "px";
    }
  }
  function getCurrentPreset(gui2, useInitialValues) {
    var toReturn2 = {};
    Common.each(gui2.__rememberedObjects, function(val, index) {
      var savedValues = {};
      var controllerMap = gui2.__rememberedObjectIndecesToControllers[index];
      Common.each(controllerMap, function(controller, property) {
        savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });
      toReturn2[index] = savedValues;
    });
    return toReturn2;
  }
  function setPresetSelectIndex(gui2) {
    for (var index = 0; index < gui2.__preset_select.length; index++) {
      if (gui2.__preset_select[index].value === gui2.preset) {
        gui2.__preset_select.selectedIndex = index;
      }
    }
  }
  function updateDisplays(controllerArray) {
    if (controllerArray.length !== 0) {
      requestAnimationFrame$1.call(window, function() {
        updateDisplays(controllerArray);
      });
    }
    Common.each(controllerArray, function(c) {
      c.updateDisplay();
    });
  }
  var GUI$1 = GUI;

  // thue.ts
  var vis = __toESM(require_vis());

  // thueState.ts
  var initialState = "#AAA#";
  function parseRules(ascii) {
    return ascii.trim().split("\n").map((x) => {
      return x.split("\u21D2").map((r) => r.trim());
    });
  }
  var RULES = parseRules(`
#AAA#\u21D2Win!
AC\u21D2CA
CA\u21D2AC
AD\u21D2DA
DA\u21D2AD
BC\u21D2CB
CB\u21D2BC
BD\u21D2DB
DB\u21D2BD
ECA\u21D2CE
CE\u21D2ECA
EDB\u21D2DE
DE\u21D2EDB
CDCA\u21D2CDCAE
CDCAE\u21D2CDCA
CAAA\u21D2AAA
AAA\u21D2CAAA
DAAA\u21D2AAA
AAA\u21D2DAAA
`);
  function isWon(state) {
    return state === "Win!";
  }
  function nextStates(state) {
    let result2 = {};
    RULES.forEach(([leftRule, rightRule], ruleIndex) => {
      let cur_pos = 0;
      while (cur_pos <= state.length - leftRule.length) {
        cur_pos = state.indexOf(leftRule, cur_pos);
        if (cur_pos === -1)
          break;
        let new_state = state.slice(0, cur_pos) + rightRule + state.slice(cur_pos + leftRule.length);
        result2[`${ruleIndex}.${cur_pos}`] = new_state;
        cur_pos += 1;
      }
    });
    return result2;
  }
  function id(state) {
    return state;
  }
  function isClearlyLost(state) {
    return false;
  }
  var State = { initialState, nextStates, isWon, id, isClearlyLost };

  // thue.ts
  var CONFIG = {
    showIDs: true
  };
  var gui = new GUI$1();
  var BUTTONS = {
    expandLevel,
    expandAll,
    hideLostCrates: () => {
      for (let node_id of Object.keys(network.body.nodes)) {
        if (network.isCluster(node_id)) {
          let representative_id = network.getNodesInCluster(node_id)[0];
          if (State.isClearlyLost(nodes.get(representative_id).state)) {
            network.clustering.updateClusteredNode(node_id, { hidden: true });
          }
        } else {
          if (State.isClearlyLost(nodes.get(node_id).state)) {
            nodes.update({ id: node_id, hidden: true });
          }
        }
      }
    }
  };
  gui.add(BUTTONS, "expandLevel");
  gui.add(BUTTONS, "expandAll");
  gui.add(BUTTONS, "hideLostCrates");
  var nodes = new vis.DataSet();
  var edges = new vis.DataSet();
  var network = new vis.Network(
    document.getElementById("mynetwork"),
    {
      nodes,
      edges
    },
    {
      edges: {
        arrows: "to",
        smooth: false
      },
      physics: {
        barnesHut: {
          gravitationalConstant: -2e4,
          damping: 0.25
        },
        minVelocity: 0
      }
    }
  );
  addNode(State.initialState);
  expandNode(nodes.get()[0]);
  network.on("click", function(params) {
    let clicked_node_id = params.nodes[0];
    if (clicked_node_id !== void 0) {
      let clicked_node = nodes.get(clicked_node_id);
      if (!clicked_node.expanded) {
        expandNode(clicked_node);
      }
    }
  });
  function expandNode(cur_node) {
    if (cur_node.expanded)
      return;
    let next_states = State.nextStates(cur_node.state);
    for (const [input, new_state] of Object.entries(next_states)) {
      let new_id = State.id(new_state);
      if (nodes.get(new_id) === null) {
        addNode(new_state, new_id, cur_node);
      }
      edges.add({
        id: `${cur_node.id}_${input}`,
        from: cur_node.id,
        to: new_id,
        input,
        label: input
      });
    }
    nodes.update({ id: cur_node.id, expanded: true, color: "#fcba03" });
  }
  function expandLevel() {
    nodes.forEach(expandNode);
  }
  function expandAll() {
    while (true) {
      if (nodes.get({ filter: (x) => !x.expanded }).length === 0)
        break;
      expandLevel();
    }
  }
  function addNode(state, id2 = void 0, parent_node = void 0) {
    if (id2 === void 0)
      id2 = State.id(state);
    let x = 0;
    let y = 0;
    if (parent_node !== void 0) {
      x = network.body.nodes[parent_node.id].x;
      y = network.body.nodes[parent_node.id].y;
    }
    let won = State.isWon(state);
    nodes.add({
      id: id2,
      state,
      won,
      expanded: false,
      label: CONFIG.showIDs ? id2 : "",
      color: "#9803fc",
      shape: state === State.initialState ? "diamond" : won ? "star" : "dot",
      x,
      y
    });
  }
})();
/*! Hammer.JS - v2.0.7 - 2016-04-22
* http://hammerjs.github.io/
*
* Copyright (c) 2016 Jorik Tangelder;
* Licensed under the MIT license */
/**
 * vis.js
 * https://github.com/almende/vis
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 4.24.11
 * @date    2019-10-24
 *
 * @license
 * Copyright (C) 2011-2017 Almende B.V, http://almende.com
 *
 * Vis.js is dual licensed under both
 *
 * * The Apache 2.0 License
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * and
 *
 * * The MIT License
 *   http://opensource.org/licenses/MIT
 *
 * Vis.js may be distributed under either license.
 */
//! moment.js

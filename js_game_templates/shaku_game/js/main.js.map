{
  "version": 3,
  "sources": ["../node_modules/shaku/lib/manager.js", "../node_modules/shaku/lib/utils/math_helper.js", "../node_modules/shaku/lib/utils/color.js", "../node_modules/shaku/lib/gfx/blend_modes.js", "../node_modules/shaku/lib/utils/vector2.js", "../node_modules/shaku/lib/utils/circle.js", "../node_modules/shaku/lib/utils/line.js", "../node_modules/shaku/lib/utils/rectangle.js", "../node_modules/shaku/lib/assets/asset.js", "../node_modules/shaku/lib/gfx/texture_filter_modes.js", "../node_modules/shaku/lib/gfx/texture_wrap_modes.js", "../node_modules/shaku/lib/logger.js", "../node_modules/shaku/lib/assets/texture_asset.js", "../node_modules/shaku/lib/gfx/matrix.js", "../node_modules/shaku/lib/gfx/effects/effect.js", "../node_modules/shaku/lib/gfx/effects/basic.js", "../node_modules/shaku/lib/gfx/effects/index.js", "../node_modules/shaku/lib/utils/vector3.js", "../node_modules/shaku/lib/utils/animator.js", "../node_modules/shaku/lib/utils/game_time.js", "../node_modules/shaku/lib/utils/seeded_random.js", "../node_modules/shaku/lib/utils/perlin.js", "../node_modules/shaku/lib/utils/storage_adapter.js", "../node_modules/shaku/lib/utils/storage.js", "../node_modules/shaku/lib/utils/path_finder.js", "../node_modules/shaku/lib/utils/index.js", "../node_modules/shaku/lib/gfx/mesh.js", "../node_modules/shaku/lib/gfx/mesh_generator.js", "../node_modules/shaku/lib/gfx/camera.js", "../node_modules/shaku/lib/gfx/sprite.js", "../node_modules/shaku/lib/gfx/sprites_group.js", "../node_modules/shaku/lib/assets/font_texture_asset.js", "../node_modules/shaku/lib/gfx/text_alignment.js", "../node_modules/shaku/lib/gfx/sprite_batch.js", "../node_modules/shaku/lib/gfx/gfx.js", "../node_modules/shaku/lib/gfx/index.js", "../node_modules/shaku/lib/assets/sound_asset.js", "../node_modules/shaku/lib/sfx/sound_instance.js", "../node_modules/shaku/lib/sfx/sound_mixer.js", "../node_modules/shaku/lib/sfx/sfx.js", "../node_modules/shaku/lib/sfx/index.js", "../node_modules/shaku/lib/input/key_codes.js", "../node_modules/shaku/lib/input/input.js", "../node_modules/shaku/lib/input/index.js", "../node_modules/shaku/lib/assets/binary_asset.js", "../node_modules/shaku/lib/assets/json_asset.js", "../node_modules/shaku/lib/assets/assets.js", "../node_modules/shaku/lib/assets/index.js", "../node_modules/shaku/lib/collision/shapes/shape.js", "../node_modules/shaku/lib/collision/result.js", "../node_modules/shaku/lib/collision/resolver.js", "../node_modules/shaku/lib/collision/shapes/point.js", "../node_modules/shaku/lib/collision/shapes/circle.js", "../node_modules/shaku/lib/collision/collision_world.js", "../node_modules/shaku/lib/collision/shapes/rectangle.js", "../node_modules/shaku/lib/collision/resolvers_imp.js", "../node_modules/shaku/lib/collision/shapes/lines.js", "../node_modules/shaku/lib/collision/shapes/tilemap.js", "../node_modules/shaku/lib/collision/collision.js", "../node_modules/shaku/lib/collision/index.js", "../node_modules/shaku/lib/shaku.js", "../src/main.ts"],
  "sourcesContent": ["/**\r\n * Define the managers interface.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\manager.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n\r\n/**\r\n * Interface for any manager.\r\n * Manager = manages a domain in Shaku, such as gfx (graphics), sfx (sounds), input, etc.\r\n */\r\nclass IManager\r\n{\r\n    /**\r\n     * Initialize the manager.\r\n     * @returns {Promise} Promise to resolve when initialization is done.\r\n     */\r\n    setup()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Called every update at the begining of the frame.\r\n     */\r\n    startFrame()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Called every update at the end of the frame.\r\n     */\r\n    endFrame()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Destroy the manager.\r\n     */\r\n    destroy()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n}\r\n\r\n// export the manager interface.\r\nmodule.exports = IManager", "/**\r\n * Implement a math utilities class.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\math_helper.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n// for radians / degrees conversion\r\nconst _toRadsFactor = (Math.PI / 180);\r\nconst _toDegreesFactor = (180 / Math.PI);\r\n\r\n\r\n/**\r\n * Implement some math utilities functions.\r\n */\r\nclass MathHelper\r\n{\r\n    /**\r\n     * Perform linear interpolation between start and end values.\r\n     * @param {Number} start Starting value.\r\n     * @param {Number} end Ending value.\r\n     * @param {Number} amount How much to interpolate from start to end.\r\n     * @returns {Number} interpolated value between start and end.\r\n     */\r\n    static lerp(start, end, amount)\r\n    {\r\n        // to prevent shaking on same values\r\n        if (start === end) { return end; }\r\n\r\n        // do lerping\r\n        return ((1-amount) * start) + (amount * end);\r\n    }\r\n\r\n    /**\r\n     * Calculate 2d dot product.\r\n     * @param {Number} x1 First vector x.\r\n     * @param {Number} y1 First vector y.\r\n     * @param {Number} x2 Second vector x.\r\n     * @param {Number} y2 Second vector y.\r\n     * @returns {Number} dot product result.\r\n     */\r\n    static dot(x1, y1, x2, y2) \r\n    {\r\n        return x1 * x2 + y1 * y2;\r\n    }\r\n\r\n    /**\r\n     * Convert degrees to radians.\r\n     * @param {Number} degrees Degrees value to convert to radians.\r\n     * @returns {Number} Value as radians.\r\n     */\r\n    static toRadians(degrees) \r\n    {\r\n        return degrees * _toRadsFactor;\r\n    }\r\n\r\n    /**\r\n     * Convert radians to degrees.\r\n     * @param {Number} radians Radians value to convert to degrees.\r\n     * @returns {Number} Value as degrees.\r\n     */\r\n    static toDegrees(radians) \r\n    {\r\n        return radians * _toDegreesFactor;\r\n    }\r\n\r\n    /**\r\n    * Find shortest distance between two radians, with sign (ie distance can be negative).\r\n    * @param {Number} a1 First radian.\r\n    * @param {Number} a2 Second radian.\r\n    * @returns {Number} Shortest distance between radians.\r\n    */\r\n    static radiansDistanceSigned(a1, a2)\r\n    {\r\n        var max = Math.PI * 2;\r\n        var da = (a2 - a1) % max;\r\n        return 2 * da % max - da;\r\n    }\r\n\r\n    /**\r\n    * Find shortest distance between two radians.\r\n    * @param {Number} a1 First radian.\r\n    * @param {Number} a2 Second radian.\r\n    * @returns {Number} Shortest distance between radians.\r\n    */\r\n    static radiansDistance(a1, a2)\r\n    {\r\n        return Math.abs(this.radiansDistanceSigned(a1, a2));\r\n    }\r\n\r\n\r\n    /**\r\n    * Find shortest distance between two angles in degrees, with sign (ie distance can be negative).\r\n    * @param {Number} a1 First angle.\r\n    * @param {Number} a2 Second angle.\r\n    * @returns {Number} Shortest distance between angles.\r\n    */\r\n    static degreesDistanceSigned(a1, a2)\r\n    {\r\n        let a1r = a1 * _toRadsFactor;\r\n        let a2r = a2 * _toRadsFactor;\r\n        let ret = this.radiansDistanceSigned(a1r, a2r);\r\n        return ret * _toDegreesFactor;\r\n    }\r\n\r\n    /**\r\n    * Find shortest distance between two angles in degrees.\r\n    * @param {Number} a1 First angle.\r\n    * @param {Number} a2 Second angle.\r\n    * @returns {Number} Shortest distance between angles.\r\n    */\r\n    static degreesDistance(a1, a2)\r\n    {\r\n        let a1r = a1 * _toRadsFactor;\r\n        let a2r = a2 * _toRadsFactor;\r\n        let ret = this.radiansDistance(a1r, a2r);\r\n        return ret * _toDegreesFactor;\r\n    }\r\n\r\n    /**\r\n     * Perform linear interpolation between radian values.\r\n     * Unlike the regular lerp method, this method will take wrapping into consideration, and will always lerp via the shortest distance.\r\n     * @param {Number} a1 Starting value.\r\n     * @param {Number} a2 Ending value.\r\n     * @param {Number} alpha How much to interpolate from start to end.\r\n     * @returns {Number} interpolated radians between start and end.\r\n     */\r\n    static lerpRadians(a1, a2, alpha)\r\n    {\r\n        // to prevent shaking on same values\r\n        if (a1 === a2) { return a2; }\r\n\r\n        // do lerping\r\n        return a1 + this.radiansDistanceSigned(a1, a2) * alpha;\r\n    }\r\n\r\n    /**\r\n     * Perform linear interpolation between degrees.\r\n     * Unlike the regular lerp method, this method will take wrapping into consideration, and will always lerp via the shortest distance.\r\n     * @param {Number} a1 Starting value.\r\n     * @param {Number} a2 Ending value.\r\n     * @param {Number} alpha How much to interpolate from start to end.\r\n     * @returns {Number} interpolated degrees between start and end.\r\n     */\r\n    static lerpDegrees(a1, a2, alpha)\r\n    {\r\n        // to prevent shaking on same values\r\n        if (a1 === a2) { return a2; }\r\n\r\n        // convert to radians\r\n        a1 = this.toRadians(a1);\r\n        a2 = this.toRadians(a2);\r\n\r\n        // lerp\r\n        var ret = this.lerpRadians(a1, a2, alpha);\r\n\r\n        // convert back to degrees and return\r\n        return this.toDegrees(ret);\r\n    }\r\n\r\n    /**\r\n    * Round numbers from 10'th digit.\r\n    * This is useful for calculations that should return round or almost round numbers, but have a long tail of 0's and 1 due to floating points accuracy.\r\n    * @param {Number} num Number to round.\r\n    * @returns {Number} Rounded number.\r\n    */\r\n    static round10(num)\r\n    {\r\n        return Math.round(num * 100000000.0) / 100000000.0;\r\n    }\r\n\r\n    /**\r\n     * Wrap degrees value to be between 0 to 360.\r\n     * @param {Number} degrees Degrees to wrap.\r\n     * @returns {Number} degrees wrapped to be 0-360 values.\r\n     */\r\n    static wrapDegrees(degrees)\r\n    {\r\n        degrees = degrees % 360;\r\n        if (degrees < 0) { degrees += 360; }\r\n        return degrees;\r\n    }\r\n}\r\n\r\n/**\r\n * PI * 2 value.\r\n */\r\nMathHelper.PI2 = Math.PI * 2;\r\n\r\n\r\n// export the math helper\r\nmodule.exports = MathHelper;", "/**\r\n * Define a color object.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\color.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\nconst MathHelper = require(\"./math_helper\");\r\n\r\n\r\n/**\r\n * Implement a color.\r\n * All color components are expected to be in 0.0 - 1.0 range (and not 0-255).\r\n */\r\nclass Color\r\n{\r\n    /**\r\n     * Create the color.\r\n     * @param {Number} r Color red component (value range: 0-1).\r\n     * @param {Number} g Color green component (value range: 0-1).\r\n     * @param {Number} b Color blue component (value range: 0-1).\r\n     * @param {Number} a Color alpha component (value range: 0-1).\r\n     */\r\n    constructor(r, g, b, a)\r\n    {\r\n        this.set(r, g, b, a);\r\n    }\r\n\r\n    /**\r\n     * Set the color components.\r\n     * @param {Number} r Color red component (value range: 0-1).\r\n     * @param {Number} g Color green component (value range: 0-1).\r\n     * @param {Number} b Color blue component (value range: 0-1).\r\n     * @param {Number} a Color alpha component (value range: 0-1).\r\n     * @returns {Color} this.\r\n     */\r\n    set(r, g, b, a)\r\n    {\r\n        this._r = r;\r\n        this._g = g;\r\n        this._b = b;\r\n        this._a = (a === undefined) ? 1 : a;\r\n        this._asHex = null;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the color components from byte values (0-255).\r\n     * @param {Number} r Color red component (value range: 0-255).\r\n     * @param {Number} g Color green component (value range: 0-255).\r\n     * @param {Number} b Color blue component (value range: 0-255).\r\n     * @param {Number} a Color alpha component (value range: 0-255).\r\n     * @returns {Color} this.\r\n     */\r\n    setByte(r, g, b, a)\r\n    {\r\n        this._r = r / 255.0;\r\n        this._g = g / 255.0;\r\n        this._b = b / 255.0;\r\n        this._a = (a === undefined) ? 1 : (a / 255.0);\r\n        this._asHex = null;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy all component values from another color.\r\n     * @param {Color} other Color to copy values from.\r\n     * @returns {Color} this.\r\n     */\r\n    copy(other)\r\n    {\r\n        this.set(other.r, other.g, other.b, other.a);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get r component.\r\n     * @returns {Number} Red component.\r\n     */\r\n    get r()\r\n    {\r\n        return this._r;\r\n    }\r\n\r\n    /**\r\n     * Get g component.\r\n     * @returns {Number} Green component.\r\n     */\r\n    get g()\r\n    {\r\n        return this._g;\r\n    }\r\n\r\n    /**\r\n     * Get b component.\r\n     * @returns {Number} Blue component.\r\n     */\r\n    get b()\r\n    {\r\n        return this._b;\r\n    }\r\n    \r\n    /**\r\n     * Get a component.\r\n     * @returns {Number} Alpha component.\r\n     */\r\n    get a()\r\n    {\r\n        return this._a;\r\n    }\r\n\r\n    /**\r\n     * Set r component.\r\n     * @returns {Number} Red component after change.\r\n     */\r\n    set r(val)\r\n    {\r\n        this._r = val;\r\n        this._asHex = null;\r\n        return this._r;\r\n    }\r\n\r\n    /**\r\n     * Set g component.\r\n     * @returns {Number} Green component after change.\r\n     */\r\n    set g(val)\r\n    {\r\n        this._g = val;\r\n        this._asHex = null;\r\n        return this._g;\r\n    }\r\n\r\n    /**\r\n     * Set b component.\r\n     * @returns {Number} Blue component after change.\r\n     */\r\n    set b(val)\r\n    {\r\n        this._b = val;\r\n        this._asHex = null;\r\n        return this._b;\r\n    }\r\n    \r\n    /**\r\n     * Set a component.\r\n     * @returns {Number} Alpha component after change.\r\n     */\r\n    set a(val)\r\n    {\r\n        this._a = val;\r\n        this._asHex = null;\r\n        return this._a;\r\n    }\r\n\r\n    /**\r\n     * Convert a single component to hex value.\r\n     * @param {Number} c Value to convert to hex.\r\n     * @returns {String} Component as hex value.\r\n     */\r\n    static componentToHex(c) \r\n    {\r\n        var hex = Math.round(c).toString(16);\r\n        return hex.length == 1 ? \"0\" + hex : hex;\r\n    }\r\n     \r\n    /**\r\n     * Convert this color to hex string (starting with '#').\r\n     * @returns {String} Color as hex.\r\n     */\r\n    get asHex() \r\n    {\r\n        if (!this._asHex) {\r\n            this._asHex = \"#\" + Color.componentToHex(this.r * 255) + Color.componentToHex(this.g * 255) + Color.componentToHex(this.b * 255) + Color.componentToHex(this.a * 255);\r\n        }\r\n        return this._asHex;\r\n    }\r\n\r\n    /**\r\n     * Create color from hex value.\r\n     * @param {string} val Number value (hex), as #rrggbbaa.\r\n     * @returns {Color} New color value.\r\n     */\r\n    static fromHex(val)\r\n    {\r\n        if (typeof val !== 'string' && val[0] != '#') {\r\n            throw new PintarJS.Error(\"Invalid color format!\");\r\n        }\r\n        var parsed = hexToColor(val);\r\n        if (!parsed) { throw new Error(\"Invalid hex value to parse!\"); }\r\n        return new Color(parsed.r, parsed.g, parsed.b, 1);\r\n    }\r\n\r\n    /**\r\n     * Create color from decimal value.\r\n     * @param {Number} val Number value (int).\r\n     * @param {Number} includeAlpha If true, will include alpha value.\r\n     * @returns {Color} New color value.\r\n     */\r\n    static fromDecimal(val, includeAlpha)\r\n    {\r\n        let ret = new Color(1, 1, 1, 1);\r\n        if (includeAlpha) { ret.a = (val & 0xff) / 255.0; val = val >> 8; }\r\n        ret.b = (val & 0xff) / 255.0; val = val >> 8;\r\n        ret.g = (val & 0xff) / 255.0; val = val >> 8;\r\n        ret.r = (val & 0xff) / 255.0;\r\n    }\r\n\r\n    /**\r\n     * Create color from a dictionary.\r\n     * @param {*} data Dictionary with {r,g,b,a}.\r\n     * @returns {Color} Newly created color.\r\n     */\r\n    static fromDict(data)\r\n    {\r\n        return new Color(data.r, data.g, data.b, data.a || 1);\r\n    }\r\n\r\n    /**\r\n     * Convert to dictionary.\r\n     * @returns {*} Dictionary with {r,g,b,a}\r\n     */\r\n    toDict()\r\n    {\r\n        return {r: this.r, g: this.g, b: this.b, a: this.a};\r\n    }\r\n\r\n    /**\r\n     * Convert this color to decimal number.\r\n     * @returns {Number} Color as decimal RGBA.\r\n     */\r\n    get asDecimalRGBA()\r\n    {\r\n      return ((Math.round(this.r * 255) << (8 * 3)) | (Math.round(this.g * 255) << (8 * 2)) | (Math.round(this.b * 255) << (8 * 1)) | (Math.round(this.a * 255)))>>>0;\r\n    }\r\n\r\n    /**\r\n     * Convert this color to decimal number.\r\n     * @returns {Number} Color as decimal ARGB.\r\n     */\r\n    get asDecimalABGR()\r\n    {\r\n      return ((Math.round(this.a * 255) << (8 * 3)) | (Math.round(this.b * 255) << (8 * 2)) | (Math.round(this.g * 255) << (8 * 1)) | (Math.round(this.r * 255)))>>>0;\r\n    }\r\n\r\n    /**\r\n     * Convert this color to a float array.\r\n     */\r\n    get floatArray()\r\n    {\r\n        return [this.r, this.g, this.b, this.a];\r\n    }\r\n\r\n    /**\r\n     * Return a clone of this color.\r\n     * @returns {Number} Cloned color.\r\n     */\r\n    clone()\r\n    {\r\n        return new Color(this.r, this.g, this.b, this.a);\r\n    }\r\n\r\n    /**\r\n     * Convert to string.\r\n     */\r\n    string() \r\n    {\r\n        return this.r + ',' + this.g + ',' + this.b + ',' + this.a;\r\n    }\r\n\r\n    /**\r\n     * Get if this color is pure black (ignoring alpha).\r\n     */\r\n    get isBlack()\r\n    {\r\n        return this.r == 0 && this.g == 0 && this.b == 0;\r\n    }\r\n\r\n    /**\r\n     * Return a random color.\r\n     * @param {Boolean} includeAlpha If true, will also randomize alpha.\r\n     * @returns {Color} Randomized color.\r\n     */\r\n    static random(includeAlpha)\r\n    {\r\n        return new Color(Math.random(), Math.random(), Math.random(), includeAlpha ? Math.random() : 1);\r\n    }\r\n\r\n    /**\r\n     * Build and return new color from bytes array.\r\n     * @param {Array<Number>} bytes Bytes array to build color from.\r\n     * @returns {Color} Newly created color.\r\n     */\r\n    static fromBytesArray(bytes)\r\n    {\r\n        return new Color(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] !== undefined ? (bytes[3] / 255) : 1);\r\n    }\r\n\r\n    /**\r\n     * Get if this color is transparent black.\r\n     */\r\n    get isTransparentBlack()\r\n    {\r\n        return this._r == this._g && this._g == this._b && this._b == this._a && this._a == 0;\r\n    }\r\n\r\n    /**\r\n     * Get array with all built-in web color names.\r\n     * @returns {Array<String>} Array with color names.\r\n     */\r\n    static get webColorNames()\r\n    {\r\n        return colorKeys;\r\n    }\r\n\r\n    /**\r\n     * Check if equal to another color.\r\n     * @param {PintarJS.Color} other Other color to compare to.\r\n     */\r\n    equals(other)\r\n    {\r\n        return (this === other) ||\r\n                (other && (other.constructor === this.constructor) && this._r == other._r && this._g == other._g && this._b == other._b && this._a == other._a);\r\n    }\r\n\r\n    /**\r\n     * Lerp between two colors.\r\n     * @param {Color} p1 First color.\r\n     * @param {Color} p2 Second color.\r\n     * @param {Number} a Lerp factor (0.0 - 1.0).\r\n     * @returns {Color} result color.\r\n     */\r\n    static lerp(p1, p2, a)\r\n    {\r\n        let lerpScalar = MathHelper.lerp;\r\n        return new Color(  lerpScalar(p1.r, p2.r, a), \r\n                        lerpScalar(p1.g, p2.g, a), \r\n                        lerpScalar(p1.b, p2.b, a), \r\n                        lerpScalar(p1.a, p2.a, a)\r\n                    );\r\n    }\r\n}\r\n\r\n// table to convert common color names to hex\r\nconst colorNameToHex = {\"aliceblue\":\"#f0f8ff\",\"antiquewhite\":\"#faebd7\",\"aqua\":\"#00ffff\",\"aquamarine\":\"#7fffd4\",\"azure\":\"#f0ffff\",\r\n    \"beige\":\"#f5f5dc\",\"bisque\":\"#ffe4c4\",\"black\":\"#000000\",\"blanchedalmond\":\"#ffebcd\",\"blue\":\"#0000ff\",\"blueviolet\":\"#8a2be2\",\"brown\":\"#a52a2a\",\"burlywood\":\"#deb887\",\r\n    \"cadetblue\":\"#5f9ea0\",\"chartreuse\":\"#7fff00\",\"chocolate\":\"#d2691e\",\"coral\":\"#ff7f50\",\"cornflowerblue\":\"#6495ed\",\"cornsilk\":\"#fff8dc\",\"crimson\":\"#dc143c\",\"cyan\":\"#00ffff\",\r\n    \"darkblue\":\"#00008b\",\"darkcyan\":\"#008b8b\",\"darkgoldenrod\":\"#b8860b\",\"darkgray\":\"#a9a9a9\",\"darkgreen\":\"#006400\",\"darkkhaki\":\"#bdb76b\",\"darkmagenta\":\"#8b008b\",\"darkolivegreen\":\"#556b2f\",\r\n    \"darkorange\":\"#ff8c00\",\"darkorchid\":\"#9932cc\",\"darkred\":\"#8b0000\",\"darksalmon\":\"#e9967a\",\"darkseagreen\":\"#8fbc8f\",\"darkslateblue\":\"#483d8b\",\"darkslategray\":\"#2f4f4f\",\"darkturquoise\":\"#00ced1\",\r\n    \"darkviolet\":\"#9400d3\",\"deeppink\":\"#ff1493\",\"deepskyblue\":\"#00bfff\",\"dimgray\":\"#696969\",\"dodgerblue\":\"#1e90ff\",\r\n    \"firebrick\":\"#b22222\",\"floralwhite\":\"#fffaf0\",\"forestgreen\":\"#228b22\",\"fuchsia\":\"#ff00ff\",\r\n    \"gainsboro\":\"#dcdcdc\",\"ghostwhite\":\"#f8f8ff\",\"gold\":\"#ffd700\",\"goldenrod\":\"#daa520\",\"gray\":\"#808080\",\"green\":\"#008000\",\"greenyellow\":\"#adff2f\",\r\n    \"honeydew\":\"#f0fff0\",\"hotpink\":\"#ff69b4\",\r\n    \"indianred \":\"#cd5c5c\",\"indigo\":\"#4b0082\",\"ivory\":\"#fffff0\",\"khaki\":\"#f0e68c\",\r\n    \"lavender\":\"#e6e6fa\",\"lavenderblush\":\"#fff0f5\",\"lawngreen\":\"#7cfc00\",\"lemonchiffon\":\"#fffacd\",\"lightblue\":\"#add8e6\",\"lightcoral\":\"#f08080\",\"lightcyan\":\"#e0ffff\",\"lightgoldenrodyellow\":\"#fafad2\",\r\n    \"lightgrey\":\"#d3d3d3\",\"lightgreen\":\"#90ee90\",\"lightpink\":\"#ffb6c1\",\"lightsalmon\":\"#ffa07a\",\"lightseagreen\":\"#20b2aa\",\"lightskyblue\":\"#87cefa\",\"lightslategray\":\"#778899\",\"lightsteelblue\":\"#b0c4de\",\r\n    \"lightyellow\":\"#ffffe0\",\"lime\":\"#00ff00\",\"limegreen\":\"#32cd32\",\"linen\":\"#faf0e6\",\r\n    \"magenta\":\"#ff00ff\",\"maroon\":\"#800000\",\"mediumaquamarine\":\"#66cdaa\",\"mediumblue\":\"#0000cd\",\"mediumorchid\":\"#ba55d3\",\"mediumpurple\":\"#9370d8\",\"mediumseagreen\":\"#3cb371\",\"mediumslateblue\":\"#7b68ee\",\r\n    \"mediumspringgreen\":\"#00fa9a\",\"mediumturquoise\":\"#48d1cc\",\"mediumvioletred\":\"#c71585\",\"midnightblue\":\"#191970\",\"mintcream\":\"#f5fffa\",\"mistyrose\":\"#ffe4e1\",\"moccasin\":\"#ffe4b5\",\r\n    \"navajowhite\":\"#ffdead\",\"navy\":\"#000080\",\r\n    \"oldlace\":\"#fdf5e6\",\"olive\":\"#808000\",\"olivedrab\":\"#6b8e23\",\"orange\":\"#ffa500\",\"orangered\":\"#ff4500\",\"orchid\":\"#da70d6\",\r\n    \"palegoldenrod\":\"#eee8aa\",\"palegreen\":\"#98fb98\",\"paleturquoise\":\"#afeeee\",\"palevioletred\":\"#d87093\",\"papayawhip\":\"#ffefd5\",\"peachpuff\":\"#ffdab9\",\"peru\":\"#cd853f\",\"pink\":\"#ffc0cb\",\"plum\":\"#dda0dd\",\"powderblue\":\"#b0e0e6\",\"purple\":\"#800080\",\r\n    \"rebeccapurple\":\"#663399\",\"red\":\"#ff0000\",\"rosybrown\":\"#bc8f8f\",\"royalblue\":\"#4169e1\",\r\n    \"saddlebrown\":\"#8b4513\",\"salmon\":\"#fa8072\",\"sandybrown\":\"#f4a460\",\"seagreen\":\"#2e8b57\",\"seashell\":\"#fff5ee\",\"sienna\":\"#a0522d\",\"silver\":\"#c0c0c0\",\"skyblue\":\"#87ceeb\",\"slateblue\":\"#6a5acd\",\"slategray\":\"#708090\",\"snow\":\"#fffafa\",\"springgreen\":\"#00ff7f\",\"steelblue\":\"#4682b4\",\r\n    \"tan\":\"#d2b48c\",\"teal\":\"#008080\",\"thistle\":\"#d8bfd8\",\"tomato\":\"#ff6347\",\"turquoise\":\"#40e0d0\",\r\n    \"violet\":\"#ee82ee\",\r\n    \"wheat\":\"#f5deb3\",\"white\":\"#ffffff\",\"whitesmoke\":\"#f5f5f5\",\r\n    \"yellow\":\"#ffff00\",\"yellowgreen\":\"#9acd32\"};\r\n\r\n// create getter function for all named color\r\nfor (var key in colorNameToHex) {\r\n    if (colorNameToHex.hasOwnProperty(key)) {\r\n        var colorValue = hexToColor(colorNameToHex[key]);\r\n        (function(_colValue) {\r\n\r\n            Object.defineProperty (Color, key, {\r\n                get: function () { \r\n                    return _colValue.clone();\r\n                }\r\n            });\r\n\r\n        })(colorValue);\r\n    }\r\n}\r\n\r\n// built-in color keys\r\nconst colorKeys = Object.keys(colorNameToHex);\r\nObject.freeze(colorKeys);\r\n\r\n// add transparent getter\r\nObject.defineProperty (Color, 'transparent', {\r\n    get: function () { \r\n        return new Color(0, 0, 0, 0);\r\n    }\r\n});\r\n\r\n// add transparent white getter\r\nObject.defineProperty (Color, 'transwhite', {\r\n    get: function () { \r\n        return new Color(1, 1, 1, 0);\r\n    }\r\n});\r\n\r\n\r\n/**\r\n * Convert Hex value to Color instance.\r\n * @param {String} hex Hex value to parse.\r\n */\r\nfunction hexToColor(hex) \r\n{\r\n    // expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\r\n    var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n    hex = hex.replace(shorthandRegex, function(m, r, g, b) {\r\n        return r + r + g + g + b + b;\r\n    });\r\n    \r\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    var components = result ? {\r\n        r: parseInt(result[1], 16) / 255.0,\r\n        g: parseInt(result[2], 16) / 255.0,\r\n        b: parseInt(result[3], 16) / 255.0\r\n    } : null;\r\n\r\n    // create Color instance\r\n    if (!components) { throw new Error(\"Invalid hex value to parse!\"); }\r\n    return new Color(components.r, components.g, components.b, 1);\r\n}\r\n\r\n\r\n// export Color object\r\nmodule.exports = Color;", "/**\r\n * Define supported blend modes.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\blend_modes.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n\r\n/**\r\n * Blend modes we can draw with, determine how we blend new draws with existing buffer.\r\n */\r\nconst BlendModes = {\r\n    AlphaBlend: \"alpha\",\r\n    Opaque: \"opaque\",\r\n    Additive: \"additive\",\r\n    Multiply: \"multiply\",\r\n    Subtract: \"subtract\",\r\n    Screen: \"screen\",\r\n    Overlay: \"overlay\",\r\n    Invert: \"invert\",\r\n    Darken: \"darken\",\r\n    DestIn: \"dest-in\",\r\n    DestOut: \"dest-out\"\r\n};\r\n\r\nObject.defineProperty(BlendModes, '_values', {\r\n    value: new Set(Object.values(BlendModes)),\r\n    writable: false,\r\n});\r\nObject.freeze(BlendModes);\r\n\r\nmodule.exports = BlendModes;", "/**\r\n * Implement a simple 2d vector.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\vector2.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\nconst MathHelper = require(\"./math_helper\");\r\n\r\n/**\r\n * A simple Vector object for 2d positions.\r\n */\r\nclass Vector2\r\n{\r\n    /**\r\n     * Create the Vector object.\r\n     * @param {number} x Vector X.\r\n     * @param {number} y Vector Y.\r\n     */\r\n    constructor(x = 0, y = 0)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    \r\n    /**\r\n     * Clone the vector.\r\n     * @returns {Vector2} cloned vector.\r\n     */\r\n    clone()\r\n    {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n    \r\n    /**\r\n     * Set vector value.\r\n     * @param {Number} x X component.\r\n     * @param {Number} y Y component.\r\n     * @returns {Vector2} this.\r\n     */\r\n    set(x, y)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy values from other vector into self.\r\n     * @returns {Vector2} this.\r\n     */\r\n    copy(other) \r\n    {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Return a new vector of this + other.\r\n     * @param {Number|Vector2} Other Vector or number to add.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    add(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            return new Vector2(this.x + other, this.y + (arguments[1] === undefined ? other : arguments[1]));\r\n        }\r\n        return new Vector2(this.x + other.x, this.y + other.y);\r\n    }\r\n    \r\n    /**\r\n     * Return a new vector of this - other.\r\n     * @param {Number|Vector2} Other Vector or number to sub.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    sub(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            return new Vector2(this.x - other, this.y - (arguments[1] === undefined ? other : arguments[1]));\r\n        }\r\n        return new Vector2(this.x - other.x, this.y - other.y);\r\n    }\r\n    \r\n    /**\r\n     * Return a new vector of this / other.\r\n     * @param {Number|Vector2} Other Vector or number to divide.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    div(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            return new Vector2(this.x / other, this.y / (arguments[1] === undefined ? other : arguments[1]));\r\n        }\r\n        return new Vector2(this.x / other.x, this.y / other.y);\r\n    }\r\n    \r\n    /**\r\n     * Return a new vector of this * other.\r\n     * @param {Number|Vector2} Other Vector or number to multiply.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    mul(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            return new Vector2(this.x * other, this.y * (arguments[1] === undefined ? other : arguments[1]));\r\n        }\r\n        return new Vector2(this.x * other.x, this.y * other.y);\r\n    }\r\n    \r\n    /**\r\n     * Return a round copy of this vector.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    round() \r\n    {\r\n        return new Vector2(Math.round(this.x), Math.round(this.y));\r\n    }\r\n    \r\n    /**\r\n     * Return a floored copy of this vector.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    floor() \r\n    {\r\n        return new Vector2(Math.floor(this.x), Math.floor(this.y));\r\n    }\r\n        \r\n    /**\r\n     * Return a ceiled copy of this vector.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    ceil() \r\n    {\r\n        return new Vector2(Math.ceil(this.x), Math.ceil(this.y));\r\n    }\r\n    \r\n    /**\r\n     * Return a normalized copy of this vector.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    normalized()\r\n    {\r\n        if (this.x == 0 && this.y == 0) { return Vector2.zero; }\r\n        let mag = this.length;\r\n        return new Vector2(this.x / mag, this.y / mag);\r\n    }\r\n\r\n    /**\r\n     * Add other vector values to self.\r\n     * @param {Number|Vector2} Other Vector or number to add.\r\n     * @returns {Vector2} this.\r\n     */\r\n    addSelf(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            this.x += other;\r\n            this.y += (arguments[1] === undefined ? other : arguments[1]);\r\n        }\r\n        else {\r\n            this.x += other.x;\r\n            this.y += other.y;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sub other vector values from self.\r\n     * @param {Number|Vector2} Other Vector or number to substract.\r\n     * @returns {Vector2} this.\r\n     */\r\n    subSelf(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            this.x -= other;\r\n            this.y -= (arguments[1] === undefined ? other : arguments[1]);\r\n        }\r\n        else {\r\n            this.x -= other.x;\r\n            this.y -= other.y;\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Divide this vector by other vector values.\r\n     * @param {Number|Vector2} Other Vector or number to divide by.\r\n     * @returns {Vector2} this.\r\n     */\r\n    divSelf(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            this.x /= other;\r\n            this.y /= (arguments[1] === undefined ? other : arguments[1]);\r\n        }\r\n        else {\r\n            this.x /= other.x;\r\n            this.y /= other.y;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiply this vector by other vector values.\r\n     * @param {Number|Vector2} Other Vector or number to multiply by.\r\n     * @returns {Vector2} this.\r\n     */\r\n    mulSelf(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            this.x *= other;\r\n            this.y *= (arguments[1] === undefined ? other : arguments[1]);\r\n        }\r\n        else {\r\n            this.x *= other.x;\r\n            this.y *= other.y;\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Round self.\r\n     * @returns {Vector2} this.\r\n     */\r\n    roundSelf() \r\n    {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Floor self.\r\n     * @returns {Vector2} this.\r\n     */\r\n    floorSelf() \r\n    {\r\n        this.x = Math.floor(this.x);\r\n        this.y = Math.floor(this.y);\r\n        return this;\r\n    }\r\n     \r\n    /**\r\n     * Ceil self.\r\n     * @returns {Vector2} this.\r\n     */\r\n    ceilSelf() \r\n    {\r\n        this.x = Math.ceil(this.x);\r\n        this.y = Math.ceil(this.y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return a normalized copy of this vector.\r\n     * @returns {Vector2} this.\r\n     */\r\n    normalizeSelf()\r\n    {\r\n        if (this.x == 0 && this.y == 0) { return this; }\r\n        let mag = this.length;\r\n        this.x /= mag;\r\n        this.y /= mag;\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Return if vector equals another vector.\r\n     * @param {Vector2} other Other vector to compare to.\r\n     * @returns {Boolean} if vectors are equal.\r\n     */\r\n    equals(other)\r\n    {\r\n        return ((this === other) || ((other.constructor === this.constructor) && this.x === other.x && this.y === other.y));\r\n    }\r\n    \r\n    /**\r\n     * Return if vector approximately equals another vector.\r\n     * @param {Vector2} other Other vector to compare to.\r\n     * @param {Number} threshold Distance threshold to consider as equal. Defaults to 1.\r\n     * @returns {Boolean} if vectors are equal.\r\n     */\r\n    approximate(other, threshold)\r\n    {\r\n        threshold = threshold || 1;\r\n        return ((this === other) || \r\n                (\r\n                 (Math.abs(this.x - other.x) <= threshold) && \r\n                 (Math.abs(this.y - other.y) <= threshold))\r\n                );\r\n    }\r\n\r\n    /**\r\n     * Return vector length (aka magnitude).\r\n     * @returns {Number} Vector length.\r\n     */\r\n    get length()\r\n    {\r\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\r\n    }\r\n\r\n    /**\r\n     * Return a copy of this vector multiplied by a factor.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    scaled(fac) \r\n    {\r\n        return new Vector2(this.x * fac, this.y * fac);\r\n    }\r\n\r\n    /**\r\n     * Get vector (0,0).\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static get zero()\r\n    {\r\n        return new Vector2();\r\n    }\r\n\r\n    /**\r\n     * Get vector with 1,1 values.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static get one()\r\n    {\r\n        return new Vector2(1, 1);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 0.5,0.5 values.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static get half()\r\n    {\r\n        return new Vector2(0.5, 0.5);\r\n    }\r\n\r\n    /**\r\n     * Get vector with -1,0 values.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static get left()\r\n    {\r\n        return new Vector2(-1, 0);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 1,0 values.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static get right()\r\n    {\r\n        return new Vector2(1, 0);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 0,-1 values.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static get up()\r\n    {\r\n        return new Vector2(0, -1);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 0,1 values.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static get down()\r\n    {\r\n        return new Vector2(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Get a random vector with length of 1.\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static get random()\r\n    {\r\n        return Vector2.fromDegree(Math.random() * 360);\r\n    }\r\n\r\n    /**\r\n     * Get degrees between this vector and another vector.\r\n     * @param {Vector2} other Other vector.\r\n     * @returns {Number} Angle between vectors in degrees.\r\n     */\r\n    degreesTo(other) \r\n    {\r\n        return Vector2.degreesBetween(this, other);\r\n    };\r\n\r\n    /**\r\n     * Get radians between this vector and another vector.\r\n     * @param {Vector2} other Other vector.\r\n     * @returns {Number} Angle between vectors in radians.\r\n     */\r\n    radiansTo(other) \r\n    {\r\n        return Vector2.radiansBetween(this, other);\r\n    };\r\n    \r\n    /**\r\n     * Get degrees between this vector and another vector.\r\n     * Return values between 0 to 360.\r\n     * @param {Vector2} other Other vector.\r\n     * @returns {Number} Angle between vectors in degrees.\r\n     */\r\n    degreesToFull(other) \r\n    {\r\n        return Vector2.degreesBetweenFull(this, other);\r\n    };\r\n\r\n    /**\r\n     * Get radians between this vector and another vector.\r\n     * Return values between 0 to PI2.\r\n     * @param {Vector2} other Other vector.\r\n     * @returns {Number} Angle between vectors in radians.\r\n     */\r\n    radiansToFull(other) \r\n    {\r\n        return Vector2.radiansBetweenFull(this, other);\r\n    };\r\n    \r\n    /**\r\n     * Calculate distance between this vector and another vectors.\r\n     * @param {Vector2} other Other vector.\r\n     * @returns {Number} Distance between vectors.\r\n     */\r\n    distanceTo(other)\r\n    {\r\n        return Vector2.distance(this, other);\r\n    }\r\n    \r\n    /**\r\n     * Get vector from degrees.\r\n     * @param {Number} degrees Angle to create vector from (0 = vector pointing right).\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static fromDegree(degrees)\r\n    {\r\n        let rads = degrees * (Math.PI / 180);\r\n        return new Vector2(Math.cos(rads), Math.sin(rads));\r\n    }\r\n\r\n    /**\r\n     * Get vector from radians.\r\n     * @param {Number} radians Angle to create vector from (0 = vector pointing right).\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static fromRadians(radians)\r\n    {\r\n        return new Vector2(Math.cos(radians), Math.sin(radians));\r\n    }\r\n    \r\n    /**\r\n     * Lerp between two vectors.\r\n     * @param {Vector2} p1 First vector.\r\n     * @param {Vector2} p2 Second vector.\r\n     * @param {Number} a Lerp factor (0.0 - 1.0).\r\n     * @returns {Vector2} result vector.\r\n     */\r\n    static lerp(p1, p2, a)\r\n    {\r\n        let lerpScalar = MathHelper.lerp;\r\n        return new Vector2(lerpScalar(p1.x, p2.x, a), lerpScalar(p1.y, p2.y, a));\r\n    }\r\n\r\n    /**\r\n     * Get degrees between two vectors.\r\n     * Return values between -180 to 180.\r\n     * @param {Vector2} p1 First vector.\r\n     * @param {Vector2} p2 Second vector.\r\n     * @returns {Number} Angle between vectors in degrees.\r\n     */\r\n    static degreesBetween(P1, P2) \r\n    {\r\n        let deltaY = P2.y - P1.y,\r\n        deltaX = P2.x - P1.x;\r\n        return Math.atan2(deltaY, deltaX) * (180 / Math.PI);\r\n    };\r\n\r\n    /**\r\n     * Get radians between two vectors.\r\n     * Return values between -PI to PI.\r\n     * @param {Vector2} p1 First vector.\r\n     * @param {Vector2} p2 Second vector.\r\n     * @returns {Number} Angle between vectors in radians.\r\n     */\r\n    static radiansBetween(P1, P2) \r\n    {\r\n        return MathHelper.toRadians(Vector2.degreesBetween(P1, P2));\r\n    };\r\n    \r\n    /**\r\n     * Get degrees between two vectors.\r\n     * Return values between 0 to 360.\r\n     * @param {Vector2} p1 First vector.\r\n     * @param {Vector2} p2 Second vector.\r\n     * @returns {Number} Angle between vectors in degrees.\r\n     */\r\n    static degreesBetweenFull(P1, P2) \r\n    {\r\n        let temp = P2.sub(P1);\r\n        return temp.getDegrees();\r\n    };\r\n\r\n    /**\r\n     * Get vector's angle in degrees.\r\n     * @returns {Number} Vector angle in degrees.\r\n     */\r\n    getDegrees()\r\n    {\r\n        var angle = Math.atan2(this.y, this.x);\r\n        var degrees = 180 * angle / Math.PI;\r\n        return (360+Math.round(degrees)) % 360;\r\n    }\r\n\r\n    /**\r\n     * Get vector's angle in radians.\r\n     * @returns {Number} Vector angle in degrees.\r\n     */\r\n    getRadians()\r\n    {\r\n        var angle = Math.atan2(this.y, this.x);\r\n        return angle;\r\n    }\r\n    \r\n    /**\r\n     * Get radians between two vectors.\r\n     * Return values between 0 to PI2.\r\n     * @param {Vector2} p1 First vector.\r\n     * @param {Vector2} p2 Second vector.\r\n     * @returns {Number} Angle between vectors in radians.\r\n     */\r\n    static radiansBetweenFull(P1, P2) \r\n    {\r\n        return MathHelper.toRadians(Vector2.degreesBetweenFull(P1, P2));\r\n    };\r\n\r\n    /**\r\n     * Calculate distance between two vectors.\r\n     * @param {Vector2} p1 First vector.\r\n     * @param {Vector2} p2 Second vector.\r\n     * @returns {Number} Distance between vectors.\r\n     */\r\n    static distance(p1, p2)\r\n    {\r\n        let a = p1.x - p2.x;\r\n        let b = p1.y - p2.y;\r\n        return Math.sqrt(a*a + b*b);\r\n    }\r\n\r\n    /**\r\n     * Return cross product between two vectors.\r\n     * @param {Vector2} p1 First vector.\r\n     * @param {Vector2} p2 Second vector.\r\n     * @returns {Number} Cross between vectors.\r\n     */\r\n    static cross(p1, p2)\r\n    {\r\n        return p1.x * p2.y - p1.y * p2.x;\r\n    }\r\n     \r\n    /**\r\n     * Return dot product between two vectors.\r\n     * @param {Vector2} p1 First vector.\r\n     * @param {Vector2} p2 Second vector.\r\n     * @returns {Number} Dot between vectors.\r\n     */\r\n    static dot(p1, p2)\r\n    {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    /**\r\n     * Convert to string.\r\n     */\r\n    string()\r\n    {\r\n        return this.x + ',' + this.y;\r\n    }\r\n\r\n    /**\r\n     * Parse and return a vector object from string in the form of \"x,y\".\r\n     * @param {String} str String to parse.\r\n     * @returns {Vector2} Parsed vector.\r\n     */\r\n    static parse(str)\r\n    {\r\n        let parts = str.split(',');\r\n        return new Vector2(parseFloat(parts[0].trim()), parseFloat(parts[1].trim()));\r\n    }\r\n\r\n    /**\r\n     * Convert to array of numbers.\r\n     * @returns {Array<Number>} Vector components as array.\r\n     */\r\n    toArray()\r\n    {\r\n        return [this.x, this.y];\r\n    }\r\n\r\n    /**\r\n     * Create vector from array of numbers.\r\n     * @param {Array<Number>} arr Array of numbers to create vector from.\r\n     * @returns {Vector2} Vector instance.\r\n     */\r\n    static fromArray(arr)\r\n    {\r\n        return new Vector2(arr[0], arr[1]);\r\n    }\r\n\r\n    /**\r\n     * Create vector from a dictionary.\r\n     * @param {*} data Dictionary with {x,y}.\r\n     * @returns {Vector2} Newly created vector.\r\n     */\r\n    static fromDict(data)\r\n    {\r\n        return new Vector2(data.x, data.y);\r\n    }\r\n\r\n    /**\r\n     * Convert to dictionary.\r\n     * @returns {*} Dictionary with {x,y}\r\n     */\r\n    toDict()\r\n    {\r\n        return {x: this.x, y: this.y};\r\n    }\r\n}\r\n\r\n// export vector object\r\nmodule.exports = Vector2;", "/**\r\n * Implement a simple 2d circle.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\circle.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\nconst MathHelper = require('./math_helper');\r\nconst Vector2 = require('./vector2');\r\n\r\n\r\n/**\r\n * Implement a simple 2d Circle.\r\n */\r\nclass Circle\r\n{\r\n    /**\r\n     * Create the Circle.\r\n     * @param {Vector2} center Circle center position.\r\n     * @param {Number} radius Circle radius.\r\n     */\r\n    constructor(center, radius)\r\n    {\r\n        this.center = center.clone();\r\n        this.radius = radius;\r\n    }\r\n\r\n    /**\r\n     * Return a clone of this circle.\r\n     * @returns {Circle} Cloned circle.\r\n     */\r\n    clone()\r\n    {\r\n        return new Circle(this.center, this.radius);\r\n    }\r\n\r\n    /**\r\n     * Check if this circle contains a Vector2.\r\n     * @param {Vector2} p Point to check.\r\n     * @returns {Boolean} if point is contained within the circle.\r\n     */\r\n    containsVector(p) \r\n    {\r\n        return this.center.distanceTo(p) <= this.radius;\r\n    }\r\n\r\n    /**\r\n     * Check if equal to another circle.\r\n     * @param {Circle} other Other circle to compare to.\r\n     * @returns {Boolean} True if circles are equal, false otherwise.\r\n     */\r\n    equals(other)\r\n    {\r\n        return (other === this) || \r\n                (other && (other.constructor === this.constructor) && this.center.equals(other.center) && this.radius == other.radius);\r\n    }\r\n\r\n    /**\r\n     * Lerp between two circle.\r\n     * @param {Circle} p1 First circle.\r\n     * @param {Circle} p2 Second circle.\r\n     * @param {Number} a Lerp factor (0.0 - 1.0).\r\n     * @returns {Circle} result circle.\r\n     */\r\n    static lerp(p1, p2, a)\r\n    {\r\n        let lerpScalar = MathHelper.lerp;\r\n        return new Circle(Vector2.lerp(p1.center, p2.center, a), lerpScalar(p1.radius, p2.radius, a));\r\n    }\r\n}\r\n\r\n\r\n// export the circle class\r\nmodule.exports = Circle;", "/**\r\n * Implement a simple 2d line.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\line.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\nconst Vector2 = require('./vector2');\r\n\r\n\r\n/**\r\n * Implement a simple 2d Line.\r\n */\r\nclass Line\r\n{\r\n    /**\r\n     * Create the Line.\r\n     * @param {Vector2} from Line start position.\r\n     * @param {Vector2} to Line end position.\r\n     */\r\n    constructor(from, to)\r\n    {\r\n        this.from = from.clone();\r\n        this.to = to.clone();\r\n    }\r\n\r\n    /**\r\n     * Return a clone of this line.\r\n     * @returns {Line} Cloned line.\r\n     */\r\n    clone()\r\n    {\r\n        return new Line(this.from, this.to);\r\n    }\r\n\r\n    /**\r\n     * Check if this circle contains a Vector2.\r\n     * @param {Vector2} p Point to check.\r\n     * @param {Number} threshold Distance between point and line to consider as intersecting. Default is 0.5, meaning it will treat point and line as round integers (sort-of).\r\n     * @returns {Boolean} if point is contained within the circle.\r\n     */\r\n    containsVector(p, threshold)\r\n    {\r\n        let A = this.from;\r\n        let B = this.to;\r\n        let distance = Vector2.distance;\r\n        if (threshold === undefined) { threshold = 0.5; }\r\n        return Math.abs((distance(A, p) + distance(B, p)) - distance(A, B)) <= threshold;\r\n    }\r\n\r\n    /**\r\n     * Check if this line collides with another line.\r\n     * @param {Line} other Other line to test collision with.\r\n     * @returns {Boolean} True if lines collide, false otherwise.\r\n     */\r\n    collideLine(other)\r\n    {\r\n        let p0 = this.from;\r\n        let p1 = this.to;\r\n        let p2 = other.from;\r\n        let p3 = other.to;\r\n\r\n        if (p0.equals(p2) || p0.equals(p3) || p1.equals(p2) || p1.equals(p3)) {\r\n            return true;\r\n        }\r\n\r\n        let s1_x, s1_y, s2_x, s2_y;\r\n        s1_x = p1.x - p0.x;\r\n        s1_y = p1.y - p0.y;\r\n        s2_x = p3.x - p2.x;\r\n        s2_y = p3.y - p2.y;\r\n    \r\n        let s, t;\r\n        s = (-s1_y * (p0.x - p2.x) + s1_x * (p0.y - p2.y)) / (-s2_x * s1_y + s1_x * s2_y);\r\n        t = (s2_x * (p0.y - p2.y) - s2_y * (p0.x - p2.x)) / (-s2_x * s1_y + s1_x * s2_y);\r\n    \r\n        return (s >= 0 && s <= 1 && t >= 0 && t <= 1);\r\n    }\r\n\r\n    /**\r\n     * Get the shortest distance between this line segment and a vector.\r\n     * @param {Vector2} v Vector to get distance to.\r\n     * @returns {Number} Shortest distance between line and vector.\r\n     */\r\n    distanceToVector(v)\r\n    {\r\n        let x1 = this.from.x;\r\n        let x2 = this.to.x;\r\n        let y1 = this.from.y;\r\n        let y2 = this.to.y;\r\n\r\n        var A = v.x - x1;\r\n        var B = v.y - y1;\r\n        var C = x2 - x1;\r\n        var D = y2 - y1;\r\n      \r\n        var dot = A * C + B * D;\r\n        var len_sq = C * C + D * D;\r\n        var param = -1;\r\n        if (len_sq != 0) //in case of 0 length line\r\n            param = dot / len_sq;\r\n      \r\n        var xx, yy;\r\n      \r\n        if (param < 0) {\r\n          xx = x1;\r\n          yy = y1;\r\n        }\r\n        else if (param > 1) {\r\n          xx = x2;\r\n          yy = y2;\r\n        }\r\n        else {\r\n          xx = x1 + param * C;\r\n          yy = y1 + param * D;\r\n        }\r\n      \r\n        var dx = v.x - xx;\r\n        var dy = v.y - yy;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    /**\r\n     * Check if equal to another circle.\r\n     * @param {Circle} other Other circle to compare to.\r\n     * @returns {Boolean} True if circles are equal, false otherwise.\r\n     */\r\n    equals(other)\r\n    {\r\n        return (this === other) || \r\n                (other && (other.constructor === this.constructor) && this.from.equals(other.from) && this.to.equals(other.to));\r\n    }\r\n\r\n    /**\r\n     * Lerp between two lines.\r\n     * @param {Line} l1 First lines.\r\n     * @param {Line} l2 Second lines.\r\n     * @param {Number} a Lerp factor (0.0 - 1.0).\r\n     * @returns {Line} result lines.\r\n     */\r\n    static lerp(l1, l2, a)\r\n    {\r\n        return new Line(Vector2.lerp(l1.from, l2.from, a), Vector2.lerp(l1.to, l2.to, a));\r\n    }\r\n}\r\n\r\n\r\n// export the line class\r\nmodule.exports = Line;", "/**\r\n * Implement a simple 2d rectangle.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\rectangle.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n\r\nconst Circle = require('./circle');\r\nconst Line = require('./line');\r\nconst MathHelper = require('./math_helper');\r\nconst Vector2 = require('./vector2');\r\n\r\n\r\n/**\r\n * Implement a simple 2d Rectangle.\r\n */\r\nclass Rectangle\r\n{\r\n    /**\r\n     * Create the Rect.\r\n     * @param {Number} x Rect position X (top left corner).\r\n     * @param {Number} y Rect position Y (top left corner).\r\n     * @param {Number} width Rect width.\r\n     * @param {Number} height Rect height.\r\n     */\r\n    constructor(x, y, width, height)\r\n    {\r\n        this.x = x || 0;\r\n        this.y = y || 0;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    /**\r\n     * Set rectangle values.\r\n     * @param {Number} x Rectangle x position.\r\n     * @param {Number} y Rectangle y position.\r\n     * @param {Number} width Rectangle width.\r\n     * @param {Number} height Rectangle height.\r\n     * @returns {Rectangle} this.\r\n     */\r\n    set(x, y, width, height)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy another rectangle.\r\n     * @param {other} other Rectangle to copy.\r\n     * @returns {Rectangle} this.\r\n     */\r\n    copy(other)\r\n    {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get position as Vector2.\r\n     * @returns {Vector2} Position vector.\r\n     */\r\n    getPosition()\r\n    {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n    \r\n    /**\r\n     * Get size as Vector2.\r\n     * @returns {Vector2} Size vector.\r\n     */\r\n    getSize()\r\n    {\r\n        return new Vector2(this.width, this.height);\r\n    }\r\n\t\r\n\t/**\r\n     * Get center position.\r\n     * @returns {Vector2} Position vector.\r\n     */\r\n    getCenter()\r\n    {\r\n        return new Vector2(Math.round(this.x + this.width / 2), Math.round(this.y + this.height / 2));\r\n    }\r\n\r\n    /**\r\n     * Get left value.\r\n     * @returns {Number} rectangle left.\r\n     */\r\n    get left()\r\n    {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Get right value.\r\n     * @returns {Number} rectangle right.\r\n     */\r\n    get right()\r\n    {\r\n        return this.x + this.width;\r\n    }\r\n\r\n    /**\r\n     * Get top value.\r\n     * @returns {Number} rectangle top.\r\n     */\r\n    get top()\r\n    {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Get bottom value.\r\n     * @returns {Number} rectangle bottom.\r\n     */\r\n    get bottom()\r\n    {\r\n        return this.y + this.height;\r\n    }\r\n\r\n    /**\r\n     * Return a clone of this rectangle.\r\n     * @returns {Rectangle} Cloned rectangle.\r\n     */\r\n    clone()\r\n    {\r\n        return new Rectangle(this.x, this.y, this.width, this.height);\r\n    }\r\n\r\n    /**\r\n     * Get top-left corner.\r\n     * @returns {Vector2} Corner position vector.\r\n     */\r\n    getTopLeft()\r\n    {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Get top-right corner.\r\n     * @returns {Vector2} Corner position vector.\r\n     */\r\n    getTopRight()\r\n    {\r\n        return new Vector2(this.x + this.width, this.y);\r\n    }\r\n        \r\n    /**\r\n     * Get bottom-left corner.\r\n     * @returns {Vector2} Corner position vector.\r\n     */\r\n    getBottomLeft()\r\n    {\r\n        return new Vector2(this.x, this.y + this.height);\r\n    }\r\n\r\n    /**\r\n     * Get bottom-right corner.\r\n     * @returns {Vector2} Corner position vector.\r\n     */\r\n    getBottomRight()\r\n    {\r\n        return new Vector2(this.x + this.width, this.y + this.height);\r\n    }\r\n\r\n    /**\r\n     * Convert to string.\r\n     */\r\n    string() \r\n    {\r\n        return this.x + ',' + this.y + ',' + this.width + ',' + this.height;\r\n    }\r\n\r\n    /**\r\n     * Check if this rectangle contains a Vector2.\r\n     * @param {Vector2} p Point to check.\r\n     * @returns {Boolean} if point is contained within the rectangle.\r\n     */\r\n    containsVector(p) \r\n    {\r\n        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\r\n    }\r\n\r\n    /**\r\n     * Check if this rectangle collides with another rectangle.\r\n     * @param {Rectangle} other Rectangle to check collision with.\r\n     * @return {Boolean} if rectangles collide.\r\n     */\r\n    collideRect(other)\r\n    {\r\n        let r1 = this;\r\n        let r2 = other;\r\n        return !(r2.left >= r1.right ||\r\n                r2.right <= r1.left ||\r\n                r2.top >= r1.bottom ||\r\n                r2.bottom <= r1.top);\r\n    }\r\n  \r\n    /**\r\n     * Check if this rectangle collides with a line.\r\n     * @param {Line} line Line to check collision with.\r\n     * @return {Boolean} if rectangle collides with line.\r\n     */\r\n    collideLine(line)\r\n    {\r\n        // first check if rectangle contains any of the line points\r\n        if (this.containsVector(line.from) || this.containsVector(line.to)) {\r\n            return true;\r\n        }\r\n\r\n        // now check intersection with the rectangle lines\r\n        let topLeft = this.getTopLeft();\r\n        let topRight = this.getTopRight();\r\n        let bottomLeft = this.getBottomLeft();\r\n        let bottomRight = this.getBottomRight();\r\n        if (line.collideLine(new Line(topLeft, topRight))) {\r\n            return true;\r\n        }\r\n        if (line.collideLine(new Line(topLeft, bottomLeft))) {\r\n            return true;\r\n        }\r\n        if (line.collideLine(new Line(topRight, bottomRight))) {\r\n            return true;\r\n        }\r\n        if (line.collideLine(new Line(bottomLeft, bottomRight))) {\r\n            return true;\r\n        }\r\n\r\n        // no collision\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if this rectangle collides with a circle.\r\n     * @param {Circle} circle Circle to check collision with.\r\n     * @return {Boolean} if rectangle collides with circle.\r\n     */\r\n    collideCircle(circle) \r\n    {\r\n        // get center and radius\r\n        let center = circle.center;\r\n        let radius = circle.radius;\r\n\r\n        // first check if circle center is inside the rectangle - easy case\r\n        let rect = this;\r\n        if (rect.containsVector(center)) {\r\n            return true;\r\n        }\r\n\r\n        // get rectangle center\r\n        let rectCenter = rect.getCenter();\r\n\r\n        // get corners\r\n        let topLeft = rect.getTopLeft();\r\n        let topRight = rect.getTopRight();\r\n        let bottomRight = rect.getBottomRight();\r\n        let bottomLeft = rect.getBottomLeft();\r\n\r\n        // create a list of lines to check (in the rectangle) based on circle position to rect center\r\n        let lines = [];\r\n        if (rectCenter.x > center.x) {\r\n            lines.push([topLeft, bottomLeft]);\r\n        } else {\r\n            lines.push([topRight, bottomRight]);\r\n        }\r\n        if (rectCenter.y > center.y) {\r\n            lines.push([topLeft, topRight]);\r\n        } else {\r\n            lines.push([bottomLeft, bottomRight]);\r\n        }\r\n\r\n        // now check intersection between circle and each of the rectangle lines\r\n        for (let i = 0; i < lines.length; ++i) {\r\n            let disToLine = pointLineDistance(center, lines[i][0], lines[i][1]);\r\n            if (disToLine <= radius) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // no collision..\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the smallest circle containing this rectangle.\r\n     * @returns {Circle} Bounding circle.\r\n     */\r\n    getBoundingCircle()\r\n    {\r\n        let center = this.getCenter();\r\n        let radius = center.distanceTo(this.getTopLeft());\r\n        return new Circle(center, radius);\r\n    }\r\n    \r\n    /**\r\n     * Build and return a rectangle from points.\r\n     * @param {Array<Vector2>} points Points to build rectangle from.\r\n     * @returns {Rectangle} new rectangle from points.\r\n     */\r\n    static fromPoints(points)\r\n    {\r\n        let min_x = points[0].x;\r\n        let min_y = points[0].y;\r\n        let max_x = min_x;\r\n        let max_y = min_y;\r\n\r\n        for (let i = 1; i < points.length; ++i) {\r\n            min_x = Math.min(min_x, points[i].x);\r\n            min_y = Math.min(min_y, points[i].y);\r\n            max_x = Math.max(max_x, points[i].x);\r\n            max_y = Math.max(max_y, points[i].y);\r\n        }\r\n\r\n        return new Rectangle(min_x, min_y, max_x - min_x, max_y - min_y);\r\n    }\r\n\r\n    /**\r\n     * Return a resized rectangle with the same center point.\r\n     * @param {Number|Vector2} amount Amount to resize.\r\n     * @returns {Rectangle} resized rectangle.\r\n     */\r\n    resize(amount)\r\n    {\r\n        if (typeof amount === 'number') {\r\n            amount = new Vector2(amount, amount);\r\n        }\r\n        return new Rectangle(this.x - amount.x / 2, this.y - amount.y / 2, this.width + amount.x, this.height + amount.y);\r\n    }\r\n\r\n    /**\r\n     * Check if equal to another rectangle.\r\n     * @param {Rectangle} other Other rectangle to compare to.\r\n     */\r\n    equals(other)\r\n    {\r\n        return (this === other) || \r\n                (other && (other.constructor === this.constructor) && this.x == other.x && this.y == other.y && this.width == other.width && this.height == other.height);\r\n    }\r\n\r\n    /**\r\n     * Lerp between two rectangles.\r\n     * @param {Rectangle} p1 First rectangles.\r\n     * @param {Rectangle} p2 Second rectangles.\r\n     * @param {Number} a Lerp factor (0.0 - 1.0).\r\n     * @returns {Rectangle} result rectangle.\r\n     */\r\n    static lerp(p1, p2, a)\r\n    {\r\n        let lerpScalar = MathHelper.lerp;\r\n        return new Rectangle(  lerpScalar(p1.x, p2.x, a), \r\n                            lerpScalar(p1.y, p2.y, a), \r\n                            lerpScalar(p1.width, p2.width, a), \r\n                            lerpScalar(p1.height, p2.height, a)\r\n                        );\r\n    }\r\n\r\n    /**\r\n     * Create rectangle from a dictionary.\r\n     * @param {*} data Dictionary with {x,y,width,height}.\r\n     * @returns {Rectangle} Newly created rectangle.\r\n     */\r\n    static fromDict(data)\r\n    {\r\n        return new Rectangle(data.x, data.y, data.width, data.height);\r\n    }\r\n\r\n    /**\r\n     * Convert to dictionary.\r\n     * @returns {*} Dictionary with {x,y,width,height}\r\n     */\r\n    toDict()\r\n    {\r\n        return {x: this.x, y: this.y, width: this.width, height: this.height};\r\n    }\r\n}\r\n\r\n/**\r\n * Get distance between a point and a line.\r\n * @private\r\n */\r\nfunction pointLineDistance(p1, l1, l2) {\r\n\r\n    let x = p1.x;\r\n    let y = p1.y;\r\n    let x1 = l1.x;\r\n    let y1 = l1.y;\r\n    let x2 = l2.x;\r\n    let y2 = l2.y;\r\n\r\n    var A = x - x1;\r\n    var B = y - y1;\r\n    var C = x2 - x1;\r\n    var D = y2 - y1;\r\n  \r\n    var dot = A * C + B * D;\r\n    var len_sq = C * C + D * D;\r\n    var param = -1;\r\n    if (len_sq != 0) //in case of 0 length line\r\n        param = dot / len_sq;\r\n  \r\n    var xx, yy;\r\n  \r\n    if (param < 0) {\r\n      xx = x1;\r\n      yy = y1;\r\n    }\r\n    else if (param > 1) {\r\n      xx = x2;\r\n      yy = y2;\r\n    }\r\n    else {\r\n      xx = x1 + param * C;\r\n      yy = y1 + param * D;\r\n    }\r\n  \r\n    var dx = x - xx;\r\n    var dy = y - yy;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n\r\n// export the rectangle class\r\nmodule.exports = Rectangle;", "/**\r\n * Assets base class.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\assets\\asset.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n\r\n/**\r\n * A loadable asset base class.\r\n * All asset types inherit from this.\r\n */\r\nclass Asset\r\n{\r\n    /**\r\n     * Create the new asset.\r\n     * @param {String} url Asset URL / identifier.\r\n     */\r\n    constructor(url)\r\n    {\r\n        this._url = url;\r\n        this._waitingCallbacks = [];\r\n    }\r\n\r\n    /**\r\n     * Register a method to be called when asset is ready.\r\n     * If asset is already in ready state, will invoke immediately.\r\n     * @param {Function} callback Callback to invoke when asset is ready.\r\n     */\r\n    onReady(callback)\r\n    {\r\n        if (this.valid || this._waitingCallbacks === null) {\r\n            callback(this);\r\n            return;\r\n        }\r\n        this._waitingCallbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Return a promise to resolve when ready.\r\n     * @returns {Promise} Promise to resolve when ready.\r\n     */\r\n    waitForReady()\r\n    {\r\n        return new Promise((resolve, reject) => {\r\n            this.onReady(resolve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Notify all waiting callbacks that this asset is ready.\r\n     * @private\r\n     */\r\n    _notifyReady()\r\n    {\r\n        if (this._waitingCallbacks) {\r\n            for (let i = 0; i < this._waitingCallbacks.length; ++i) {\r\n                this._waitingCallbacks[i](this);\r\n            }\r\n            this._waitingCallbacks = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get asset's URL.\r\n     * @returns {String} Asset URL.\r\n     */\r\n    get url()\r\n    {\r\n        return this._url;\r\n    }\r\n\r\n    /**\r\n     * Get if this asset is loaded and valid.\r\n     * @returns {Boolean} True if asset is loaded and valid, false otherwise.\r\n     */\r\n    get valid()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Load the asset from it's URL.\r\n     * @param {*} params Optional additional params.\r\n     * @returns {Promise} Promise to resolve when fully loaded.\r\n     */\r\n    load(params)\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Create the asset from data source.\r\n     * @param {*} source Data to create asset from.\r\n     * @param {*} params Optional additional params.\r\n     * @returns {Promise} Promise to resolve when asset is ready.\r\n     */\r\n    create(source)\r\n    {\r\n        throw new Error(\"Not Supported for this asset type.\");\r\n    }\r\n\r\n    /**\r\n     * Destroy the asset, freeing any allocated resources in the process.\r\n     */\r\n    destroy()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n}\r\n\r\n\r\n// export the asset base class.\r\nmodule.exports = Asset;", "/**\r\n * Define possible texture filter modes.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\texture_filter_modes.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict'; \r\n\r\n/**\r\n * Texture filter modes, determine how to scale textures.\r\n */\r\nconst TextureFilterModes = {\r\n    Nearest: \"NEAREST\",\r\n    Linear: \"LINEAR\",\r\n    NearestMipmapNearest: \"NEAREST_MIPMAP_NEAREST\",\r\n    LinearMipmapNearest: \"LINEAR_MIPMAP_NEAREST\",\r\n    NearestMipmapLinear: \"NEAREST_MIPMAP_LINEAR\",\r\n    LinearMipmapLinear: \"LINEAR_MIPMAP_LINEAR\",\r\n};\r\n\r\nObject.defineProperty(TextureFilterModes, '_values', {\r\n    value: new Set(Object.values(TextureFilterModes)),\r\n    writable: false,\r\n});\r\n\r\nObject.freeze(TextureFilterModes);\r\nmodule.exports = TextureFilterModes;\r\n", "/**\r\n * Define possible texture wrap modes.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\texture_wrap_modes.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n/**\r\n * Texture wrap modes, determine what to do when texture coordinates are outside texture boundaries.\r\n */\r\nconst TextureWrapModes = {\r\n    Clamp: \"CLAMP_TO_EDGE\",\r\n    Repeat: \"REPEAT\",\r\n    RepeatMirrored: \"MIRRORED_REPEAT\",\r\n};\r\n\r\nObject.defineProperty(TextureWrapModes, '_values', {\r\n    value: new Set(Object.values(TextureWrapModes)),\r\n    writable: false,\r\n});\r\n\r\nObject.freeze(TextureWrapModes);\r\nmodule.exports = TextureWrapModes;", "/**\r\n * Implement basic logger.\r\n * By default, uses console for logging, but it can be replaced with setDrivers().\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\logger.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n// default logger drivers.\r\nvar _drivers = console;\r\n\r\n// application name\r\nvar _application = \"Shaku\";\r\n\r\n/**\r\n * A logger manager.\r\n * By default writes logs to console.\r\n */\r\nclass Logger\r\n{\r\n    constructor(name)\r\n    {\r\n        this._nameHeader = '[' + _application + '][' + name + ']';\r\n        this._throwErrors = false;\r\n    }\r\n\r\n    /**\r\n     * Write a trace level log message.\r\n     * @param {String} msg Message to write.\r\n     */\r\n    trace(msg)\r\n    {\r\n        _drivers.trace(this._nameHeader, msg);\r\n    }\r\n\r\n    /**\r\n     * Write a debug level log message.\r\n     * @param {String} msg Message to write.\r\n     */\r\n    debug(msg)\r\n    {\r\n        _drivers.debug(this._nameHeader, msg);\r\n    }\r\n\r\n    /**\r\n     * Write an info level log message.\r\n     * @param {String} msg Message to write.\r\n     */\r\n    info(msg)\r\n    {\r\n        _drivers.info(this._nameHeader, msg);\r\n    }\r\n\r\n    /**\r\n     * Write a warning level log message.\r\n     * @param {String} msg Message to write.\r\n     */\r\n    warn(msg)\r\n    {\r\n        _drivers.warn(this._nameHeader, msg);\r\n        if (this._throwErrors) {\r\n            throw new Error(msg);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write an error level log message.\r\n     * @param {String} msg Message to write.\r\n     */\r\n    error(msg)\r\n    {\r\n        _drivers.error(this._nameHeader, msg);\r\n        if (this._throwErrors) {\r\n            throw new Error(msg);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set logger to throw an error every time a log message with severity higher than warning is written.\r\n     * @param {Boolean} enable Set to true to throw error on warnings.\r\n     */\r\n    throwErrorOnWarnings(enable)\r\n    {\r\n        this._throwErrors = Boolean(enable);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Null logger drivers to silent logs.\r\n * @private\r\n */\r\nclass NullDrivers\r\n{\r\n    /**\r\n     * @private\r\n     */\r\n    constructor()\r\n    {\r\n    }\r\n    trace(msg)\r\n    {\r\n    }\r\n    debug(msg)\r\n    {\r\n    }\r\n    info(msg)\r\n    {\r\n    }\r\n    warn(msg)\r\n    {\r\n    }\r\n    error(msg)\r\n    {\r\n    }\r\n}\r\n\r\n// export the seeded random class.\r\nmodule.exports = {\r\n\r\n    /**\r\n     * Get a logger object.\r\n     * @param {String} name Logger name.\r\n     */\r\n    getLogger: function(name) {\r\n        return new Logger(name);\r\n    },\r\n\r\n    /**\r\n     * Silent the logger.\r\n     */\r\n    silent: function() {\r\n        _drivers = new NullDrivers();\r\n    },\r\n\r\n    /**\r\n     * Set log drivers that implement trace, debug, info, warn and error that all loggers will use.\r\n     */\r\n    setDrivers: function(drivers)\r\n    {\r\n        _drivers = drivers;\r\n    },\r\n\r\n    /**\r\n     * Set logger application name.\r\n     * @param {String} name Set application name to replace the 'Shaku' in the headers.\r\n     */\r\n    setApplicationName: function(name)\r\n    {\r\n        _application = name;\r\n        return this;\r\n    }\r\n};", "/**\r\n * Implement texture asset type.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\assets\\texture_asset.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Asset = require(\"./asset\");\r\nconst TextureFilterModes = require('../gfx/texture_filter_modes');\r\nconst TextureWrapModes = require('../gfx/texture_wrap_modes');\r\nconst Color = require('../utils/color');\r\nconst Vector2 = require(\"../utils/vector2\");\r\nconst _logger = require('../logger.js').getLogger('assets');\r\n\r\n// the webgl context to use\r\nvar gl = null;\r\n\r\n\r\n/**\r\n * A loadable texture asset.\r\n * This asset type loads an image from URL or source, and turn it into a texture.\r\n */\r\nclass TextureAsset extends Asset\r\n{\r\n    /** @inheritdoc */\r\n    constructor(url)\r\n    {\r\n        super(url);\r\n        this._image = null;\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this._texture = null;\r\n        this._filter = null;\r\n        this._wrapMode = null;\r\n        this._ctxForPixelData = null;\r\n    }\r\n\r\n    /**\r\n     * Set the WebGL context.\r\n     * @private\r\n     */\r\n    static _setWebGl(_gl)\r\n    {\r\n        gl = _gl;\r\n    }\r\n\r\n    /**\r\n     * Get texture magnifying filter, or null to use default.\r\n     * @see Shaku.gfx.TextureFilterModes\r\n     */\r\n    get filter()\r\n    {\r\n        return this._filter;\r\n    }\r\n\r\n    /**\r\n     * Set texture magnifying filter.\r\n     * @see Shaku.gfx.TextureFilterModes \r\n     * @param {TextureFilterModes} value Filter mode to use or null to use default.\r\n     */\r\n    set filter(value)\r\n    {\r\n        this._filter = value;\r\n    }\r\n\r\n    /**\r\n     * Get texture wrapping mode, or null to use default.\r\n     * @see Shaku.gfx.TextureWrapModes\r\n     */\r\n    get wrapMode()\r\n    {\r\n        return this._wrapMode;\r\n    }\r\n\r\n    /**\r\n     * Set texture wrapping mode.\r\n     * @see Shaku.gfx.TextureWrapModes\r\n     * @param {TextureWrapModes} value Wrapping mode to use or null to use default.\r\n     */\r\n    set wrapMode(value)\r\n    {\r\n        this._wrapMode = value;\r\n    }\r\n    \r\n    /**\r\n     * Load the texture from it's image URL.\r\n     * @param {*} params Optional additional params. Possible values are:\r\n     *                      - generateMipMaps (default=false): should we generate mipmaps for this texture?\r\n     *                      - crossOrigin (default=undefined): if set, will set the crossOrigin property with this value.\r\n     * @returns {Promise} Promise to resolve when fully loaded.\r\n     */\r\n    load(params)\r\n    {\r\n        // default params\r\n        params = params || {};\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (!gl) {\r\n                return reject(\"Can't load textures before initializing gfx manager!\");\r\n            }\r\n\r\n            // create image to load\r\n            const image = new Image();\r\n            if (params.crossOrigin !== undefined) {\r\n                image.crossOrigin = params.crossOrigin;\r\n            }\r\n            image.onload = async () =>\r\n            {\r\n                try {\r\n                    await this.create(image, params);\r\n                    this._notifyReady();\r\n                    resolve();\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            };\r\n            image.onerror = () => {\r\n                reject(\"Failed to load texture image!\");\r\n            }\r\n\r\n            // initiate image load\r\n            image.src = this.url;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create this texture as an empty render target.\r\n     * @param {Number} width Texture width.\r\n     * @param {Number} height Texture height.\r\n     * @param {Number} channels Texture channels count. Defaults to 4 (RGBA).\r\n     */\r\n    createRenderTarget(width, height, channels)\r\n    {\r\n        // create to render to\r\n        const targetTextureWidth = width;\r\n        const targetTextureHeight = height;\r\n        const targetTexture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, targetTexture);\r\n        \r\n        // calculate format\r\n        var _format = gl.RGBA;\r\n        if (channels !== undefined) {\r\n            switch (channels) {\r\n                case 1:\r\n                    _format = gl.LUMINANCE;\r\n                    break;\r\n                case 3:\r\n                    _format = gl.RGB;\r\n                    break;\r\n                case 4:\r\n                    _format = gl.RGBA;\r\n                    break;\r\n                default:\r\n                    throw new Error(\"Unknown render target format!\");\r\n            }\r\n        }\r\n\r\n        {\r\n            // create texture\r\n            const level = 0;\r\n            const internalFormat = _format;\r\n            const border = 0;\r\n            const format = _format;\r\n            const type = gl.UNSIGNED_BYTE;\r\n            const data = null;\r\n            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,\r\n                            targetTextureWidth, targetTextureHeight, border,\r\n                            format, type, data);\r\n            \r\n            // set default wrap and filter modes\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        }\r\n\r\n        // store texture\r\n        this._width = width;\r\n        this._height = height;\r\n        this._texture = targetTexture;\r\n        this._notifyReady();\r\n    }\r\n\r\n    /**\r\n     * Create texture from loaded image instance.\r\n     * @see TextureAsset.load for params.\r\n     * @param {Image} image Image to create texture from. Image must be loaded!\r\n     * @param {*} params Optional additional params. See load() for details.\r\n     */\r\n    fromImage(image, params)\r\n    {\r\n        if (image.width === 0) { \r\n            throw new Error(\"Image to build texture from must be loaded and have valid size!\");\r\n        }\r\n\r\n        if (this.valid) {\r\n            throw new Error(\"Texture asset is already initialized!\");\r\n        }\r\n        \r\n        // default params\r\n        params = params || {};\r\n\r\n        // store image\r\n        this._image = image;\r\n        this._width = image.width;\r\n        this._height = image.height;\r\n\r\n        // create texture\r\n        const texture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n        // set texture\r\n        const level = 0;\r\n        const internalFormat = gl.RGBA;\r\n        const srcFormat = gl.RGBA;\r\n        const srcType = gl.UNSIGNED_BYTE;\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image);\r\n\r\n        // WebGL1 has different requirements for power of 2 images\r\n        // vs non power of 2 images so check if the image is a\r\n        // power of 2 in both dimensions.\r\n        if (params.generateMipMaps) {\r\n            if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\r\n                _logger.warn(\"Tried to generate MipMaps for a texture with size that is *not* a power of two. This might not work as expected.\");\r\n            } \r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n\r\n        // default wrap and filters\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n\r\n        // success!\r\n        this._texture = texture;\r\n        this._notifyReady();\r\n    }\r\n\r\n    /**\r\n     * Create the texture from an image.\r\n     * @see TextureAsset.load for params.\r\n     * @param {Image|String} source Image or Image source URL to create texture from.\r\n     * @param {*} params Optional additional params. See load() for details.\r\n     * @returns {Promise} Promise to resolve when asset is ready.\r\n     */\r\n    create(source, params)\r\n    {\r\n        return new Promise(async (resolve, reject) => {\r\n\r\n            if (typeof source === \"string\") {\r\n                let img = new Image();\r\n                img.onload = () => {\r\n                    this.fromImage(source, params);\r\n                    this._notifyReady();\r\n                    resolve();\r\n                }\r\n                if (params.crossOrigin !== undefined) {\r\n                    img.crossOrigin = params.crossOrigin;\r\n                }\r\n                img.src = source;\r\n            }\r\n            else {\r\n                this.fromImage(source, params);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get raw image.\r\n     * @returns {Image} Image instance.\r\n     */\r\n    get image()\r\n    {\r\n        return this._image;\r\n    }\r\n\r\n    /**\r\n     * Get texture width.\r\n     * @returns {Number} Texture width.\r\n     */\r\n    get width()\r\n    {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * Get texture height.\r\n     * @returns {Number} Texture height.\r\n     */\r\n    get height()\r\n    {\r\n        return this._height;\r\n    }\r\n\r\n    /**\r\n     * Get texture size as a vector.\r\n     * @returns {Vector2} Texture size.\r\n     */\r\n    get size()\r\n    {\r\n        return new Vector2(this.width, this.height);\r\n    }\r\n\r\n    /**\r\n     * Get texture instance for WebGL.\r\n     */\r\n    get texture()\r\n    {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Get pixel color from image.\r\n     * @param {Number} x Pixel X value.\r\n     * @param {Number} y Pixel Y value.\r\n     * @returns {Color} Pixel color.\r\n     */\r\n    getPixel(x, y) \r\n    {\r\n        if (!this._image) { \r\n            throw new Error(\"'getPixel()' only works on textures loaded from image!\");\r\n        }\r\n\r\n        // build internal canvas and context to get pixel data\r\n        if (!this._ctxForPixelData) {\r\n            let canvas = document.createElement('canvas');\r\n            canvas.width = 1;\r\n            canvas.height = 1;\r\n            this._ctxForPixelData = canvas.getContext('2d');\r\n        }\r\n\r\n        // get pixel data\r\n        let ctx = this._ctxForPixelData;\r\n        ctx.drawImage(this._image, x, y, 1, 1, 0, 0, 1, 1);\r\n        let pixelData = ctx.getImageData(0, 0, 1, 1).data;   \r\n        return Color.fromBytesArray(pixelData);\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    get valid()\r\n    {\r\n        return Boolean(this._texture);\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    destroy()\r\n    {\r\n        gl.deleteTexture(this._texture);\r\n        this._image = null;\r\n        this._width = this._height = 0;\r\n        this._ctxForPixelData = null;\r\n        this._texture = null;\r\n    }\r\n}\r\n\r\n// check if value is a power of 2\r\nfunction isPowerOf2(value) {\r\n    return (value & (value - 1)) == 0;\r\n}\r\n\r\n\r\n// export the asset type.\r\nmodule.exports = TextureAsset;", "/**\r\n * Matrix class.\r\n * Based on code from https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\matrix.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n\r\n /**\r\n  * Implements a matrix.\r\n  */\r\nclass Matrix\r\n{\r\n    /**\r\n     * Create the matrix.\r\n     * @param values matrix values array.\r\n     * @param cloneValues if true or undefined, will clone values instead of just holding a reference to them.\r\n     */\r\n    constructor(values, cloneValues)\r\n    {\r\n        if (cloneValues || cloneValues === undefined) {\r\n            this.values = values.slice(0);\r\n        }\r\n        else {\r\n            this.values = values;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the matrix values.\r\n     */\r\n     set(v11, v12, v13, v14, v21, v22, v23, v24, v31, v32, v33, v34, v41, v42, v43, v44)\r\n     {\r\n         this.values = new Float32Array([ v11, v12, v13, v14,\r\n                         v21, v22, v23, v24,\r\n                         v31, v32, v33, v34,\r\n                         v41, v42, v43, v44\r\n                     ]);\r\n     }\r\n\r\n    /**\r\n     * Clone the matrix.\r\n     * @returns {Matrix} Cloned matrix.\r\n     */\r\n    clone()\r\n    {\r\n        let ret = new Matrix(this.values, true);\r\n        return ret;\r\n    }\r\n    \r\n    /**\r\n     * Compare this matrix to another matrix.\r\n     * @param {Matrix} other Matrix to compare to.\r\n     * @returns {Boolean} If matrices are the same.\r\n     */\r\n    equals(other)\r\n    {\r\n        if (other === this) { return true; }\r\n        if (!other) { return false; }\r\n        for (let i = 0; i < this.values.length; ++i) {\r\n            if (this.values[i] !== other.values[i]) { return false; }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Create an orthographic projection matrix.\r\n     * @returns {Matrix} a new matrix with result.\r\n     */\r\n    static orthographic(left, right, bottom, top, near, far) \r\n    {\r\n        return new Matrix([\r\n          2 / (right - left), 0, 0, 0,\r\n          0, 2 / (top - bottom), 0, 0,\r\n          0, 0, 2 / (near - far), 0,\r\n     \r\n          (left + right) / (left - right),\r\n          (bottom + top) / (bottom - top),\r\n          (near + far) / (near - far),\r\n          1,\r\n        ], false);\r\n    }\r\n\r\n    /**\r\n     * Create a perspective projection matrix.\r\n     * @returns {Matrix} a new matrix with result.\r\n     */\r\n    static perspective(fieldOfViewInRadians, aspectRatio, near, far) \r\n    {\r\n        var f = 1.0 / Math.tan(fieldOfViewInRadians / 2);\r\n        var rangeInv = 1 / (near - far);\r\n      \r\n        return new Matrix([\r\n          f / aspectRatio, 0,                          0,   0,\r\n          0,               f,                          0,   0,\r\n          0,               0,    (near + far) * rangeInv,  -1,\r\n          0,               0,  near * far * rangeInv * 2,   0\r\n        ], false);\r\n    }\r\n\r\n    /**\r\n     * Create a translation matrix.\r\n     * @returns {Matrix} a new matrix with result.\r\n     */\r\n    static translate(x, y, z)\r\n    {\r\n        return new Matrix([\r\n            1,          0,          0,          0,\r\n            0,          1,          0,          0,\r\n            0,          0,          1,          0,\r\n            x || 0,     y || 0,     z || 0,     1\r\n        ], false);\r\n    }\r\n\r\n    /**\r\n     * Create a scale matrix.\r\n     * @returns {Matrix} a new matrix with result.\r\n     */\r\n    static scale(x, y, z)\r\n    {\r\n        return new Matrix([\r\n            x || 1,         0,              0,              0,\r\n            0,              y || 1,         0,              0,\r\n            0,              0,              z || 1,         0,\r\n            0,              0,              0,              1\r\n        ], false);\r\n    }\r\n    \r\n    /**\r\n     * Create a rotation matrix around X axis.\r\n     * @returns {Matrix} a new matrix with result.\r\n     */\r\n    static rotateX(a)\r\n    {\r\n        let sin = Math.sin;\r\n        let cos = Math.cos;\r\n        return new Matrix([\r\n            1,       0,        0,     0,\r\n            0,  cos(a),  -sin(a),     0,\r\n            0,  sin(a),   cos(a),     0,\r\n            0,       0,        0,     1\r\n        ], false);\r\n    }\r\n        \r\n    /**\r\n     * Create a rotation matrix around Y axis.\r\n     * @returns {Matrix} a new matrix with result.\r\n     */\r\n    static rotateY(a)\r\n    {\r\n        let sin = Math.sin;\r\n        let cos = Math.cos;\r\n        return new Matrix([\r\n             cos(a),   0, sin(a),   0,\r\n                  0,   1,      0,   0,\r\n            -sin(a),   0, cos(a),   0,\r\n                  0,   0,      0,   1\r\n        ], false);\r\n    }\r\n        \r\n    /**\r\n     * Create a rotation matrix around Z axis.\r\n     * @returns {Matrix} a new matrix with result.\r\n     */\r\n    static rotateZ(a)\r\n    {\r\n        let sin = Math.sin;\r\n        let cos = Math.cos;\r\n        return new Matrix([\r\n            cos(a), -sin(a),    0,    0,\r\n            sin(a),  cos(a),    0,    0,\r\n                0,       0,    1,    0,\r\n                0,       0,    0,    1\r\n        ], false);\r\n    }\r\n    \r\n    /**\r\n     * Multiply two matrices. \r\n     * @returns {Matrix} a new matrix with result.\r\n     */\r\n    static multiply(matrixA, matrixB) \r\n    {\r\n        // Slice the second matrix up into rows\r\n        let row0 = [matrixB.values[ 0], matrixB.values[ 1], matrixB.values[ 2], matrixB.values[ 3]];\r\n        let row1 = [matrixB.values[ 4], matrixB.values[ 5], matrixB.values[ 6], matrixB.values[ 7]];\r\n        let row2 = [matrixB.values[ 8], matrixB.values[ 9], matrixB.values[10], matrixB.values[11]];\r\n        let row3 = [matrixB.values[12], matrixB.values[13], matrixB.values[14], matrixB.values[15]];\r\n      \r\n        // Multiply each row by matrixA\r\n        let result0 = multiplyMatrixAndPoint(matrixA.values, row0);\r\n        let result1 = multiplyMatrixAndPoint(matrixA.values, row1);\r\n        let result2 = multiplyMatrixAndPoint(matrixA.values, row2);\r\n        let result3 = multiplyMatrixAndPoint(matrixA.values, row3);\r\n      \r\n        // Turn the result rows back into a single matrix\r\n        return new Matrix([\r\n          result0[0], result0[1], result0[2], result0[3],\r\n          result1[0], result1[1], result1[2], result1[3],\r\n          result2[0], result2[1], result2[2], result2[3],\r\n          result3[0], result3[1], result3[2], result3[3]\r\n        ], false);\r\n    }\r\n\r\n    /**\r\n     * Multiply an array of matrices.\r\n     * @param {Array<Matrix>} matrices Matrices to multiply.\r\n     * @returns {Matrix} new matrix with multiply result.\r\n     */\r\n    static multiplyMany(matrices)\r\n    {\r\n        let ret = matrices[0];\r\n        for(let i = 1; i < matrices.length; i++) {\r\n            ret = Matrix.multiply(ret, matrices[i]);\r\n        }        \r\n        return ret;\r\n    }\r\n        \r\n    /**\r\n     * Multiply two matrices and put result in first matrix. \r\n     * @returns {Matrix} matrixA, after it was modified.\r\n     */\r\n    static multiplyIntoFirst(matrixA, matrixB) \r\n    {\r\n        // Slice the second matrix up into rows\r\n        let row0 = [matrixB.values[ 0], matrixB.values[ 1], matrixB.values[ 2], matrixB.values[ 3]];\r\n        let row1 = [matrixB.values[ 4], matrixB.values[ 5], matrixB.values[ 6], matrixB.values[ 7]];\r\n        let row2 = [matrixB.values[ 8], matrixB.values[ 9], matrixB.values[10], matrixB.values[11]];\r\n        let row3 = [matrixB.values[12], matrixB.values[13], matrixB.values[14], matrixB.values[15]];\r\n    \r\n        // Multiply each row by matrixA\r\n        let result0 = multiplyMatrixAndPoint(matrixA.values, row0);\r\n        let result1 = multiplyMatrixAndPoint(matrixA.values, row1);\r\n        let result2 = multiplyMatrixAndPoint(matrixA.values, row2);\r\n        let result3 = multiplyMatrixAndPoint(matrixA.values, row3);\r\n    \r\n        // Turn the result rows back into a single matrix\r\n        matrixA.set(\r\n            result0[0], result0[1], result0[2], result0[3],\r\n            result1[0], result1[1], result1[2], result1[3],\r\n            result2[0], result2[1], result2[2], result2[3],\r\n            result3[0], result3[1], result3[2], result3[3]\r\n        );\r\n\r\n        // return the first matrix after it was modified\r\n        return matrixA;\r\n    }\r\n\r\n    /**\r\n     * Multiply an array of matrices into the first matrix in the array.\r\n     * @param {Array<Matrix>} matrices Matrices to multiply.\r\n     * @returns {Matrix} first matrix in array, after it was modified.\r\n     */\r\n     static multiplyManyIntoFirst(matrices)\r\n     {\r\n         let ret = matrices[0];\r\n         for(let i = 1; i < matrices.length; i++) {\r\n             ret = Matrix.multiplyIntoFirst(ret, matrices[i]);\r\n         }        \r\n         return ret;\r\n     }\r\n}\r\n\r\n\r\n/**\r\n * Multiply matrix and vector.\r\n * @private\r\n */\r\nfunction multiplyMatrixAndPoint(matrix, point) \r\n{\r\n    // Give a simple variable name to each part of the matrix, a column and row number\r\n    let c0r0 = matrix[ 0], c1r0 = matrix[ 1], c2r0 = matrix[ 2], c3r0 = matrix[ 3];\r\n    let c0r1 = matrix[ 4], c1r1 = matrix[ 5], c2r1 = matrix[ 6], c3r1 = matrix[ 7];\r\n    let c0r2 = matrix[ 8], c1r2 = matrix[ 9], c2r2 = matrix[10], c3r2 = matrix[11];\r\n    let c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15];\r\n\r\n    // Now set some simple names for the point\r\n    let x = point[0];\r\n    let y = point[1];\r\n    let z = point[2];\r\n    let w = point[3];\r\n\r\n    // Multiply the point against each part of the 1st column, then add together\r\n    let resultX = (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3);\r\n\r\n    // Multiply the point against each part of the 2nd column, then add together\r\n    let resultY = (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3);\r\n\r\n    // Multiply the point against each part of the 3rd column, then add together\r\n    let resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3);\r\n\r\n    // Multiply the point against each part of the 4th column, then add together\r\n    let resultW = (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3);\r\n\r\n    return [resultX, resultY, resultZ, resultW];\r\n}\r\n\r\n\r\n/**\r\n * An identity matrix.\r\n */\r\nMatrix.identity = new Matrix([\r\n    1, 0, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 0, 1\r\n], false);\r\nObject.freeze(Matrix.identity);\r\n\r\n// export the matrix object\r\nmodule.exports = Matrix;", "/**\r\n * Effect base class.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\effects\\effect.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\nconst TextureAsset = require('../../assets/texture_asset.js');\r\nconst Color = require('../../utils/color.js');\r\nconst Rectangle = require('../../utils/rectangle.js');\r\nconst TextureFilterModes = require('../texture_filter_modes');\r\nconst TextureWrapModes = require('../texture_wrap_modes');\r\nconst Matrix = require('../matrix.js');\r\nconst _logger = require('../../logger.js').getLogger('gfx-effect');\r\n\r\n\r\n/**\r\n * Effect base class.\r\n * An effect = vertex shader + fragment shader + uniforms & attributes + setup code.\r\n */\r\nclass Effect\r\n{\r\n    /**\r\n     * Build the effect.\r\n     * Called from gfx manager.\r\n     * @private\r\n     * @param {WebGl} gl WebGL context.\r\n     */\r\n    _build(gl)\r\n    {\r\n        // create program\r\n        let program = gl.createProgram();\r\n\r\n        // build vertex shader\r\n        {\r\n            let shader = compileShader(gl, this.vertexCode, gl.VERTEX_SHADER);\r\n            gl.attachShader(program, shader);\r\n        }\r\n\r\n        // build fragment shader\r\n        {\r\n            let shader = compileShader(gl, this.fragmentCode, gl.FRAGMENT_SHADER);\r\n            gl.attachShader(program, shader);\r\n        }\r\n\r\n        // link program\r\n        gl.linkProgram(program)\r\n\r\n        // check for errors\r\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n            _logger.error(\"Error linking shader program:\");\r\n            _logger.error(gl.getProgramInfoLog(program));\r\n            throw new Error(\"Failed to link shader program.\");\r\n        }\r\n\r\n        // store program and gl\r\n        this._gl = gl;\r\n        this._program = program;\r\n\r\n        // a set of dynamically-created setters to set uniform values\r\n        this.uniforms = {};\r\n\r\n        // dictionary to bind uniform to built-in roles, like main texture or color\r\n        this._uniformBinds = {};\r\n\r\n        // initialize uniform setters\r\n        for (let uniform in this.uniformTypes) {\r\n\r\n            // get uniform location\r\n            let uniformLocation = this._gl.getUniformLocation(this._program, uniform);\r\n            if (uniformLocation === -1) { \r\n                _logger.error(\"Could not find uniform: \" + uniform);\r\n                throw new Error(`Uniform named '${uniform}' was not found in shader code!`); \r\n            }\r\n\r\n            // get gl setter method\r\n            let uniformData = this.uniformTypes[uniform];\r\n            if (!UniformTypes._values.has(uniformData.type)) { \r\n                _logger.error(\"Uniform has invalid type: \" + uniformData.type);\r\n                throw new Error(`Uniform '${uniform}' have illegal value type '${uniformData.type}'!`); \r\n            }\r\n\r\n            // build setter method for matrices\r\n            if (uniformData.type === UniformTypes.Matrix) {\r\n                (function(_this, name, location, method) {\r\n                    _this.uniforms[name] = (mat) => {\r\n                        _this._gl[method](location, false, mat);\r\n                    }\r\n                })(this, uniform, uniformLocation, uniformData.type);\r\n            }\r\n            // build setter method for textures\r\n            else if (uniformData.type === UniformTypes.Texture) {\r\n                (function(_this, name, location, method) {\r\n                    _this.uniforms[name] = (texture, index) => {\r\n                        index = index || 0;\r\n                        const glTexture = texture.texture || texture;\r\n                        const textureCode = _this._gl['TEXTURE' + (index || 0)];\r\n                        _this._gl.activeTexture(textureCode);\r\n                        _this._gl.bindTexture(_this._gl.TEXTURE_2D, glTexture);\r\n                        _this._gl.uniform1i(location, (index || 0));\r\n                        if (texture.filter) { _setTextureFilter(_this._gl, texture.filter); }\r\n                        if (texture.wrapMode) { _setTextureWrapMode(_this._gl, texture.wrapMode); }\r\n                    }\r\n                })(this, uniform, uniformLocation, uniformData.type);\r\n            }\r\n            // build setter method for other types\r\n            else {\r\n                (function(_this, name, location, method) {\r\n                    _this.uniforms[name] = (v1, v2, v3, v4) => {\r\n                        _this._gl[method](location, v1, v2, v3, v4);\r\n                    }\r\n                })(this, uniform, uniformLocation, uniformData.type);       \r\n            }\r\n\r\n            // set binding\r\n            let bindTo = uniformData.bind;\r\n            if (bindTo) {\r\n                this._uniformBinds[bindTo] = uniform;\r\n            }\r\n        }\r\n\r\n        // a set of dynamically-created setters to set attribute values\r\n        this.attributes = {};\r\n\r\n        // dictionary to bind attribute to built-in roles, like vertices positions or uvs\r\n        this._attributeBinds = {};\r\n\r\n        // get attribute locations\r\n        for (let attr in this.attributeTypes) {\r\n\r\n            // get attribute location\r\n            let attributeLocation = this._gl.getAttribLocation(this._program, attr);\r\n            if (attributeLocation === -1) { \r\n                _logger.error(\"Could not find attribute: \" + attr);\r\n                throw new Error(`Attribute named '${attr}' was not found in shader code!`); \r\n            }\r\n\r\n            // get attribute data\r\n            let attributeData = this.attributeTypes[attr];\r\n\r\n            // build setter method\r\n            (function(_this, name, location, data) {\r\n                _this.attributes[name] = (buffer) => {\r\n                    if (buffer) {\r\n                        _this._gl.bindBuffer(_this._gl.ARRAY_BUFFER, buffer);\r\n                        _this._gl.vertexAttribPointer(location, data.size, _this._gl[data.type] || _this._gl.FLOAT, data.normalize || false, data.stride || 0, data.offset || 0);\r\n                        _this._gl.enableVertexAttribArray(location);\r\n                    }\r\n                    else {\r\n                        _this._gl.disableVertexAttribArray(location);\r\n                    }\r\n                }\r\n            })(this, attr, attributeLocation, attributeData);\r\n      \r\n            // set binding\r\n            let bindTo = attributeData.bind;\r\n            if (bindTo) {\r\n                this._attributeBinds[bindTo] = attr;\r\n            }\r\n        }\r\n\r\n        // values we already set for this effect, so we won't set them again\r\n        this._cachedValues = {};\r\n    }\r\n\r\n    /**\r\n     * Get a dictionary with all shaders uniforms.\r\n     * Key = uniform name, as appears in shader code.\r\n     * Value = {\r\n     *              type: UniformTypes to represent uniform type,\r\n     *              bind: Optional bind to one of the built-in uniforms. See Effect.UniformBinds for details.\r\n     *         }\r\n     * @returns {*} Dictionary with uniforms descriptions.\r\n     */\r\n    get uniformTypes()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Get a dictionary with all shader attributes.\r\n     * Key = attribute name, as appears in shader code.\r\n     * Value = {\r\n     *             size: size of every value in this attribute.\r\n     *             type: attribute type. See Effect.AttributeTypes for details.\r\n     *             normalize: if true, will normalize values.\r\n     *             stride: optional stride. \r\n     *             offset: optional offset.\r\n     *             bind: Optional bind to one of the built-in attributes. See Effect.AttributeBinds for details.\r\n     *         }\r\n     * @returns {*} Dictionary with attributes descriptions.\r\n     */\r\n    get attributeTypes()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Make this effect active.\r\n     */\r\n    setAsActive()\r\n    {\r\n        // use effect program\r\n        this._gl.useProgram(this._program);\r\n\r\n        // enable / disable some features\r\n        if (this.enableDepthTest) { this._gl.enable(this._gl.DEPTH_TEST); } else { this._gl.disable(this._gl.DEPTH_TEST); }\r\n        if (this.enableFaceCulling) { this._gl.enable(this._gl.CULL_FACE); } else { this._gl.disable(this._gl.CULL_FACE); }\r\n        if (this.enableStencilTest) { this._gl.enable(this._gl.STENCIL_TEST); } else { this._gl.disable(this._gl.STENCIL_TEST); }\r\n        if (this.enableDithering) { this._gl.enable(this._gl.DITHER); } else { this._gl.disable(this._gl.DITHER); }\r\n\r\n        // reset cached values\r\n        this._cachedValues = {};\r\n    }\r\n\r\n    /**\r\n     * Prepare effect before drawing it with batching.\r\n     * @param {Mesh} mesh Mesh we're about to draw.\r\n     * @param {Matrix} world World matrix.\r\n     */\r\n    prepareToDrawBatch(mesh, world)\r\n    {\r\n        this._cachedValues = {};\r\n        this.setPositionsAttribute(mesh.positions);\r\n        this.setTextureCoordsAttribute(mesh.textureCoords);\r\n        this.setColorsAttribute(mesh.colors);\r\n        this.setWorldMatrix(world);\r\n    }\r\n\r\n    /**\r\n     * Get this effect's vertex shader code, as string.\r\n     * @returns {String} Vertex shader code. \r\n     */\r\n    get vertexCode()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Get this effect's fragment shader code, as string.\r\n     * @returns {String} Fragment shader code. \r\n     */\r\n    get fragmentCode()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Should this effect enable depth test?\r\n     */\r\n    get enableDepthTest()\r\n    {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Should this effect enable face culling?\r\n     */\r\n    get enableFaceCulling()\r\n    {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Should this effect enable stencil test?\r\n     */\r\n    get enableStencilTest()\r\n    {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Should this effect enable dithering?\r\n     */\r\n    get enableDithering()\r\n    {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set the main texture.\r\n     * Only works if there's a uniform type bound to 'MainTexture'.\r\n     * @param {TextureAsset} texture Texture to set.\r\n     * @returns {Boolean} True if texture was changed, false if there was no need to change the texture.\r\n     */\r\n    setTexture(texture)\r\n    {\r\n        let uniform = this._uniformBinds[Effect.UniformBinds.MainTexture];\r\n        if (uniform) {\r\n            if (texture === this._cachedValues.texture) { return false; }\r\n            this._cachedValues.texture = texture;\r\n            let glTexture = texture.texture || texture;\r\n            this._gl.activeTexture(this._gl.TEXTURE0);\r\n            this._gl.bindTexture(this._gl.TEXTURE_2D, glTexture);\r\n            this.uniforms[uniform](texture, 0);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set the main tint color.\r\n     * Only works if there's a uniform type bound to 'Color'.\r\n     * @param {Color} color Color to set.\r\n     */\r\n    setColor(color)\r\n    {\r\n        let uniform = this._uniformBinds[Effect.UniformBinds.Color];\r\n        if (uniform) {\r\n            if (color.equals(this._cachedValues.color)) { return; }\r\n            this._cachedValues.color = color.clone();\r\n            this.uniforms[uniform](color.floatArray);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set uvOffset and uvScale params from source rectangle and texture.\r\n     * @param {Rectangle} sourceRect Source rectangle to set, or null to take entire texture.\r\n     * @param {TextureAsset} texture Texture asset to set source rect for.\r\n     */\r\n    setUvOffsetAndScale(sourceRect, texture)\r\n    {\r\n        // skip if the same\r\n        if (sourceRect) {\r\n            if (sourceRect.equals(this._cachedValues.sourceRect)) { return; }\r\n        }\r\n        else {\r\n            if (this._cachedValues.sourceRect === null) { return; }\r\n        }\r\n        this._cachedValues.sourceRect = sourceRect ? sourceRect.clone() : null;\r\n\r\n        // default source rect\r\n        if (!sourceRect) { sourceRect = new Rectangle(0, 0, texture.width, texture.height); }\r\n\r\n        // set uv offset\r\n        let uvOffset = this._uniformBinds[Effect.UniformBinds.UvOffset];\r\n        if (uvOffset) {\r\n            this.uniforms[uvOffset](sourceRect.x / texture.width, sourceRect.y / texture.height);\r\n        }\r\n        \r\n        // set uv scale\r\n        let uvScale = this._uniformBinds[Effect.UniformBinds.UvScale];\r\n        if (uvScale) {\r\n            this.uniforms[uvScale](sourceRect.width / texture.width, sourceRect.height / texture.height);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the projection matrix uniform.\r\n     * @param {Matrix} matrix Matrix to set.\r\n     */\r\n    setProjectionMatrix(matrix)\r\n    {\r\n        let uniform = this._uniformBinds[Effect.UniformBinds.Projection];\r\n        if (uniform) {\r\n            if (matrix.equals(this._cachedValues.projection)) { return; }\r\n            this._cachedValues.projection = matrix.clone();\r\n            this.uniforms[uniform](matrix.values);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the world matrix uniform.\r\n     * @param {Matrix} matrix Matrix to set.\r\n     */\r\n    setWorldMatrix(matrix)\r\n    {\r\n        let uniform = this._uniformBinds[Effect.UniformBinds.World];\r\n        if (uniform) {\r\n            this.uniforms[uniform](matrix.values);\r\n        }\r\n    }\r\n     \r\n    /**\r\n     * Set the vertices position buffer.\r\n     * Only works if there's an attribute type bound to 'Position'.\r\n     * @param {WebGLBuffer} buffer Vertices position buffer.\r\n     */\r\n    setPositionsAttribute(buffer)\r\n    {\r\n        let attr = this._attributeBinds[Effect.AttributeBinds.Position];\r\n        if (attr) {\r\n            if (buffer === this._cachedValues.positions) { return; }\r\n            this._cachedValues.positions = buffer;\r\n            this.attributes[attr](buffer);\r\n        }\r\n    }\r\n     \r\n    /**\r\n     * Set the vertices texture coords buffer.\r\n     * Only works if there's an attribute type bound to 'TextureCoords'.\r\n     * @param {WebGLBuffer} buffer Vertices texture coords buffer.\r\n     */\r\n    setTextureCoordsAttribute(buffer)\r\n    {\r\n        let attr = this._attributeBinds[Effect.AttributeBinds.TextureCoords];\r\n        if (attr) {\r\n            if (buffer === this._cachedValues.coords) { return; }\r\n            this._cachedValues.coords = buffer;\r\n            this.attributes[attr](buffer);\r\n        }\r\n    }\r\n         \r\n    /**\r\n     * Set the vertices colors buffer.\r\n     * Only works if there's an attribute type bound to 'Colors'.\r\n     * @param {WebGLBuffer} buffer Vertices colors buffer.\r\n     */\r\n     setColorsAttribute(buffer)\r\n     {\r\n         let attr = this._attributeBinds[Effect.AttributeBinds.Colors];\r\n         if (attr) {\r\n            if (buffer === this._cachedValues.colors) { return; }\r\n            this._cachedValues.colors = buffer;\r\n            this.attributes[attr](buffer);\r\n         }\r\n     }\r\n}\r\n\r\n/**\r\n * Build a shader.\r\n */\r\nfunction compileShader(gl, code, type) \r\n{\r\n    let shader = gl.createShader(type);\r\n\r\n    gl.shaderSource(shader, code);\r\n    gl.compileShader(shader);\r\n\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        _logger.error(`Error compiling ${type === gl.VERTEX_SHADER ? \"vertex\" : \"fragment\"} shader:`);\r\n        _logger.error(gl.getShaderInfoLog(shader));\r\n        throw new Error(\"Failed to compile a shader.\");\r\n    }\r\n\r\n    return shader;\r\n}\r\n\r\n\r\n/**\r\n * Uniform types enum.\r\n */\r\nconst UniformTypes = \r\n{\r\n    Texture: 'texture',\r\n    Matrix: 'uniformMatrix4fv',\r\n    Color: 'uniform4fv',\r\n\r\n    Float: 'uniform1f',\r\n    FloatArray: 'uniform1fv',\r\n\r\n    Int: 'uniform1i',\r\n    IntArray: 'uniform1iv',\r\n\r\n    Float2: 'uniform2f',\r\n    Float2Array: 'uniform2fv',\r\n\r\n    Int2: 'uniform2i',\r\n    Int2Array: 'uniform2iv',\r\n    \r\n    Float3: 'uniform3f',\r\n    Float3Array: 'uniform3fv',\r\n\r\n    Int3: 'uniform3i',\r\n    Int3Array: 'uniform3iv',\r\n    \r\n    Float4: 'uniform4f',\r\n    Float4Array: 'uniform4fv',\r\n\r\n    Int4: 'uniform4i',\r\n    Int4Array: 'uniform4iv',\r\n}\r\nObject.defineProperty(UniformTypes, '_values', {\r\n    value: new Set(Object.values(UniformTypes)),\r\n    writable: false,\r\n});\r\nObject.freeze(UniformTypes);\r\n\r\n// attach uniform types to effect\r\nEffect.UniformTypes = UniformTypes;\r\n\r\n// define uniform binds - connect uniform name to special usage, like key texture, etc.\r\nEffect.UniformBinds = {\r\n    MainTexture: 'texture',     // bind uniform to be used as the main texture.\r\n    Color: 'color',             // bind uniform to be used as a main color.\r\n    Projection: 'projection',   // bind uniform to be used as the projection matrix.\r\n    World: 'world',             // bind uniform to be used as the world matrix.\r\n    UvOffset: 'uvOffset',       // bind uniform to be used as UV offset.\r\n    UvScale: 'uvScale',         // bind uniform to be used as UV scale.\r\n};\r\nObject.freeze(Effect.UniformBinds);\r\n\r\n// define attribute value types.\r\nEffect.AttributeTypes = {\r\n    Byte: 'BYTE',\r\n    Short: 'SHORT',\r\n    UByte: 'UNSIGNED_BYTE',\r\n    UShort: 'UNSIGNED_SHORT',\r\n    Float: 'FLOAT',\r\n    HalfFloat: 'HALF_FLOAT',\r\n};\r\nObject.freeze(Effect.AttributeTypes);\r\n\r\n// define attribute binds - connect attribute name to special usage, like position, uvs, etc.\r\nEffect.AttributeBinds = {\r\n    Position: 'position',   // bind attribute to be used for vertices position array.\r\n    TextureCoords: 'uvs',   // bind attribute to be used for texture coords array.\r\n    Colors: 'colors',       // bind attribute to be used for vertices colors array.\r\n}\r\nObject.freeze(Effect.AttributeBinds);\r\n\r\n\r\n/**\r\n * Set texture mag and min filters.\r\n * @private\r\n * @param {TextureFilterModes} filter Texture filter to set.\r\n */\r\nfunction _setTextureFilter(gl, filter)\r\n{\r\n    if (!TextureFilterModes._values.has(filter)) { throw new Error(\"Invalid texture filter mode! Please pick a value from 'TextureFilterModes'.\"); }\r\n    let glMode = gl[filter];\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glMode);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glMode);\r\n}\r\n\r\n/**\r\n * Set texture wrap mode on X and Y axis.\r\n * @private\r\n * @param {WrapModes} wrapX Wrap mode on X axis.\r\n * @param {WrapModes} wrapY Wrap mode on Y axis.\r\n */\r\n function _setTextureWrapMode(gl, wrapX, wrapY)\r\n{\r\n    if (wrapY === undefined) { wrapY = wrapX; }\r\n    if (!TextureWrapModes._values.has(wrapX)) { throw new Error(\"Invalid texture wrap mode! Please pick a value from 'WrapModes'.\"); }\r\n    if (!TextureWrapModes._values.has(wrapY)) { throw new Error(\"Invalid texture wrap mode! Please pick a value from 'WrapModes'.\"); }\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[wrapX]);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[wrapY]);\r\n}\r\n\r\n\r\n// export the effect class.\r\nmodule.exports = Effect;", "/**\r\n * Implement a basic effect to draw sprites.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\effects\\basic.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Effect = require(\"./effect\");\r\n\r\n// vertex shader code\r\nconst vertexShader = `\r\nattribute vec3 position;\r\nattribute vec2 coord;\r\nattribute vec4 color;\r\n\r\nuniform mat4 projection;\r\nuniform mat4 world;\r\n\r\nvarying vec2 v_texCoord;\r\nvarying vec4 v_color;\r\n\r\nvoid main(void) {\r\n    gl_Position = projection * world * vec4(position, 1.0);\r\n    gl_PointSize = 1.0;\r\n    v_texCoord = coord;\r\n    v_color = color;\r\n}\r\n    `;\r\n\r\n// fragment shader code\r\nconst fragmentShader = `  \r\n#ifdef GL_ES\r\n    precision highp float;\r\n#endif\r\n\r\nuniform sampler2D texture;\r\n\r\nvarying vec2 v_texCoord;\r\nvarying vec4 v_color;\r\n\r\nvoid main(void) {\r\n    gl_FragColor = texture2D(texture, v_texCoord) * v_color;\r\n    gl_FragColor.rgb *= gl_FragColor.a;\r\n}\r\n    `;\r\n\r\n/**\r\n * Default basic effect to draw 2d sprites.\r\n */\r\nclass BasicEffect extends Effect\r\n{\r\n    /** @inheritdoc */\r\n    get vertexCode() \r\n    { \r\n        return vertexShader; \r\n    }\r\n\r\n    /** @inheritdoc */\r\n    get fragmentCode()\r\n    { \r\n        return fragmentShader;\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    get uniformTypes()\r\n    {\r\n        return {\r\n            \"texture\": { type: Effect.UniformTypes.Texture, bind: Effect.UniformBinds.MainTexture },\r\n            \"projection\": { type: Effect.UniformTypes.Matrix, bind: Effect.UniformBinds.Projection },\r\n            \"world\": { type: Effect.UniformTypes.Matrix, bind: Effect.UniformBinds.World },\r\n        };\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    get attributeTypes()\r\n    {\r\n        return {\r\n            \"position\": { size: 3, type: Effect.AttributeTypes.Float, normalize: false, bind: Effect.AttributeBinds.Position },\r\n            \"coord\": { size: 2, type: Effect.AttributeTypes.Float, normalize: false, bind: Effect.AttributeBinds.TextureCoords },\r\n            \"color\": { size: 4, type: Effect.AttributeTypes.Float, normalize: false, bind: Effect.AttributeBinds.Colors },\r\n        };\r\n    }\r\n}\r\n\r\n\r\n// export the basic shader\r\nmodule.exports = BasicEffect;", "/**\r\n * Include all built-in effects.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\effects\\index.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n\r\n module.exports = {\r\n    Effect: require('./effect'),\r\n    BasicEffect: require('./basic'),\r\n }", "/**\r\n * Implement a 3d vector.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\vector3.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\nconst MathHelper = require(\"./math_helper\");\r\n\r\n/**\r\n * A Vector object for 3d positions.\r\n */\r\nclass Vector3\r\n{\r\n    /**\r\n     * Create the Vector object.\r\n     * @param {number} x Vector X.\r\n     * @param {number} y Vector Y.\r\n     * @param {number} z Vector Z.\r\n     */\r\n    constructor(x = 0, y = 0, z = 0)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    \r\n    /**\r\n     * Clone the vector.\r\n     * @returns {Vector3} cloned vector.\r\n     */\r\n    clone()\r\n    {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    }\r\n    \r\n    /**\r\n     * Set vector value.\r\n     * @param {Number} x X component.\r\n     * @param {Number} y Y component.\r\n     * @param {Number} z Z component.\r\n     * @returns {Vector3} this.\r\n     */\r\n    set(x, y)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy values from other vector into self.\r\n     * @returns {Vector3} this.\r\n     */\r\n    copy(other) \r\n    {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        this.z = other.z;\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Return a new vector of this + other.\r\n     * @param {Number|Vector3} Other Vector or number to add.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    add(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            return new Vector3(\r\n                this.x + other, \r\n                this.y + (arguments[1] === undefined ? other : arguments[1]),\r\n                this.z + (arguments[2] === undefined ? other : arguments[2])\r\n            );\r\n        }\r\n        return new Vector3(this.x + other.x, this.y + other.y, this.z + other.z);\r\n    }\r\n    \r\n    /**\r\n     * Return a new vector of this - other.\r\n     * @param {Number|Vector3} Other Vector or number to sub.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    sub(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            return new Vector3(\r\n                this.x - other, \r\n                this.y - (arguments[1] === undefined ? other : arguments[1]),\r\n                this.z - (arguments[2] === undefined ? other : arguments[2])\r\n            );\r\n        }\r\n        return new Vector3(this.x - other.x, this.y - other.y, this.z - other.z);\r\n    }\r\n    \r\n    /**\r\n     * Return a new vector of this / other.\r\n     * @param {Number|Vector3} Other Vector or number to divide.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    div(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            return new Vector3(\r\n                this.x / other, \r\n                this.y / (arguments[1] === undefined ? other : arguments[1]),\r\n                this.z / (arguments[2] === undefined ? other : arguments[2])\r\n            );\r\n        }\r\n        return new Vector3(this.x / other.x, this.y / other.y, this.z / other.z);\r\n    }\r\n    \r\n    /**\r\n     * Return a new vector of this * other.\r\n     * @param {Number|Vector3} Other Vector or number to multiply.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    mul(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            return new Vector3(\r\n                this.x * other, \r\n                this.y * (arguments[1] === undefined ? other : arguments[1]),\r\n                this.z * (arguments[2] === undefined ? other : arguments[2])\r\n            );\r\n        }\r\n        return new Vector3(this.x * other.x, this.y * other.y, this.z * other.z);\r\n    }\r\n    \r\n    /**\r\n     * Return a round copy of this vector.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    round() \r\n    {\r\n        return new Vector3(Math.round(this.x), Math.round(this.y), Math.round(this.z));\r\n    }\r\n    \r\n    /**\r\n     * Return a floored copy of this vector.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    floor() \r\n    {\r\n        return new Vector3(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));\r\n    }\r\n        \r\n    /**\r\n     * Return a ceiled copy of this vector.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    ceil() \r\n    {\r\n        return new Vector3(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));\r\n    }\r\n    \r\n    /**\r\n     * Return a normalized copy of this vector.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    normalized()\r\n    {\r\n        if (this.x == 0 && this.y == 0 && this.z == 0) { return Vector3.zero; }\r\n        let mag = this.length;\r\n        return new Vector3(this.x / mag, this.y / mag, this.z / mag);\r\n    }\r\n\r\n    /**\r\n     * Add other vector values to self.\r\n     * @param {Number|Vector3} Other Vector or number to add.\r\n     * @returns {Vector3} this.\r\n     */\r\n    addSelf(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            this.x += other;\r\n            this.y += (arguments[1] === undefined ? other : arguments[1]);\r\n            this.z += (arguments[2] === undefined ? other : arguments[2]);\r\n        }\r\n        else {\r\n            this.x += other.x;\r\n            this.y += other.y;\r\n            this.z += other.z;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sub other vector values from self.\r\n     * @param {Number|Vector3} Other Vector or number to substract.\r\n     * @returns {Vector3} this.\r\n     */\r\n    subSelf(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            this.x -= other;\r\n            this.y -= (arguments[1] === undefined ? other : arguments[1]);\r\n            this.z -= (arguments[2] === undefined ? other : arguments[2]);\r\n        }\r\n        else {\r\n            this.x -= other.x;\r\n            this.y -= other.y;\r\n            this.z -= other.z;\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Divide this vector by other vector values.\r\n     * @param {Number|Vector3} Other Vector or number to divide by.\r\n     * @returns {Vector3} this.\r\n     */\r\n    divSelf(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            this.x /= other;\r\n            this.y /= (arguments[1] === undefined ? other : arguments[1]);\r\n            this.z /= (arguments[2] === undefined ? other : arguments[2]);\r\n        }\r\n        else {\r\n            this.x /= other.x;\r\n            this.y /= other.y;\r\n            this.z /= other.z;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiply this vector by other vector values.\r\n     * @param {Number|Vector3} Other Vector or number to multiply by.\r\n     * @returns {Vector3} this.\r\n     */\r\n    mulSelf(other) \r\n    {\r\n        if (typeof other === 'number') {\r\n            this.x *= other;\r\n            this.y *= (arguments[1] === undefined ? other : arguments[1]);\r\n            this.z *= (arguments[2] === undefined ? other : arguments[2]);\r\n        }\r\n        else {\r\n            this.x *= other.x;\r\n            this.y *= other.y;\r\n            this.z *= other.z;\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Round self.\r\n     * @returns {Vector3} this.\r\n     */\r\n    roundSelf() \r\n    {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        this.z = Math.round(this.z);\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Floor self.\r\n     * @returns {Vector3} this.\r\n     */\r\n    floorSelf() \r\n    {\r\n        this.x = Math.floor(this.x);\r\n        this.y = Math.floor(this.y);\r\n        this.z = Math.floor(this.z);\r\n        return this;\r\n    }\r\n     \r\n    /**\r\n     * Ceil self.\r\n     * @returns {Vector3} this.\r\n     */\r\n    ceilSelf() \r\n    {\r\n        this.x = Math.ceil(this.x);\r\n        this.y = Math.ceil(this.y);\r\n        this.z = Math.ceil(this.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return a normalized copy of this vector.\r\n     * @returns {Vector3} this.\r\n     */\r\n    normalizeSelf()\r\n    {\r\n        if (this.x == 0 && this.y == 0 && this.z == 0) { return this; }\r\n        let mag = this.length;\r\n        this.x /= mag;\r\n        this.y /= mag;\r\n        this.z /= mag;\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Return if vector equals another vector.\r\n     * @param {Vector3} other Other vector to compare to.\r\n     * @returns {Boolean} if vectors are equal.\r\n     */\r\n    equals(other)\r\n    {\r\n        return ((this === other) || \r\n                ((other.constructor === this.constructor) && \r\n                this.x === other.x && this.y === other.y && this.z === other.z)\r\n            );\r\n    }\r\n    \r\n    /**\r\n     * Return if vector approximately equals another vector.\r\n     * @param {Vector3} other Other vector to compare to.\r\n     * @param {Number} threshold Distance threshold to consider as equal. Defaults to 1.\r\n     * @returns {Boolean} if vectors are equal.\r\n     */\r\n    approximate(other, threshold)\r\n    {\r\n        threshold = threshold || 1;\r\n        return (\r\n            (this === other) || \r\n                ((Math.abs(this.x - other.x) <= threshold) && \r\n                (Math.abs(this.y - other.y) <= threshold) && \r\n                (Math.abs(this.z - other.z) <= threshold))\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Return vector length (aka magnitude).\r\n     * @returns {Number} Vector length.\r\n     */\r\n    get length()\r\n    {\r\n        return Math.sqrt((this.x * this.x) + (this.y * this.y) + (this.z * this.z));\r\n    }\r\n\r\n    /**\r\n     * Return a copy of this vector multiplied by a factor.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    scaled(fac) \r\n    {\r\n        return new Vector3(this.x * fac, this.y * fac, this.z * fac);\r\n    }\r\n\r\n    /**\r\n     * Get vector (0,0).\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static get zero()\r\n    {\r\n        return new Vector3();\r\n    }\r\n\r\n    /**\r\n     * Get vector with 1,1 values.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static get one()\r\n    {\r\n        return new Vector3(1, 1, 1);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 0.5,0.5 values.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static get half()\r\n    {\r\n        return new Vector3(0.5, 0.5, 0.5);\r\n    }\r\n\r\n    /**\r\n     * Get vector with -1,0 values.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static get left()\r\n    {\r\n        return new Vector3(-1, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 1,0 values.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static get right()\r\n    {\r\n        return new Vector3(1, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 0,-1 values.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static get up()\r\n    {\r\n        return new Vector3(0, -1, 0);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 0,1 values.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static get down()\r\n    {\r\n        return new Vector3(0, 1, 0);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 0,0,-1 values.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static get front()\r\n    {\r\n        return new Vector3(0, 0, -1);\r\n    }\r\n\r\n    /**\r\n     * Get vector with 0,0,1 values.\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static get back()\r\n    {\r\n        return new Vector3(0, 0, 1);\r\n    }\r\n    \r\n    /**\r\n     * Calculate distance between this vector and another vectors.\r\n     * @param {Vector3} other Other vector.\r\n     * @returns {Number} Distance between vectors.\r\n     */\r\n    distanceTo(other)\r\n    {\r\n        return Vector3.distance(this, other);\r\n    }\r\n    \r\n    /**\r\n     * Lerp between two vectors.\r\n     * @param {Vector3} p1 First vector.\r\n     * @param {Vector3} p2 Second vector.\r\n     * @param {Number} a Lerp factor (0.0 - 1.0).\r\n     * @returns {Vector3} result vector.\r\n     */\r\n    static lerp(p1, p2, a)\r\n    {\r\n        let lerpScalar = MathHelper.lerp;\r\n        return new Vector3(lerpScalar(p1.x, p2.x, a), lerpScalar(p1.y, p2.y, a), lerpScalar(p1.z, p2.z, a));\r\n    }\r\n\r\n    /**\r\n     * Calculate distance between two vectors.\r\n     * @param {Vector3} p1 First vector.\r\n     * @param {Vector3} p2 Second vector.\r\n     * @returns {Number} Distance between vectors.\r\n     */\r\n    static distance(p1, p2)\r\n    {\r\n        let a = p1.x - p2.x;\r\n        let b = p1.y - p2.y;\r\n        let c = p1.z - p2.z;\r\n        return Math.sqrt(a*a + b*b + c*c);\r\n    }\r\n\r\n    /**\r\n     * Return cross product between two vectors.\r\n     * @param {Vector3} p1 First vector.\r\n     * @param {Vector3} p2 Second vector.\r\n     * @returns {Vector3} Crossed vector.\r\n     */\r\n    static crossVector(p1, p2)\r\n    {\r\n        const ax = p1.x, ay = p1.y, az = p1.z;\r\n\t\tconst bx = p2.x, by = p2.y, bz = p2.z;\r\n\r\n\t\tlet x = ay * bz - az * by;\r\n\t\tlet y = az * bx - ax * bz;\r\n\t\tlet z = ax * by - ay * bx;\r\n\r\n\t\treturn new Vector3(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Convert to string.\r\n     */\r\n    string()\r\n    {\r\n        return this.x + ',' + this.y + ',' + this.z;\r\n    }\r\n\r\n    /**\r\n     * Parse and return a vector object from string in the form of \"x,y\".\r\n     * @param {String} str String to parse.\r\n     * @returns {Vector3} Parsed vector.\r\n     */\r\n    static parse(str)\r\n    {\r\n        let parts = str.split(',');\r\n        return new Vector3(parseFloat(parts[0].trim()), parseFloat(parts[1].trim()), parseFloat(parts[2].trim()));\r\n    }\r\n\r\n    /**\r\n     * Convert to array of numbers.\r\n     * @returns {Array<Number>} Vector components as array.\r\n     */\r\n    toArray()\r\n    {\r\n        return [this.x, this.y, this.z];\r\n    }\r\n\r\n    /**\r\n     * Create vector from array of numbers.\r\n     * @param {Array<Number>} arr Array of numbers to create vector from.\r\n     * @returns {Vector3} Vector instance.\r\n     */\r\n    static fromArray(arr)\r\n    {\r\n        return new Vector3(arr[0], arr[1], arr[2]);\r\n    }\r\n\r\n    /**\r\n     * Create vector from a dictionary.\r\n     * @param {*} data Dictionary with {x,y,z}.\r\n     * @returns {Vector3} Newly created vector.\r\n     */\r\n    static fromDict(data)\r\n    {\r\n        return new Vector3(data.x, data.y, data.z);\r\n    }\r\n\r\n    /**\r\n     * Convert to dictionary.\r\n     * @returns {*} Dictionary with {x,y,z}\r\n     */\r\n    toDict()\r\n    {\r\n        return {x: this.x, y: this.y, z: this.z};\r\n    }\r\n}\r\n\r\n// export vector object\r\nmodule.exports = Vector3;", "/**\r\n * Implement an animator helper class.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\animator.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst _autoAnimators = [];\r\n\r\n\r\n/**\r\n * Implement an animator object that change values over time using Linear Interpolation.\r\n * Usage example:\r\n * (new Animator(sprite)).from({'position.x': 0}).to({'position.x': 100}).duration(1).play();\r\n */\r\nclass Animator\r\n{\r\n    /**\r\n     * Create the animator.\r\n     * @param {*} target Any object you want to animate.\r\n     */\r\n    constructor(target)\r\n    {\r\n        this._target = target;\r\n        this._fromValues = {};\r\n        this._toValues = {};\r\n        this._progress = 0;\r\n        this._onFinish = null;\r\n        this._smoothDamp = false;\r\n        this._repeats = false;\r\n        this._repeatsWithReverseAnimation = false;\r\n        this._isInAutoUpdate = false;\r\n        this._originalFrom = null;\r\n        this._originalTo = null;\r\n        this._originalRepeats = null;\r\n\r\n        /**\r\n         * Speed factor to multiply with delta every time this animator updates.\r\n         */\r\n        this.speedFactor = 1;\r\n    }\r\n\r\n    /**\r\n     * Update this animator with a given delta time.\r\n     * @param {Number} delta Delta time to progress this animator by.\r\n     */\r\n    update(delta)\r\n    {\r\n        // if already done, skip\r\n        if (this._progress >= 1) {\r\n            return;\r\n        }\r\n\r\n        // apply speed factor and update progress\r\n        delta *= this.speedFactor;\r\n        this._progress += delta;\r\n\r\n        // did finish?\r\n        if (this._progress >= 1) { \r\n\r\n            // make sure don't overflow\r\n            this._progress = 1; \r\n\r\n            // trigger finish method\r\n            if (this._onFinish) {\r\n                this._onFinish();\r\n            }\r\n        }\r\n\r\n        // update values\r\n        for (let key in this._toValues) {\r\n\r\n            // get key as parts and to-value\r\n            let keyParts = this._toValues[key].keyParts;\r\n            let toValue = this._toValues[key].value;\r\n\r\n            // get from value\r\n            let fromValue = this._fromValues[key];\r\n\r\n            // if from not set, get default\r\n            if (fromValue === undefined) {\r\n                this._fromValues[key] = fromValue = this._getValueFromTarget(keyParts);\r\n                if (fromValue === undefined) {\r\n                    throw new Error(`Animator issue: missing origin value for key '${key}' and property not found in target object.`);\r\n                }\r\n            }\r\n\r\n            // if to-value is a method, call it\r\n            if (typeof toValue === 'function') {\r\n                toValue = toValue();\r\n            }\r\n            \r\n            // if from-value is a method, call it\r\n            if (typeof fromValue === 'function') {\r\n                fromValue = toValue();\r\n            }\r\n\r\n            // get lerp factor\r\n            let a = (this._smoothDamp && this._progress < 1) ? (this._progress * (1 + 1 - this._progress)) : this._progress;\r\n\r\n            // calculate new value\r\n            let newValue = null;\r\n            if (typeof fromValue === 'number') {\r\n                newValue = lerp(fromValue, toValue, a);\r\n            }\r\n            else if (fromValue.constructor.lerp) {\r\n                newValue = fromValue.constructor.lerp(fromValue, toValue, a);\r\n            }\r\n            else {\r\n                throw new Error(`Animator issue: from-value for key '${key}' is not a number, and its class type don't implement a 'lerp()' method!`);\r\n            }\r\n\r\n            // set new value\r\n            this._setValueToTarget(keyParts, newValue);\r\n        }\r\n\r\n        // if repeating, reset progress\r\n        if (this._repeats && this._progress >= 1) {\r\n            if (typeof this._repeats === 'number') { this._repeats--; }\r\n            this._progress = 0;\r\n            if (this._repeatsWithReverseAnimation ) {\r\n                this.flipFromAndTo();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get value from target object.\r\n     * @private\r\n     * @param {Array<String>} keyParts Key parts broken by dots.\r\n     */\r\n    _getValueFromTarget(keyParts)\r\n    {\r\n        // easy case - get value when key parts is just one component\r\n        if (keyParts.length === 1) {\r\n            return this._target[keyParts[0]];\r\n        }\r\n\r\n        // get value for path with parts\r\n        function index(obj,i) {return obj[i]}\r\n        return keyParts.reduce(index, this._target);\r\n    }\r\n\r\n    /**\r\n     * Set value in target object.\r\n     * @private\r\n     * @param {Array<String>} keyParts Key parts broken by dots.\r\n     */\r\n     _setValueToTarget(keyParts, value)\r\n     {\r\n        // easy case - set value when key parts is just one component\r\n        if (keyParts.length === 1) {\r\n            this._target[keyParts[0]] = value;\r\n            return;\r\n        }\r\n\r\n        // set value for path with parts\r\n        function index(obj,i) {return obj[i]}\r\n        let parent = keyParts.slice(0, keyParts.length - 1).reduce(index, this._target);\r\n        parent[keyParts[keyParts.length - 1]] = value;\r\n     }\r\n\r\n    /**\r\n     * Make sure a given value is legal for the animator.\r\n     * @private\r\n     */\r\n    _validateValueType(value)\r\n    {\r\n        return (typeof value === 'number') || (typeof value === 'function') || (value && value.constructor && value.constructor.lerp);\r\n    }\r\n\r\n    /**\r\n     * Set a method to run when animation ends.\r\n     * @param {Function} callback Callback to invoke when done.\r\n     * @returns {Animator} this.\r\n     */\r\n    then(callback)\r\n    {\r\n        this._onFinish = callback;\r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Set smooth damp.\r\n     * If true, lerping will go slower as the animation reach its ending.\r\n     * @param {Boolean} enable set smooth damp mode.\r\n     * @returns {Animator} this.\r\n     */\r\n    smoothDamp(enable)\r\n    {\r\n        this._smoothDamp = enable;\r\n        return this;\r\n    }\r\n        \r\n    /**\r\n     * Set if the animator should repeat itself.\r\n     * @param {Boolean|Number} enable false to disable repeating, true for endless repeats, or a number for limited number of repeats.\r\n     * @param {Boolean} reverseAnimation if true, it will reverse animation to repeat it instead of just \"jumping\" back to starting state.\r\n     * @returns {Animator} this.\r\n     */\r\n    repeats(enable, reverseAnimation)\r\n    {\r\n        this._originalRepeats = this._repeats = enable;\r\n        this._repeatsWithReverseAnimation = Boolean(reverseAnimation);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set 'from' values.\r\n     * You don't have to provide 'from' values, when a value is not set the animator will just take whatever was set in target when first update is called.\r\n     * @param {*} values Values to set as 'from' values. \r\n     * Key = property name in target (can contain dots for nested), value = value to start animation from.\r\n     * @returns {Animator} this.\r\n     */\r\n    from(values)\r\n    {\r\n        for (let key in values) {\r\n            if (!this._validateValueType(values[key])) {\r\n                throw new Error(\"Illegal value type to use with Animator! All values must be either numbers, methods, or a class instance that has a static lerp() method.\");\r\n            }\r\n            this._fromValues[key] = values[key];\r\n        }\r\n        this._originalFrom = null;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set 'to' values, ie the result when animation ends.\r\n     * @param {*} values Values to set as 'to' values. \r\n     * Key = property name in target (can contain dots for nested), value = value to start animation from.\r\n     * @returns {Animator} this.\r\n     */\r\n    to(values)\r\n    {\r\n        for (let key in values) {\r\n            if (!this._validateValueType(values[key])) {\r\n                throw new Error(\"Illegal value type to use with Animator! All values must be either numbers, methods, or a class instance that has a static lerp() method.\");\r\n            }\r\n            this._toValues[key] = {keyParts: key.split('.'), value: values[key]};\r\n        }\r\n        this._originalTo = null;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Flip between the 'from' and the 'to' states.\r\n     */\r\n    flipFromAndTo()\r\n    {\r\n        let newFrom = {};\r\n        let newTo = {};\r\n\r\n        if (!this._originalFrom) { this._originalFrom = this._fromValues; }\r\n        if (!this._originalTo) { this._originalTo = this._toValues; }\r\n\r\n        for (let key in this._toValues) {\r\n            newFrom[key] = this._toValues[key].value;\r\n            newTo[key] = {keyParts: key.split('.'), value: this._fromValues[key]};\r\n        }\r\n\r\n        this._fromValues = newFrom;\r\n        this._toValues = newTo;\r\n    }\r\n\r\n    /**\r\n     * Make this Animator update automatically with the gameTime delta time.\r\n     * Note: this will change the speedFactor property.\r\n     * @param {Number} seconds Animator duration time in seconds.\r\n     * @returns {Animator} this.\r\n     */\r\n    duration(seconds)\r\n    {\r\n        this.speedFactor = 1 / seconds;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset animator progress.\r\n     * @returns {Animator} this.\r\n     */\r\n    reset()\r\n    {\r\n        if (this._originalFrom) { this._fromValues = this._originalFrom; }\r\n        if (this._originalTo) { this._toValues = this._originalTo; }\r\n        if (this._originalRepeats !== null) { this._repeats = this._originalRepeats; }\r\n        this._progress = 0;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Make this Animator update automatically with the gameTime delta time, until its done.\r\n     * @returns {Animator} this.\r\n     */\r\n    play()\r\n    {\r\n        if (this._isInAutoUpdate) {\r\n            return;\r\n        }\r\n\r\n        _autoAnimators.push(this);\r\n        this._isInAutoUpdate = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get if this animator finished.\r\n     * @returns {Boolean} True if animator finished.\r\n     */\r\n    get ended()\r\n    {\r\n        return this._progress >= 1;\r\n    }\r\n\r\n    /**\r\n     * Update all auto animators.\r\n     * @private\r\n     * @param {Number} delta Delta time in seconds.\r\n     */\r\n    static updateAutos(delta)\r\n    {\r\n        for (let i = _autoAnimators.length - 1; i >= 0; --i) {\r\n\r\n            _autoAnimators[i].update(delta);\r\n\r\n            if (_autoAnimators[i].ended) {\r\n                _autoAnimators[i]._isInAutoUpdate = false;\r\n                _autoAnimators.splice(i, 1);\r\n            }\r\n\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// a simple lerp method\r\nfunction lerp(start, end, amt) {\r\n    return (1-amt)*start + amt*end;\r\n}\r\n\r\n\r\n// export the animator class.\r\nmodule.exports = Animator;", "/**\r\n * A utility to hold gametime.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\game_time.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n \r\n/**\r\n * Class to hold current game time (elapse and deltatime).\r\n */\r\nclass GameTime\r\n{\r\n    /**\r\n     * create the gametime object with current time.\r\n     */\r\n    constructor()\r\n    {\r\n        /**\r\n         * Current timestamp\r\n         */\r\n        this.timestamp = _currElapsed;\r\n\r\n        /**\r\n         * Delta time struct.\r\n         * Contains: milliseconds, seconds.\r\n         */\r\n        this.deltaTime = {\r\n            milliseconds: _currDelta,\r\n            seconds: _currDelta / 1000.0,\r\n        };\r\n\r\n        /**\r\n         * Elapsed time struct.\r\n         * Contains: milliseconds, seconds.\r\n         */\r\n        this.elapsedTime = {\r\n            milliseconds: _currElapsed,\r\n            seconds: _currElapsed / 1000.0\r\n        };\r\n\r\n        /**\r\n         * Delta time, in seconds, since last frame.\r\n         */\r\n        this.delta = this.deltaTime ? this.deltaTime.seconds : null;\r\n\r\n        /**\r\n         * Total time, in seconds, since Shaku was initialized.\r\n         */\r\n        this.elapsed = this.elapsedTime.seconds;\r\n\r\n        // freeze object\r\n        Object.freeze(this);\r\n    }\r\n\r\n    /**\r\n     * Update game time.\r\n     */\r\n    static update()\r\n    {\r\n        // get current time\r\n        let curr = getAccurateTimestampMs();\r\n\r\n        // calculate delta time\r\n        let delta = 0;\r\n        if (_prevTime) {\r\n            delta = curr - _prevTime;\r\n        }\r\n\r\n        // update previous time\r\n        _prevTime = curr;\r\n\r\n        // update delta and elapsed\r\n        _currDelta = delta;\r\n        _currElapsed += delta;\r\n    }\r\n\r\n    /**\r\n     * Get raw timestamp in milliseconds.\r\n     * @returns {Number} raw timestamp in milliseconds.\r\n     */\r\n    static rawTimestamp()\r\n    {\r\n        return getAccurateTimestampMs();\r\n    }\r\n\r\n    /**\r\n     * Reset elapsed and delta time.\r\n     */\r\n    static reset()\r\n    {\r\n        _prevTime = null;\r\n        _currDelta = 0;\r\n        _currElapsed = 0;\r\n    }\r\n\r\n    /**\r\n     * Reset current frame's delta time.\r\n     */ \r\n    static resetDelta()\r\n    {\r\n        _prevTime = null;\r\n        _currDelta = 0;\r\n    }\r\n}\r\n\r\n// do we have the performance.now method?\r\nconst gotPerformance = (typeof performance !== 'undefined') && performance.now;\r\n\r\n// get most accurate timestamp in milliseconds.\r\nfunction getAccurateTimestampMs() {\r\n    if (gotPerformance) {\r\n        return performance.now();\r\n    }\r\n    return Date.now();\r\n}\r\n\r\n// previous time (to calculate delta).\r\nvar _prevTime = null;\r\n\r\n// current delta and elapsed\r\nvar _currDelta = 0;\r\nvar _currElapsed = 0;\r\n\r\n// export the GameTime class.\r\nmodule.exports = GameTime;", "/**\r\n * Implement a seeded random generator.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\seeded_random.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n/**\r\n * Class to generate random numbers with seed.\r\n */\r\nclass SeededRandom\r\n{\r\n    /**\r\n     * Create the seeded random object.\r\n     * @param {Number} seed Seed to start from. If not provided, will use 0.\r\n     */\r\n    constructor(seed)\r\n    {\r\n        if (seed === undefined) { seed = 0; }\r\n        this.seed = seed;\r\n    }\r\n\r\n    /**\r\n     * Get next random value.\r\n     * @param {Number} min Optional min value. If max is not provided, this will be used as max.\r\n     * @param {Number} max Optional max value.\r\n     * @returns {Number} A randomly generated value.\r\n     */\r\n    random(min, max)\r\n    {\r\n        // generate next value\r\n        this.seed = (this.seed * 9301 + 49297) % 233280;\r\n        let rnd = this.seed / 233280;\r\n\r\n        // got min and max?\r\n        if (min && max) {\r\n            return min + rnd * (max - min);\r\n        }\r\n        // got only min (used as max)?\r\n        else if (min) {\r\n            return rnd * min;\r\n        }\r\n        // no min nor max provided\r\n        return rnd;\r\n    }\r\n    \r\n    /**\r\n     * Pick a random value from array.\r\n     * @param {Array} options Options to pick random value from.\r\n     * @returns {*} Random value from options array.\r\n     */\r\n    pick(options)\r\n    {\r\n        return options[Math.floor(this.random(options.length))];\r\n    }\r\n}\r\n\r\n// export the seeded random class.\r\nmodule.exports = SeededRandom;", "/**\r\n * Implements 2d perlin noise generator.\r\n * Based on code from noisejs by Stefan Gustavson.\r\n * https://github.com/josephg/noisejs/blob/master/perlin.js\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\perlin.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n// import some utilities\r\nconst MathHelper = require(\"./math_helper\");\r\nconst lerp = MathHelper.lerp;\r\n\r\n// do fade\r\nfunction fade(t) {\r\n    return t*t*t*(t*(t*6-15)+10);\r\n}\r\n\r\n// store gradient value\r\nfunction Grad(x, y, z) {\r\n    this.x = x; this.y = y; this.z = z;\r\n}\r\nGrad.prototype.dot2 = function(x, y) {\r\n    return this.x*x + this.y*y;\r\n};\r\n\r\n// const premutations\r\nconst p = [151,160,137,91,90,15,\r\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\r\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\r\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\r\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\r\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\r\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\r\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\r\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\r\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\r\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\r\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\r\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\r\n\r\n\r\n/**\r\n * Generate 2d perlin noise.\r\n * Based on code from noisejs by Stefan Gustavson.\r\n * https://github.com/josephg/noisejs/blob/master/perlin.js\r\n */\r\nclass Perlin\r\n{\r\n    /**\r\n     * Create the perlin noise generator.\r\n     * @param {Number} seed Seed for perlin noise, or undefined for random.\r\n     */\r\n    constructor(seed)\r\n    {\r\n        if (seed === undefined) { seed = Math.random(); }\r\n        this.seed(seed);\r\n    }\r\n\r\n    /**\r\n     * Set the perlin noise seed.\r\n     * @param {Number} seed New seed value. May be either a decimal between 0 to 1, or an unsigned short between 0 to 65536.\r\n     */\r\n    seed(seed)\r\n    {\r\n        // scale the seed out\r\n        if(seed > 0 && seed < 1) {\r\n            seed *= 65536;\r\n        }\r\n    \r\n        // make sure round and current number of bits\r\n        seed = Math.floor(seed);\r\n        if (seed < 256) {\r\n            seed |= seed << 8;\r\n        }\r\n\r\n        // create perm, gradP and grad3 arrays\r\n        var perm = new Array(512);\r\n        var gradP = new Array(512);\r\n        var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\r\n            new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\r\n            new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\r\n    \r\n        // apply seed\r\n        for(var i = 0; i < 256; i++) \r\n        {\r\n            var v;\r\n            if (i & 1) {\r\n                v = p[i] ^ (seed & 255);\r\n            } else {\r\n                v = p[i] ^ ((seed>>8) & 255);\r\n            }\r\n    \r\n            perm[i] = perm[i + 256] = v;\r\n            gradP[i] = gradP[i + 256] = grad3[v % 12];\r\n        }\r\n\r\n        // store new params\r\n        this._perm = perm;\r\n        this._gradP = gradP;\r\n    }\r\n\r\n    /**\r\n     * Generate a perlin noise value for x,y coordinates.\r\n     * @param {Number} x X coordinate to generate perlin noise for.\r\n     * @param {Number} y Y coordinate to generate perlin noise for. \r\n     * @param {Number} blurDistance Distance to take neighbors to blur returned value with. Defaults to 0.25.\r\n     * @param {Number} contrast Optional contrast factor.\r\n     * @returns {Number} Perlin noise value for given point.\r\n     */\r\n    generateSmooth(x, y, blurDistance, contrast) \r\n    {\r\n        if (blurDistance === undefined) { \r\n            blurDistance = 0.25;\r\n        }\r\n        let a = this.generate(x-blurDistance, y-blurDistance, contrast);\r\n        let b = this.generate(x+blurDistance, y+blurDistance, contrast);\r\n        let c = this.generate(x-blurDistance, y+blurDistance, contrast);\r\n        let d = this.generate(x+blurDistance, y-blurDistance, contrast);\r\n        return (a + b + c + d) / 4;\r\n    }\r\n\r\n    /**\r\n     * Generate a perlin noise value for x,y coordinates.\r\n     * @param {Number} x X coordinate to generate perlin noise for.\r\n     * @param {Number} y Y coordinate to generate perlin noise for. \r\n     * @param {Number} contrast Optional contrast factor.\r\n     * @returns {Number} Perlin noise value for given point, ranged from 0 to 1.\r\n     */\r\n    generate(x, y, contrast) \r\n    {\r\n        // default contrast\r\n        if (contrast === undefined) {\r\n            contrast = 1;\r\n        }\r\n\r\n        // store new params\r\n        let perm = this._perm;\r\n        let gradP = this._gradP;\r\n\r\n        // find unit grid cell containing point\r\n        var X = Math.floor(x), Y = Math.floor(y);\r\n\r\n        // get relative xy coordinates of point within that cell\r\n        x = x - X; y = y - Y;\r\n\r\n        // wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n        X = X & 255; Y = Y & 255;\r\n    \r\n        // calculate noise contributions from each of the four corners\r\n        var n00 = gradP[X+perm[Y]].dot2(x, y) * contrast;\r\n        var n01 = gradP[X+perm[Y+1]].dot2(x, y-1) * contrast;\r\n        var n10 = gradP[X+1+perm[Y]].dot2(x-1, y) * contrast;\r\n        var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1) * contrast;\r\n    \r\n        // compute the fade curve value for x\r\n        var u = fade(x);\r\n    \r\n        // interpolate the four results\r\n        return Math.min(lerp(\r\n            lerp(n00, n10, u),\r\n            lerp(n01, n11, u),\r\n            fade(y)) + 0.5, 1);\r\n    };\r\n}\r\n\r\n// export the perlin generator\r\nmodule.exports = Perlin;", "/**\r\n * Implement a storage adapter.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\storage_adapter.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n\r\n/**\r\n * Storage adapter class that implement access to a storage device.\r\n * Used by the Storage utilitiy.\r\n */\r\nclass StorageAdapter\r\n{\r\n    /**\r\n     * Return if this storage adapter is persistent storage or not.\r\n     * @returns {Boolean} True if this storage type is persistent.\r\n     */\r\n    get persistent()\r\n    {\r\n        throw new Error(\"Not Implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Check if this adapter is OK to be used.\r\n     * For example, an adapter for localStorage will make sure it exists and not null.\r\n     * @returns {Boolean} True if storage adapter is valid to be used.\r\n     */\r\n    isValid()\r\n    {\r\n        throw new Error(\"Not Implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Check if a key exists.\r\n     * @param {String} key Key to check.\r\n     * @returns {Boolean} True if key exists in storage.\r\n     */\r\n    exists(key)\r\n    {\r\n        throw new Error(\"Not Implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Set value.\r\n     * @param {String} key Key to set.\r\n     * @param {String} value Value to set.\r\n     */\r\n    setItem(key, value)\r\n    {\r\n        throw new Error(\"Not Implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Get value.\r\n     * @param {String} key Key to get.\r\n     * @returns {String} Value or null if not set.\r\n     */\r\n    getItem(key)\r\n    {\r\n        throw new Error(\"Not Implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Delete value.\r\n     * @param {String} key Key to delete.\r\n     */\r\n    deleteItem(key)\r\n    {\r\n        throw new Error(\"Not Implemented.\");\r\n    }\r\n    \r\n    /**\r\n     * Clear all values from this storage device.\r\n     * @param {String} prefix Storage keys prefix.\r\n     */\r\n    clear(prefix)\r\n    {\r\n        throw new Error(\"Not Implemented.\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Implement simple memory storage adapter.\r\n */\r\nclass StorageAdapterMemory\r\n{\r\n    /**\r\n     * Create the memory storage adapter.\r\n     */\r\n    constructor()\r\n    {\r\n        this._data = {};\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get persistent()\r\n    {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    isValid()\r\n    {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    exists(key)\r\n    {\r\n        return Boolean(this._data[key]);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    setItem(key, value)\r\n    {\r\n        this._data[key] = value;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    getItem(key)\r\n    {\r\n        return this._data[key];\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    deleteItem(key)\r\n    {\r\n        delete this._data[key];\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    clear(prefix)\r\n    {\r\n        for (let key in this._data) {\r\n            if (key.indexOf(prefix) === 0) {\r\n                delete this._data[key];\r\n            }\r\n        }\r\n    }\r\n}\r\nStorageAdapter.memory = StorageAdapterMemory;\r\n\r\n\r\n/**\r\n * Implement simple localstorage storage adapter.\r\n */\r\nclass StorageAdapterLocalStorage\r\n{\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get persistent()\r\n    {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    isValid()\r\n    {\r\n        try {\r\n            return (typeof localStorage !== \"undefined\") && (localStorage !== null);\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    exists(key)\r\n    {\r\n        return localStorage.getItem(key) !== null;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    setItem(key, value)\r\n    {\r\n        localStorage.setItem(key, value);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    getItem(key)\r\n    {\r\n        return localStorage.getItem(key);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    deleteItem(key)\r\n    {\r\n        localStorage.deleteItem(key);\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    clear(prefix)\r\n    {\r\n        for (let i = 0; i < localStorage.length; i++) {\r\n            const key = localStorage.key(i);\r\n            if (key.indexOf(prefix) === 0) {\r\n                delete localStorage.deleteItem(key);\r\n            }\r\n        }\r\n    }\r\n}\r\nStorageAdapter.localStorage = StorageAdapterLocalStorage;\r\n\r\n\r\n/**\r\n * Implement simple sessionStorage storage adapter.\r\n */\r\nclass StorageAdapterSessionStorage\r\n{\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get persistent()\r\n    {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    isValid()\r\n    {\r\n        try {\r\n            return (typeof sessionStorage !== \"undefined\") && (sessionStorage !== null);\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    exists(key)\r\n    {\r\n        return sessionStorage.getItem(key) !== null;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    setItem(key, value)\r\n    {\r\n        sessionStorage.setItem(key, value);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    getItem(key)\r\n    {\r\n        return sessionStorage.getItem(key);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    deleteItem(key)\r\n    {\r\n        sessionStorage.deleteItem(key);\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    clear(prefix)\r\n    {\r\n        for (let i = 0; i < sessionStorage.length; i++) {\r\n            const key = sessionStorage.key(i);\r\n            if (key.indexOf(prefix) === 0) {\r\n                delete sessionStorage.deleteItem(key);\r\n            }\r\n        }\r\n    }\r\n}\r\nStorageAdapter.sessionStorage = StorageAdapterSessionStorage;\r\n\r\n\r\n// export the storage adapter class\r\nmodule.exports = StorageAdapter;", "/**\r\n * Implement a storage wrapper.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\storage.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst StorageAdapter = require(\"./storage_adapter\");\r\n\r\n\r\n/**\r\n * A thin wrapper layer around storage utility.\r\n */\r\nclass Storage\r\n{\r\n    /**\r\n     * Create the storage.\r\n     * @param {Array<StorageAdapter>} adapters List of storage adapters to pick from. Will use the first option returning 'isValid()' = true.\r\n     * @param {String} prefix Optional prefix to add to all keys under this storage instance.\r\n     * @param {Boolean} valuesAsBase64 If true, will encode and decode data as base64.\r\n     * @param {Boolean} keysAsBase64 If true, will encode and decode keys as base64.\r\n     */\r\n    constructor(adapters, prefix, valuesAsBase64, keysAsBase64)\r\n    {\r\n        // default adapters\r\n        adapters = adapters || Storage.defaultAdapters;\r\n\r\n        // default to array\r\n        if (!(adapters instanceof Array)) {\r\n            adapters = [adapters];\r\n        }\r\n\r\n        // choose adapter\r\n        this._adapter = null;\r\n        for (let adapter of adapters) {\r\n            if (adapter.isValid()) {\r\n                this._adapter = adapter;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // set if should use base64\r\n        this.valuesAsBase64 = Boolean(valuesAsBase64);\r\n        this.keysAsBase64 = Boolean(keysAsBase64);\r\n\r\n        // set prefix\r\n        this._keysPrefix = 'shaku_storage_' + (prefix || '') + '_';\r\n    }\r\n\r\n    /**\r\n     * Return if this storage adapter is persistent storage or not.\r\n     * @returns {Boolean} True if this storage type is persistent.\r\n     */\r\n    get persistent()\r\n    {\r\n        return this.isValid && this._adapter.persistent;\r\n    }\r\n\r\n    /**\r\n     * Check if this storage instance has a valid adapter.\r\n     * @returns {Boolean} True if found a valid adapter to use, false otherwise.\r\n     */\r\n    get isValid()\r\n    {\r\n        return Boolean(this._adapter);\r\n    }\r\n\r\n    /**\r\n     * Convert key to string and add prefix if needed.\r\n     * @private\r\n     * @param {String} key Key to normalize.\r\n     * @returns {String} Normalized key.\r\n     */\r\n    normalizeKey(key)\r\n    {\r\n        key = this._keysPrefix + key.toString();\r\n        if (this.keysAsBase64) {\r\n            key = btoa(key);\r\n        }\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Check if a key exists.\r\n     * @param {String} key Key to check.\r\n     * @returns {Boolean} True if key exists in storage.\r\n     */\r\n    exists(key)\r\n    {\r\n        if (typeof key !== 'string') { throw new Error(\"Key must be a string!\"); }\r\n        key = this.normalizeKey(key);\r\n        return this._adapter.exists(key);\r\n    }\r\n\r\n    /**\r\n     * Set value.\r\n     * @private\r\n     */\r\n    _set(key, value)\r\n    {\r\n        // json stringify\r\n        value = JSON.stringify({\r\n            data: value,\r\n            timestamp: (new Date()).getTime(),\r\n            src: \"Shaku\",\r\n            sver: 1.0\r\n        });\r\n\r\n        // convert to base64\r\n        if (this.valuesAsBase64) {\r\n            value = btoa(value);\r\n        }\r\n\r\n        // store value\r\n        this._adapter.setItem(key, value);\r\n    }\r\n\r\n    /**\r\n     * Get value.\r\n     * @private\r\n     */\r\n    _get(key)\r\n    {\r\n        // get value\r\n        var value = this._adapter.getItem(key);\r\n\r\n        // not found? return null\r\n        if (value === null) {\r\n            return null;\r\n        }\r\n\r\n        // convert from base64\r\n        if (this.valuesAsBase64) {\r\n            try {\r\n                value = atob(value);\r\n            }\r\n            catch (e) {\r\n                throw new Error(\"Failed to parse Base64 string while reading data. Did you try to read a value as Base64 that wasn't encoded as Base64 when written to storage?\");\r\n            }\r\n        }\r\n\r\n        // parse json\r\n        try {\r\n            value = JSON.parse(value);\r\n        }\r\n        catch (e) {\r\n            throw new Error(\"Failed to JSON-parse data from storage. Did you try to read something that wasn't written with the Storage utility?\");\r\n        }\r\n\r\n        // return value\r\n        return value.data;\r\n    }\r\n    \r\n    /**\r\n     * Set value.\r\n     * @param {String} key Key to set.\r\n     * @param {String} value Value to set.\r\n     */\r\n    setItem(key, value)\r\n    {\r\n        // sanity and normalize key\r\n        if (typeof key !== 'string') { throw new Error(\"Key must be a string!\"); }\r\n        key = this.normalizeKey(key);\r\n\r\n        // write value with metadata\r\n        this._set(key, value);\r\n    }\r\n\r\n    /**\r\n     * Get value.\r\n     * @param {String} key Key to get.\r\n     * @returns {String} Value or null if not set.\r\n     */\r\n    getItem(key)\r\n    {\r\n        // sanity and normalize key\r\n        if (typeof key !== 'string') { throw new Error(\"Key must be a string!\"); }\r\n        key = this.normalizeKey(key);\r\n\r\n        // read value from metadata\r\n        return this._get(key);\r\n    }\r\n\r\n    /**\r\n     * Get value and JSON parse it.\r\n     * @param {String} key Key to get.\r\n     * @returns {*} Value as a dictionary object or null if not set.\r\n     */\r\n    getJson(key)\r\n    {\r\n        return this.getItem(key) || null;\r\n    }\r\n\r\n    /**\r\n     * Set value as JSON.\r\n     * @param {String} key Key to set.\r\n     * @param {*} value Value to set as a dictionary.\r\n     */\r\n    setJson(key, value)\r\n    {\r\n        key = this.normalizeKey(key);\r\n        this._set(key, value);\r\n    }\r\n\r\n    /**\r\n     * Delete value.\r\n     * @param {String} key Key to delete.\r\n     */\r\n    deleteItem(key)\r\n    {\r\n        if (typeof key !== 'string') { throw new Error(\"Key must be a string!\"); }\r\n        key = this.normalizeKey(key);\r\n        this._adapter.deleteItem(key);\r\n    }\r\n    \r\n    /**\r\n     * Clear all values from this storage instance, based on prefix + adapter type.\r\n     */\r\n    clear()\r\n    {\r\n        this._adapter.clear(this._keysPrefix);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Default adapters to use when no adapters list is provided.\r\n */\r\nStorage.defaultAdapters = [new StorageAdapter.localStorage(), new StorageAdapter.sessionStorage(), new StorageAdapter.memory()];\r\n\r\n\r\n// export the storage class\r\nmodule.exports = Storage;", "/**\r\n * Provide a pathfinding algorithm.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\path_finder.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n*/\r\n'use strict';\r\nconst Vector2 = require(\"./vector2\");\r\n\r\n\r\n/**\r\n * Interface for a supported grid.\r\n */\r\nclass IGrid\r\n{\r\n    /**\r\n     * Check if a given tile is blocked from a given neihbor.\r\n     * @param {Vector2|Vector3} _from Source tile index.\r\n     * @param {Vector2|Vector3} _to Target tile index. Must be a neighbor of _from.\r\n     * @returns {Boolean} Can we travel from _from to _to?\r\n     */\r\n    isBlocked(_from, _to) { throw new Error(\"Not Implemented\"); }\r\n\r\n    /**\r\n     * Get the price to travel on a given tile.\r\n     * Should return 1 for \"normal\" traveling price, > 1 for expensive tile, and < 1 for a cheap tile to pass on.\r\n     * @param {Vector2|Vector3} _index Tile index.\r\n     * @returns {Number} Price factor to walk on.\r\n     */\r\n    getPrice(_index) { throw new Error(\"Not Implemented\"); }\r\n}\r\n\r\n\r\n/**\r\n * A path node.\r\n */\r\nclass Node\r\n{\r\n    constructor(position)\r\n    {\r\n        this.position = position;\r\n        this.gCost = 0;\r\n        this.hCost = 0;\r\n        this.parent = null;\r\n        this.price = 1;\r\n    }\r\n\r\n    get fCost()\r\n    {\r\n        return this.gCost + this.hCost;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find a path between start to target.\r\n * @param {IGrid} grid Grid provider to check if tiles are blocked.\r\n * @param {Vector2|Vector3} startPos Starting tile index.\r\n * @param {Vector2|Vector3} targetPos Target tile index.\r\n * @param {*} options Additional options: { maxIterations, ignorePrices, allowDiagonal }\r\n * @returns {Array<Vector2>} List of tiles to traverse.\r\n */\r\nfunction findPath(grid, startPos, targetPos, options)\r\n{\r\n    let ret = _ImpFindPath(grid, startPos, targetPos, options || {});\r\n    return ret;\r\n}\r\n\r\n\r\n/**\r\n * Internal function that implements the path-finding algorithm.\r\n * @private\r\n */\r\nfunction _ImpFindPath(grid, startPos, targetPos, options)\r\n{\r\n    // do we allow diagonal tiles?\r\n    const allowDiagonal = options.allowDiagonal;\r\n\r\n    // get / create node\r\n    let nodesCache = {};\r\n    function getOrCreateNode(position) {\r\n\r\n        // get from cache\r\n        let key = (position.x + ',' + position.y);\r\n        if (nodesCache[key]) {\r\n            return nodesCache[key];\r\n        }\r\n\r\n        // create new\r\n        let ret = new Node(position);\r\n        nodesCache[key] = ret;\r\n        return ret;\r\n    }\r\n    \r\n    // create start and target node\r\n    let startNode = getOrCreateNode(startPos);\r\n    let targetNode = getOrCreateNode(targetPos);\r\n\r\n    // tiles we may still travel to\r\n    let openSet = [];\r\n    openSet.push(startNode);\r\n\r\n    // tiles we were blocked at\r\n    let closedSet = new Set();\r\n\r\n    // remove from array by value\r\n    function removeFromArray(arr, val) {\r\n        let index = arr.indexOf(val);\r\n        if (index !== -1) {\r\n            arr.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    // while we got open way to go...\r\n    let iterationsCount = -1;\r\n    while (openSet.length > 0)\r\n    {\r\n        // check iterations count\r\n        if (options.maxIterations) {\r\n            if (iterationsCount++ > options.maxIterations) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // find optimal node to start from\r\n        let currentNode = openSet[0];\r\n        for (let i = 1; i < openSet.length; i++)\r\n        {\r\n            if ((openSet[i].fCost <= currentNode.fCost) && (openSet[i].hCost < currentNode.hCost))\r\n            {\r\n                currentNode = openSet[i];\r\n            }\r\n        }\r\n\r\n        // add current node to close set\r\n        removeFromArray(openSet, currentNode);\r\n        closedSet.add(currentNode);\r\n\r\n        // did we reach target? :D\r\n        if (currentNode == targetNode)\r\n        {\r\n            let finalPath = retracePath(startNode, targetNode);\r\n            return finalPath;\r\n        }\r\n\r\n        // get neighbor tiles\r\n        let neighbors = [];\r\n        for (let nx = -1; nx <= 1; nx++)\r\n        {\r\n            for (let ny = -1; ny <= 1; ny++)\r\n            {\r\n                if (nx === 0 && ny === 0) { continue; }\r\n                if (!allowDiagonal && (nx !== 0 && ny !== 0)) { continue; }\r\n                neighbors.push(getOrCreateNode({x: currentNode.position.x + nx, y: currentNode.position.y + ny, z: currentNode.position.z}));\r\n            }\r\n        }\r\n\r\n        // iterate neighbors\r\n        for (let neighbor of neighbors)\r\n        {\r\n            // skip if already passed or can't walk there\r\n            if (closedSet.has(neighbor) || grid.isBlocked(currentNode.position, neighbor.position)) {\r\n                continue;\r\n            }\r\n\r\n            // calc const and price to walk there\r\n            let price = (options.ignorePrices) ? 1 : grid.getPrice(neighbor.position);\r\n            let currStepCost = currentNode.gCost + getDistance(currentNode, neighbor) * price;\r\n\r\n            // update node price and add to open set\r\n            let isInOpenSet = (openSet.indexOf(neighbor) !== -1);\r\n            if (!isInOpenSet || (currStepCost < neighbor.gCost))\r\n            {\r\n                // update node price and parent\r\n                neighbor.gCost = currStepCost;\r\n                neighbor.hCost = getDistance(neighbor, targetNode);\r\n                neighbor.parent = currentNode;\r\n\r\n                // add to open set\r\n                if (!isInOpenSet) {\r\n                    openSet.push(neighbor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // didn't find path\r\n    return null;\r\n}\r\n\r\n/**\r\n * Convert nodes structure with parents into a list of tile indices.\r\n * Go from end to start (for shortest path) and build list reversed.\r\n * @private\r\n */\r\nfunction retracePath(startNode, endNode)\r\n{\r\n    let path = [];\r\n    let currentNode = endNode;\r\n\r\n    while (currentNode !== startNode)\r\n    {\r\n        path.unshift(currentNode.position);\r\n        currentNode = currentNode.parent;\r\n    }\r\n\r\n    return path;\r\n}\r\n\r\n/**\r\n * Get distance between two points on grid.\r\n * This method is quick and dirty and takes diagonal into consideration.\r\n */\r\nfunction getDistance(pa, pb)\r\n{\r\n    let dx = (pa.position.x - pb.position.x);\r\n    let dy = (pa.position.y - pb.position.y);\r\n    return Math.sqrt(dx*dx + dy*dy);\r\n}\r\n\r\n\r\n// export main method and grid interface.\r\nconst PathFinder = {\r\n    findPath: findPath,\r\n    IGrid: IGrid\r\n};\r\nmodule.exports = PathFinder;", "/**\r\n * Include all util classes.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\utils\\index.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n\r\n module.exports = {\r\n    Vector2: require('./vector2'),\r\n    Vector3: require('./vector3'),\r\n    Rectangle: require('./rectangle'),\r\n    Circle: require('./circle'),\r\n    Line: require('./line'),\r\n    Color: require('./color'),\r\n    Animator: require('./animator'),\r\n    GameTime: require('./game_time'),\r\n    MathHelper: require('./math_helper'),\r\n    SeededRandom: require('./seeded_random'),\r\n    Perlin: require('./perlin'),\r\n    Storage: require('./storage'),\r\n    StorageAdapter: require('./storage_adapter'),\r\n    PathFinder: require('./path_finder')\r\n };", "/**\r\n * Define a mesh object.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\mesh.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n\r\nconst { Color } = require(\"../utils\");\r\n\r\n /**\r\n  * Class to hold a mesh.\r\n  */\r\n class Mesh\r\n {\r\n    /**\r\n     * Create the mesh object.\r\n     * @param {WebGLBuffer} positions vertices positions buffer. \r\n     * @param {WebGLBuffer} textureCoords vertices texture coords buffer.\r\n     * @param {WebGLBuffer} colorss vertices colors buffer.\r\n     * @param {WebGLBuffer} indices indices buffer.\r\n     * @param {Number} indicesCount how many indices we have.\r\n     */\r\n    constructor(positions, textureCoords, colorsBuffer, indices, indicesCount)\r\n    {\r\n        this.positions = positions;\r\n        this.textureCoords = textureCoords;\r\n        this.colors = colorsBuffer;\r\n        this.indices = indices;\r\n        this.indicesCount = indicesCount;\r\n        this.__color = new Color(-1, -1, -1, -1);\r\n        Object.freeze(this);\r\n    }\r\n\r\n    /**\r\n     * Override the colors buffer, if possible.\r\n     * @param {WebGl} gl WebGL context.\r\n     * @param {Color} color Color to set.\r\n     */\r\n    overrideColors(gl, color)\r\n    {\r\n        if (color.equals(this.__color)) { return; }\r\n        this.__color.copy(color);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.colors);\r\n        const colors = [];\r\n        for (let i = 0; i < this.indicesCount; ++i) {\r\n            colors.push(color.r);\r\n            colors.push(color.g);\r\n            colors.push(color.b);\r\n            colors.push(color.a);\r\n        }\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);\r\n    }\r\n }\r\n \r\n // export the mesh class.\r\n module.exports = Mesh;", "/**\r\n * Define utility to generate meshes.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\mesh_generator.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\nconst Mesh = require(\"./mesh\");\r\n\r\n/**\r\n * Utility class to generate meshes.\r\n * @private\r\n */\r\nclass MeshGenerator\r\n{\r\n    /**\r\n     * Create the mesh generator.\r\n     */\r\n    constructor(gl)\r\n    {\r\n        this._gl = gl;\r\n    }\r\n\r\n    /**\r\n     * Generate and return a textured quad.\r\n     * @returns {Mesh} Quad mesh.\r\n     */\r\n    quad()\r\n    {\r\n        const gl = this._gl;\r\n\r\n        const positionBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n        let x = 0.5; // <- 0.5 so total size would be 1x1\r\n        const positions = [\r\n            -x, -x,  0,\r\n             x, -x,  0,\r\n            -x,  x,  0,\r\n            x,  x,  0,\r\n        ];\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n    \r\n        const textureCoordBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n        const textureCoordinates = [\r\n            0.0,  0.0,\r\n            1.0,  0.0,\r\n            0.0,  1.0,\r\n            1.0,  1.0,\r\n        ];\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n        const colorsBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\r\n        const colors = [\r\n            1,1,1,1,\r\n            1,1,1,1,\r\n            1,1,1,1,\r\n            1,1,1,1,\r\n        ];\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);\r\n    \r\n        const indexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        const indices = [\r\n            0, 1, 3, 2\r\n        ];\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n    \r\n        return new Mesh(positionBuffer, textureCoordBuffer, colorsBuffer, indexBuffer, indices.length);\r\n    }\r\n}\r\n\r\n// export the meshes generator.\r\nmodule.exports = MeshGenerator;", "/**\r\n * Camera class.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\camera.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n\r\nconst Rectangle = require(\"../utils/rectangle\");\r\nconst Vector2 = require(\"../utils/vector2\");\r\nconst Matrix = require(\"./matrix\");\r\n\r\n /**\r\n  * Implements a Camera object.\r\n  */\r\nclass Camera\r\n{\r\n    /**\r\n     * Create the camera.\r\n     * @param {Gfx} gfx The gfx manager instance.\r\n     */\r\n    constructor(gfx)\r\n    {\r\n        /**\r\n         * Camera projection matrix.\r\n         * You can set it manually, or use 'orthographicOffset' / 'orthographic' / 'perspective' helper functions.\r\n         */\r\n        this.projection = null;\r\n\r\n        this._region = null;\r\n        this._gfx = gfx;\r\n        this.orthographic();\r\n        this._viewport = null;\r\n    }\r\n\r\n    /**\r\n     * Get camera's viewport (drawing region to set when using this camera).\r\n     * @returns {Rectangle} Camera's viewport as rectangle.\r\n     */\r\n    get viewport()\r\n    {\r\n        return this._viewport;\r\n    }\r\n\r\n    /**\r\n     * Set camera's viewport.\r\n     * @param {Rectangle} viewport New viewport to set or null to not use any viewport when using this camera.\r\n     */\r\n    set viewport(viewport)\r\n    {\r\n        this._viewport = viewport;\r\n        return viewport;\r\n    }\r\n\r\n    /**\r\n     * Get the region this camera covers.\r\n     * @returns {Rectangle} region this camera covers.\r\n     */\r\n    getRegion()\r\n    {\r\n        return this._region.clone();\r\n    }\r\n\r\n    /**\r\n     * Make this camera an orthographic camera with offset.\r\n     * @param {Vector2} offset Camera offset (top-left corner).\r\n     * @param {Boolean} ignoreViewportSize If true, will take the entire canvas size for calculation and ignore the viewport size, if set.\r\n     * @param {Number} near Near clipping plane.\r\n     * @param {Number} far Far clipping plane.\r\n     */\r\n    orthographicOffset(offset, ignoreViewportSize, near, far)\r\n    {\r\n        let renderingSize = (ignoreViewportSize || !this.viewport) ? this._gfx.getCanvasSize() : this.viewport.getSize();\r\n        let region = new Rectangle(offset.x, offset.y, renderingSize.x, renderingSize.y);\r\n        this.orthographic(region, near, far);\r\n    }\r\n\r\n    /**\r\n     * Make this camera an orthographic camera.\r\n     * @param {Rectangle} region Camera left, top, bottom and right. If not set, will take entire canvas.\r\n     * @param {Number} near Near clipping plane.\r\n     * @param {Number} far Far clipping plane.\r\n     */\r\n    orthographic(region, near, far) \r\n    {\r\n        if (region === undefined) {\r\n            region = this._gfx.getRenderingRegion();\r\n        }\r\n        this._region = region;\r\n        this.projection = Matrix.orthographic(region.left, region.right, region.bottom, region.top, near || -1, far || 400);\r\n    }\r\n\r\n    /**\r\n     * Make this camera a perspective camera.\r\n     * @private\r\n     * @param {*} fieldOfView Field of view angle in radians.\r\n     * @param {*} aspectRatio Aspect ratio.\r\n     * @param {*} near Near clipping plane.\r\n     * @param {*} far Far clipping plane.\r\n     */\r\n    _perspective(fieldOfView, aspectRatio, near, far) \r\n    {\r\n        this.projection = Matrix.perspective(fieldOfView || (Math.PI / 2), aspectRatio || 1, near || 0.1, far || 1000)\r\n    }\r\n}\r\n\r\n// export the camera object\r\nmodule.exports = Camera;", "/**\r\n * Define a sprite object.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\sprite.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\nconst TextureAsset = require(\"../assets/texture_asset\");\r\nconst Color = require(\"../utils/color\");\r\nconst Rectangle = require(\"../utils/rectangle\");\r\nconst Vector2 = require(\"../utils/vector2\");\r\nconst Vector3 = require(\"../utils/vector3\");\r\nconst BlendModes = require(\"./blend_modes\");\r\n\r\n/**\r\n * Sprite class.\r\n * This object is a helper class to hold all the properties of a texture to render.\r\n */\r\nclass Sprite\r\n{\r\n    /**\r\n     * Create the texture object.\r\n     * @param {TextureAsset} texture Texture asset.\r\n     * @param {Rectangle | null} sourceRect Optional source rect.\r\n     */\r\n    constructor(texture, sourceRect)\r\n    {\r\n        /**\r\n         * Texture to use for this sprite.\r\n         * @name Sprite#texture\r\n         * @type {TextureAsset}\r\n         */\r\n        this.texture = texture;\r\n        \r\n        /**\r\n         * Sprite position.\r\n         * If Vector3 is provided, the z value will be passed to vertices position in shader code.\r\n         * This property is locked when static=true.\r\n         * @name Sprite#position\r\n         * @type {Vector2|Vector3}\r\n         */\r\n        this.position = new Vector2(0, 0);\r\n\r\n        /**\r\n         * Sprite size.\r\n         * If Vector3 is provided, the z value will be passed to the bottom vertices position in shader code, as position.z + size.z.\r\n         * This property is locked when static=true.\r\n         * @name Sprite#size\r\n         * @type {Vector2|Vector3}\r\n         */\r\n        this.size = new Vector2(texture.width, texture.height);\r\n\r\n        /**\r\n         * Sprite source rectangle in texture.\r\n         * Null will take entire texture.\r\n         * This property is locked when static=true.\r\n         * @name Sprite#sourceRect\r\n         * @type {Rectangle}\r\n         */\r\n        this.sourceRect = sourceRect || null;\r\n        \r\n        /**\r\n         * Sprite blend mode.\r\n         * @name Sprite#blendMode\r\n         * @type {BlendModes}\r\n         */\r\n        this.blendMode = BlendModes.AlphaBlend;\r\n        \r\n        /**\r\n         * Sprite rotation in radians.\r\n         * This property is locked when static=true.\r\n         * @name Sprite#rotation\r\n         * @type {Number}\r\n         */\r\n        this.rotation = 0;\r\n        \r\n        /**\r\n         * Sprite origin point.\r\n         * This property is locked when static=true.\r\n         * @name Sprite#origin\r\n         * @type {Vector2}\r\n         */\r\n        this.origin = new Vector2(0.5, 0.5);\r\n        \r\n        /**\r\n         * Skew the sprite corners on X and Y axis, around the origin point.\r\n         * This property is locked when static=true.\r\n         * @name Sprite#skew\r\n         * @type {Vector2}\r\n         */\r\n        this.skew = new Vector2(0, 0);\r\n        \r\n        /**\r\n         * Sprite color.\r\n         * If array is set, will assign each color to different vertex, starting from top-left.\r\n         * @name Sprite#color\r\n         * @type {Color|Array<Color>}\r\n         */\r\n        this.color = Color.white;\r\n\r\n        /**\r\n         * Is this a static sprite.\r\n         * Static sprites will only calculate vertices properties once, and reuse them in following render calls.\r\n         * This will improve performance, but also means that once the sprite is rendered once, changing things like position, size, rotation, etc.\r\n         * won't affect the output. To refresh the properties of a static sprite, you need to call updateStaticProperties() manually.\r\n         * @name Sprite#static\r\n         * @type {Boolean}\r\n         */\r\n        this.static = false;\r\n    }\r\n\r\n    /**\r\n     * Clone this sprite.\r\n     * @returns {Sprite} cloned sprite.\r\n     */\r\n    clone()\r\n    {\r\n        let ret = new Sprite(this.texture, this.sourceRect);\r\n        ret.position = this.position.clone();\r\n        ret.size = this.size.clone();\r\n        ret.blendMode = this.blendMode;\r\n        ret.rotation = this.rotation;\r\n        ret.origin = this.origin.clone();\r\n        ret.color = this.color.clone();\r\n        ret.static = this.static;\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Manually update the static properties (position, size, rotation, origin, source rectangle, etc.) of a static sprite.\r\n     */\r\n    updateStaticProperties()\r\n    {\r\n        this._cachedVertices = null;\r\n    }\r\n\r\n    /**\r\n     * Check if this sprite is flipped around X axis.\r\n     * This is just a sugarcoat that returns if size.x < 0.\r\n     * @returns {Boolean} If sprite is flipped on X axis.\r\n     */\r\n    get flipX()\r\n    {\r\n        return this.size.x < 0;\r\n    }\r\n\r\n    /**\r\n     * Flip sprite around X axis.\r\n     * This is just a sugarcoat that set size.x to negative or positive value, without changing its scale.\r\n     * @param {Boolean} flip Should we flip the sprite around X axis. If undefined, will take the negative of flipX current value, ie will toggle flipping.\r\n     */\r\n    set flipX(flip)\r\n    {\r\n        if (flip === undefined) flip = !this.flipX;\r\n        this.size.x = Math.abs(this.size.x) * (flip ? -1 : 1);\r\n        return flip;\r\n    }\r\n\r\n    /**\r\n     * Check if this sprite is flipped around y axis.\r\n     * This is just a sugarcoat that returns if size.y < 0.\r\n     * @returns {Boolean} If sprite is flipped on Y axis.\r\n     */\r\n     get flipY()\r\n     {\r\n         return this.size.y < 0;\r\n     }\r\n \r\n     /**\r\n      * Flip sprite around Y axis.\r\n      * This is just a sugarcoat that set size.y to negative or positive value, without changing its scale.\r\n      * @param {Boolean} flip Should we flip the sprite around Y axis. If undefined, will take the negative of flipY current value, ie will toggle flipping.\r\n      */\r\n     set flipY(flip)\r\n     {\r\n         if (flip === undefined) flip = !this.flipY;\r\n         this.size.y = Math.abs(this.size.y) * (flip ? -1 : 1);\r\n         return flip;\r\n     }\r\n}\r\n\r\n// export the sprite class.\r\nmodule.exports = Sprite;", "/**\r\n * Define a sprites group.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\sprites_group.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Color = require(\"../utils/color\");\r\nconst Vector2 = require(\"../utils/vector2\");\r\nconst Matrix = require(\"./matrix\");\r\nconst Sprite = require(\"./sprite\");\r\n\r\n\r\n/**\r\n * Sprites group class.\r\n * This object is a container to hold sprites collection + parent transformations.\r\n * You need SpritesGroup to use batched rendering.\r\n */\r\nclass SpritesGroup\r\n{\r\n    /**\r\n     * Create the group object.\r\n     */\r\n    constructor()\r\n    {\r\n        this._sprites = [];\r\n        this.rotation = 0;\r\n        this.position = new Vector2(0, 0);\r\n        this.scale = new Vector2(1, 1);\r\n    }\r\n\r\n    /**\r\n     * Iterate all sprites.\r\n     * @param {Function} callback Callback to run on all sprites in group.\r\n     */\r\n    forEach(callback)\r\n    {\r\n        this._sprites.forEach(callback);\r\n    }\r\n\r\n    /**\r\n     * Set color for all sprites in group.\r\n     * @param {Color} color Color to set.\r\n     */\r\n    setColor(color)\r\n    {\r\n        for (let i = 0; i < this._sprites.length; ++i) {\r\n            this._sprites[i].color.copy(color);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get group's transformations.\r\n     * @returns {Matrix} Transformations matrix, or null if there's nothing to apply.\r\n     */\r\n    getTransform()\r\n    {\r\n        let matrices = [];\r\n\r\n        if ((this.position.x !== 0) || (this.position.y !== 0)) \r\n        { \r\n            matrices.push(Matrix.translate(this.position.x, this.position.y, 0));\r\n        }\r\n        \r\n        if (this.rotation) \r\n        { \r\n            matrices.push(Matrix.rotateZ(-this.rotation));\r\n        }\r\n        \r\n        if ((this.scale.x !== 1) || (this.scale.y !== 1)) \r\n        { \r\n            matrices.push(Matrix.scale(this.scale.x, this.scale.y));\r\n        }\r\n\r\n        if (matrices.length === 0) { return null };\r\n        if (matrices.length === 1) { return matrices[0]; }\r\n        return Matrix.multiplyMany(matrices);\r\n    }\r\n    \r\n    /**\r\n     * Adds a sprite to group.\r\n     * @param {Sprite} sprite Sprite to add.\r\n     * @returns {Sprite} The newly added sprite.\r\n     */\r\n    add(sprite)\r\n    {\r\n        this._sprites.push(sprite);\r\n        return sprite;\r\n    }\r\n        \r\n    /**\r\n     * Remove a sprite from group.\r\n     * @param {Sprite} sprite Sprite to remove.\r\n     */\r\n    remove(sprite)\r\n    {\r\n        for (let i = 0; i < this._sprites.length; ++i) {\r\n            if (this._sprites[i] === sprite) {\r\n                this._sprites.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Shift first sprite element.\r\n     * @returns {Sprite} The removed sprite.\r\n     */\r\n    shift()\r\n    {\r\n        return this._sprites.shift();\r\n    }\r\n\r\n    /**\r\n     * Sort sprites.\r\n     * @param {Function} compare Comparer method.\r\n     */\r\n    sort(compare)\r\n    {\r\n        this._sprites.sort(compare);\r\n    }\r\n\r\n    /**\r\n     * Sort by texture and blend mode for maximum efficiency in batching.\r\n     * This will change sprites order.\r\n     */\r\n    sortForBatching()\r\n    {\r\n        this._sprites.sort((a,b) => {\r\n            let at = a.texture.url + a.blendMode;\r\n            let bt = b.texture.url + b.blendMode;\r\n            return (at > bt) ? 1 : ((bt > at) ? -1 : 0);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sprites count in group.\r\n     * @returns {Number} Number of sprites in group.\r\n     */\r\n    get count()\r\n    {\r\n        return this._sprites.length;\r\n    }\r\n}\r\n\r\n\r\n// export the sprites group class.\r\nmodule.exports = SpritesGroup;", "/**\r\n * Implement a font texture asset type.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\assets\\font_texture_asset.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Asset = require(\"./asset\");\r\nconst Vector2 = require(\"../utils/vector2\");\r\nconst Rectangle = require(\"../utils/rectangle\");\r\nconst TextureAsset = require(\"./texture_asset\");\r\n\r\n\r\n/**\r\n * A font texture asset, dynamically generated from loaded font and canvas.\r\n * This asset type creates an atlas of all the font's characters as textures, so we can later render them as sprites.\r\n */\r\nclass FontTextureAsset extends Asset\r\n{\r\n    /** @inheritdoc */\r\n    constructor(url)\r\n    {\r\n        super(url);\r\n        this._fontName = null;\r\n        this._fontSize = null;\r\n        this._placeholderChar = null;\r\n        this._sourceRects = null;\r\n        this._texture = null;\r\n        this._lineHeight = 0;\r\n    }\r\n\r\n    /**\r\n     * Get line height.\r\n     */\r\n    get lineHeight()\r\n    {\r\n        return this._lineHeight;\r\n    }\r\n\r\n    /**\r\n     * Get font name.\r\n     */\r\n    get fontName()\r\n    {\r\n        return this._fontName;\r\n    }\r\n\r\n    /**\r\n     * Get font size.\r\n     */\r\n    get fontSize()\r\n    {\r\n        return this._fontSize;\r\n    }\r\n\r\n    /**\r\n     * Get placeholder character.\r\n     */\r\n    get placeholderCharacter()\r\n    {\r\n        return this._placeholderChar;\r\n    }\r\n\r\n    /**\r\n     * Get the texture.\r\n     */\r\n    get texture()\r\n    {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Generate the font texture from a font found in given URL.\r\n     * @param {*} params Additional params. Possible values are:\r\n     *                      - fontName: mandatory font name. on some browsers if the font name does not match the font you actually load via the URL, it will not be loaded properly.\r\n     *                      - missingCharPlaceholder (default='?'): character to use for missing characters.\r\n     *                      - smoothFont (default=true): if true, will set font to smooth mode.\r\n     *                      - fontSize (default=52): font size in texture. larget font size will take more memory, but allow for sharper text rendering in larger scales.\r\n     *                      - enforceTexturePowerOfTwo (default=true): if true, will force texture size to be power of two.\r\n     *                      - maxTextureWidth (default=1024): max texture width.\r\n     *                      - charactersSet (default=FontTextureAsset.defaultCharactersSet): which characters to set in the texture.\r\n     *                      - extraPadding (default=0,0): Optional extra padding to add around characters in texture.\r\n     * @returns {Promise} Promise to resolve when fully loaded.\r\n     */\r\n    load(params)\r\n    {\r\n        return new Promise(async (resolve, reject) => {\r\n            \r\n            if (!params || !params.fontName) {\r\n                return reject(\"When loading font texture you must provide params with a 'fontName' value!\");\r\n            }\r\n        \r\n            // set default missing char placeholder + store it\r\n            this._placeholderChar = (params.missingCharPlaceholder || '?')[0];\r\n    \r\n            // set smoothing mode\r\n            let smooth = params.smoothFont === undefined ? true : params.smoothFont;\r\n\r\n            // set extra margins\r\n            let extraPadding = params.extraPadding || {x: 0, y: 0};\r\n    \r\n            // set max texture size\r\n            let maxTextureWidth = params.maxTextureWidth || 1024;\r\n    \r\n            // default chars set\r\n            let charsSet = params.charactersSet || FontTextureAsset.defaultCharactersSet;\r\n    \r\n            // make sure charSet got the placeholder char\r\n            if (charsSet.indexOf(this._placeholderChar) === -1) {\r\n                charsSet += this._placeholderChar;\r\n            }\r\n    \r\n            // load font\r\n            let fontFace = new FontFace(params.fontName, `url(${this.url})`);\r\n            await fontFace.load();\r\n            document.fonts.add(fontFace);\r\n            \r\n            // store font name and size\r\n            this._fontName = params.fontName;\r\n            this._fontSize = params.fontSize || 52;\r\n            let margin = {x: 10, y: 5};\r\n\r\n            // measure font height\r\n            let fontFullName = this.fontSize.toString() + 'px ' + this.fontName;\r\n            let fontHeight = measureTextHeight(this.fontName, this.fontSize, undefined, extraPadding.y);\r\n            let fontWidth = measureTextWidth(this.fontName, this.fontSize, undefined, extraPadding.x);\r\n\r\n            // set line height\r\n            this._lineHeight = fontHeight;\r\n\r\n            // calc estimated size of a single character in texture\r\n            let estimatedCharSizeInTexture = new Vector2(fontWidth + margin.x * 2, fontHeight + margin.y * 2);\r\n\r\n            // calc texture size\r\n            let charsPerRow = Math.floor(maxTextureWidth / estimatedCharSizeInTexture.x);\r\n            let textureWidth = Math.min(charsSet.length * estimatedCharSizeInTexture.x, maxTextureWidth);\r\n            let textureHeight = Math.ceil(charsSet.length / charsPerRow) * (estimatedCharSizeInTexture.y);\r\n\r\n            // make width and height powers of two\r\n            if (params.enforceTexturePowerOfTwo || params.enforceTexturePowerOfTwo === undefined) {\r\n                textureWidth = makePowerTwo(textureWidth);\r\n                textureHeight = makePowerTwo(textureHeight);\r\n            }\r\n\r\n            // a dictionary to store the source rect of every character\r\n            this._sourceRects = {};\r\n\r\n            // create a canvas to generate the texture on\r\n            let canvas = document.createElement('canvas');\r\n            canvas.width = textureWidth;\r\n            canvas.height = textureHeight;\r\n            if (!smooth) {\r\n                canvas.style.webkitFontSmoothing = \"none\";\r\n                canvas.style.fontSmooth = \"never\";\r\n                canvas.style.textRendering = \"geometricPrecision\";\r\n            }\r\n            let ctx = canvas.getContext('2d');\r\n\r\n            // set font and white color\r\n            ctx.font = fontFullName;\r\n            ctx.fillStyle = '#ffffffff';\r\n            ctx.imageSmoothingEnabled = smooth;\r\n\r\n            // draw the font texture\r\n            let x = 0; let y = 0;\r\n            for (let i = 0; i < charsSet.length; ++i) {\r\n                \r\n                // get actual width of current character\r\n                let currChar = charsSet[i];\r\n                let currCharWidth = Math.ceil(ctx.measureText(currChar).width + extraPadding.x);\r\n\r\n                // check if need to break line down in texture\r\n                if (x + currCharWidth > textureWidth) {\r\n                    y += Math.round(fontHeight + margin.y);\r\n                    x = 0;\r\n                }\r\n\r\n                // calc source rect\r\n                let sourceRect = new Rectangle(x, y + Math.round(fontHeight / 4), currCharWidth, fontHeight);\r\n                this._sourceRects[currChar] = sourceRect;\r\n\r\n                // draw character\r\n                ctx.fillText(currChar, x, y + fontHeight);\r\n\r\n                // move to next spot in texture\r\n                x += Math.round(currCharWidth + margin.x);\r\n            }\r\n                    \r\n            // do threshold effect\r\n            if (!smooth) {\r\n                let imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n                let data = imageData.data;\r\n                for (let i = 0; i < data.length; i += 4) {\r\n                    if (data[i+3] > 0 && (data[i+3] < 255 || data[i] < 255 || data[i+1] < 255 || data[i+2] < 255)) {\r\n                        data[i + 3] = 0;\r\n                    }\r\n                }\r\n                ctx.putImageData(imageData, 0, 0);\r\n            }\r\n\r\n            // convert canvas to image\r\n            let img = new Image();\r\n            img.src = canvas.toDataURL(\"image/png\");\r\n            img.onload = () => {\r\n\r\n                // convert image to texture\r\n                let texture = new TextureAsset(this.url + '__font-texture');\r\n                texture.fromImage(img);\r\n\r\n                // success!\r\n                this._texture = texture;\r\n                this._notifyReady();\r\n                resolve();\r\n\r\n            };\r\n        });\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    get valid()\r\n    {\r\n        return Boolean(this._texture);\r\n    }\r\n    \r\n    /**\r\n     * Get the source rectangle for a given character in texture.\r\n     * @param {Character} character Character to get source rect for.\r\n     * @returns {Rectangle} Source rectangle for character.\r\n     */\r\n    getSourceRect(character)\r\n    {\r\n        return this._sourceRects[character] || this._sourceRects[this.placeholderCharacter];\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    destroy()\r\n    {\r\n        if (this._texture) this._texture.destroy();\r\n        this._fontName = null;\r\n        this._fontSize = null;\r\n        this._placeholderChar = null;\r\n        this._sourceRects = null;\r\n        this._texture = null;\r\n        this._lineHeight = 0;\r\n    }\r\n}\r\n\r\n// default ascii characters to generate font textures for\r\nFontTextureAsset.defaultCharactersSet = \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u00A0\u00A1\u00A2\u00A3\u00A4\u00A5\u00A6\u00A7\u00A8\u00A9\u00AA\u00AB\u00AC\u00AD\u00AE\u00AF\u00B0\u00B1\u00B2\u00B3\u00B4\u00B5\u00B6\u00B7\u00B8\u00B9\u00BA\u00BB\u00BC\u00BD\u00BE\";\r\n\r\n// return the closest power-of-two value to a given number\r\nfunction makePowerTwo(val)\r\n{\r\n    let ret = 2;\r\n    while (ret < val) {\r\n        if (ret >= val) { return ret; }\r\n        ret = ret * 2;\r\n    }\r\n    return ret;\r\n}\r\n\r\n\r\n/**\r\n * Measure font's actual height.\r\n */\r\nfunction measureTextHeight(fontFamily, fontSize, char, extraHeight) \r\n{\r\n    let text = document.createElement('pre');\r\n    text.style.fontFamily = fontFamily;\r\n    text.style.fontSize = fontSize + \"px\";\r\n    text.style.paddingBottom = text.style.paddingLeft = text.style.paddingTop = text.style.paddingRight = '0px';\r\n    text.style.marginBottom = text.style.marginLeft = text.style.marginTop = text.style.marginRight = '0px';\r\n    text.textContent = char || \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \";\r\n    document.body.appendChild(text);\r\n    let result = text.getBoundingClientRect().height + (extraHeight || 0);\r\n    document.body.removeChild(text);\r\n    return Math.ceil(result);\r\n};\r\n\r\n/**\r\n * Measure font's actual width.\r\n */\r\nfunction measureTextWidth(fontFamily, fontSize, char, extraWidth) \r\n{\r\n    // special case to ignore \\r and \\n when measuring text width\r\n    if (char === '\\n' || char === '\\r') { return 0; }\r\n\r\n    // measure character width\r\n    let canvas = document.createElement(\"canvas\");\r\n    let context = canvas.getContext(\"2d\");\r\n    context.font = fontSize.toString() + 'px ' + fontFamily;\r\n    let result = 0;\r\n    let text = char || \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \";\r\n    for (let i = 0; i < text.length; ++i) {\r\n        result = Math.max(result, context.measureText(text[i]).width + (extraWidth || 0));\r\n    }\r\n    return Math.ceil(result);\r\n};\r\n\r\n// export the asset type.\r\nmodule.exports = FontTextureAsset;", "/**\r\n * Define possible text alignments.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\text_alignment.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n/**\r\n * Possible text alignments.\r\n */\r\nconst TextAlignment = {\r\n\r\n    /**\r\n     * Align text left-to-right.\r\n     */\r\n    Left: \"left\",\r\n\r\n    /**\r\n     * Align text right-to-left.\r\n     */\r\n    Right: \"right\",\r\n\r\n    /**\r\n     * Align text to center.\r\n     */\r\n    Center: \"center\",\r\n};\r\n\r\nObject.freeze(TextAlignment);\r\nmodule.exports = TextAlignment;", "/**\r\n * Implement the gfx sprite batch renderer.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\sprite_batch.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\nconst { Rectangle, Color } = require('../utils');\r\nconst Vector2 = require('../utils/vector2');\r\nconst Vector3 = require('../utils/vector3');\r\nconst BlendModes = require('./blend_modes');\r\nconst Matrix = require('./matrix');\r\nconst Mesh = require('./mesh');\r\nconst _logger = require('../logger.js').getLogger('gfx');\r\n\r\n\r\n/**\r\n * Sprite batch renderer, responsible on drawing a batch of sprites with as little draw calls as possible.\r\n */\r\nclass SpriteBatch\r\n{\r\n    /**\r\n     * Create the spritebatch.\r\n     * @param {Gfx} gfx Gfx manager.\r\n     */\r\n    constructor(gfx)\r\n    {\r\n        this._gfx = gfx;\r\n        this._gl = gfx._gl;\r\n        this._positions = gfx._dynamicBuffers.positionArray;\r\n        this._uvs = gfx._dynamicBuffers.textureArray;\r\n        this._colors = gfx._dynamicBuffers.colorsArray;\r\n        this._positionsBuff = gfx._dynamicBuffers.positionBuffer;\r\n        this._uvsBuff = gfx._dynamicBuffers.textureCoordBuffer;\r\n        this._colorsBuff = gfx._dynamicBuffers.colorsBuffer;\r\n        this._indexBuff = gfx._dynamicBuffers.indexBuffer;\r\n\r\n        /** \r\n         * If true, will floor vertices positions before pushing them to batch.\r\n         */\r\n        this.snapPixels = true;\r\n\r\n        /**\r\n         * If true, will slightly offset texture uv when rotating sprites, to prevent bleeding while using texture atlas.\r\n         */\r\n        this.applyAntiBleeding = true;\r\n    }\r\n\r\n    /**\r\n     * Create and return a new vertex.\r\n     * @param {Vector2} position Vertex position.\r\n     * @param {Vector2} textureCoord Vertex texture coord.\r\n     * @param {Color} color Vertex color.\r\n     * @returns {Vertex} new vertex object.\r\n     */\r\n    vertex(position, textureCoord, color)\r\n    {\r\n        return new Vertex(position, textureCoord, color);\r\n    }\r\n\r\n    /**\r\n     * Get if batch is currently drawing.\r\n     * @returns {Boolean} True if batch is drawing.\r\n     */\r\n    get drawing()\r\n    {\r\n        return this._drawing;\r\n    }\r\n\r\n    /**\r\n     * Start drawing a batch.\r\n     * @param {Effect} effect Effect to use.\r\n     * @param {Matrix} transform Optional transformations to apply on all sprites.\r\n     */\r\n    begin(effect, transform)\r\n    {\r\n        if (this._drawing) {\r\n            _logger.error(\"Start drawing a batch while already drawing a batch!\");\r\n        }\r\n\r\n        if (effect) {\r\n            this._gfx.useEffect(effect);\r\n        }\r\n        this._effect = this._gfx._activeEffect;\r\n        \r\n        this._currBlend = BlendModes.AlphaBlend;\r\n        this._currTexture = null;\r\n        this._currBatchCount = 0;\r\n\r\n        this._transform = transform;\r\n\r\n        this._drawing = true;\r\n    }\r\n\r\n    /**\r\n     * Finish drawing batch (and render whatever left in buffers).\r\n     */\r\n    end()\r\n    {\r\n        if (!this._drawing) {\r\n            _logger.error(\"Stop drawing a batch without starting it first!\");\r\n        }\r\n\r\n        if (this._currBatchCount) {\r\n            this._drawCurrentBatch();\r\n        }\r\n        this._drawing = false;\r\n    }\r\n\r\n    /**\r\n     * Set the currently active texture.\r\n     * @param {Texture} texture Texture to set.\r\n     */\r\n    setTexture(texture)\r\n    {\r\n        if (texture !== this._currTexture) {\r\n            if (this._currBatchCount) {\r\n                this._drawCurrentBatch();\r\n            }\r\n            this._currTexture = texture;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add sprite to batch.\r\n     * Note: changing texture or blend mode may trigger a draw call.\r\n     * @param {Sprite|Array<Sprite>} sprites Sprite or multiple sprites to draw.\r\n     * @param {Boolean} cullOutOfScreen If true, will cull sprites that are not visible.\r\n     */\r\n    draw(sprites, cullOutOfScreen)\r\n    {\r\n        // if single sprite, turn to array\r\n        if (sprites.length === undefined) { sprites = [sprites]; }\r\n\r\n        // get visible region\r\n        let region = cullOutOfScreen ? this._gfx.getRenderingRegion() : null;\r\n\r\n        // get buffers\r\n        let positions = this._positions;\r\n        let uvs = this._uvs;\r\n        let colors = this._colors;\r\n        \r\n        for (let sprite of sprites) {\r\n\r\n            // if texture changed, blend mode changed, or we have too many indices - draw current batch\r\n            if (this._currBatchCount) {\r\n                if ((this._currBatchCount >= this.batchSpritesCount) || \r\n                    (sprite.blendMode !== this._currBlend) || \r\n                    (sprite.texture !== this._currTexture)) {\r\n                    this._drawCurrentBatch();\r\n                }\r\n            }\r\n\r\n            // set texture and blend (used internally when drawing batch)\r\n            this._currTexture = sprite.texture;\r\n            this._currBlend = sprite.blendMode;\r\n\r\n            // set colors batch\r\n            let ci = this._currBatchCount * 4 * 4;\r\n\r\n            // array of colors\r\n            if (sprite.color instanceof Array) {\r\n                let lastColor = sprite.color[0];\r\n                for (let x = 0; x < 4; ++x) {\r\n                    let curr = (sprite.color[x] || lastColor);\r\n                    colors[ci + x*4 + 0] = curr.r;\r\n                    colors[ci + x*4 + 1] = curr.g;\r\n                    colors[ci + x*4 + 2] = curr.b;\r\n                    colors[ci + x*4 + 3] = curr.a;\r\n                    lastColor = curr;\r\n                }\r\n            }\r\n            // single color\r\n            else {\r\n                for (let x = 0; x < 4; ++x) {\r\n                    colors[ci + x*4 + 0] = sprite.color.r;\r\n                    colors[ci + x*4 + 1] = sprite.color.g;\r\n                    colors[ci + x*4 + 2] = sprite.color.b;\r\n                    colors[ci + x*4 + 3] = sprite.color.a;\r\n                }\r\n            }\r\n\r\n            // check if its a static sprite with cached properties. if so, we'll use it.\r\n            if (sprite.static && sprite._cachedVertices) {\r\n\r\n                // get vertices from cache\r\n                let topLeft = sprite._cachedVertices[0];\r\n                let topRight = sprite._cachedVertices[1];\r\n                let bottomLeft = sprite._cachedVertices[2];\r\n                let bottomRight = sprite._cachedVertices[3];\r\n\r\n                // set positions\r\n                let pi = this._currBatchCount * 4 * 3;\r\n                positions[pi+0] = topLeft.position.x;             positions[pi+1] = topLeft.position.y;             positions[pi+2] = topLeft.position.z || 0;\r\n                positions[pi+3] = topRight.position.x;            positions[pi+4] = topRight.position.y;            positions[pi+5] = topRight.position.z || 0;\r\n                positions[pi+6] = bottomLeft.position.x;          positions[pi+7] = bottomLeft.position.y;          positions[pi+8] = bottomLeft.position.z || 0;\r\n                positions[pi+9] = bottomRight.position.x;         positions[pi+10] = bottomRight.position.y;        positions[pi+11] = bottomRight.position.z || 0;\r\n        \r\n                // set uvs\r\n                let uvi = this._currBatchCount * 4 * 2;\r\n                uvs[uvi+0] = topLeft.uv.x;          uvs[uvi+1] = topLeft.uv.y;\r\n                uvs[uvi+2] = bottomRight.uv.x;      uvs[uvi+3] = topLeft.uv.y;\r\n                uvs[uvi+4] = topLeft.uv.x;          uvs[uvi+5] = bottomRight.uv.y;\r\n                uvs[uvi+6] = bottomRight.uv.x;      uvs[uvi+7] = bottomRight.uv.y;\r\n\r\n                // increase sprites count and continue\r\n                this._currBatchCount++;\r\n                continue;\r\n            }\r\n\r\n            // calculate vertices positions\r\n            let sizeX = sprite.size.x;\r\n            let sizeY = sprite.size.y;\r\n            let left = -sizeX * sprite.origin.x;\r\n            let top = -sizeY * sprite.origin.y;\r\n\r\n            // calculate corners\r\n            let topLeft = new Vector2(left, top);\r\n            let topRight = new Vector2(left + sizeX, top);\r\n            let bottomLeft = new Vector2(left, top + sizeY);\r\n            let bottomRight = new Vector2(left + sizeX, top + sizeY);\r\n\r\n            // apply skew\r\n            if (sprite.skew) {\r\n                if (sprite.skew.x) {\r\n                    topLeft.x += sprite.skew.x * sprite.origin.y;\r\n                    topRight.x += sprite.skew.x * sprite.origin.y;\r\n                    bottomLeft.x -= sprite.skew.x * (1 - sprite.origin.y);\r\n                    bottomRight.x -= sprite.skew.x * (1 - sprite.origin.y);\r\n                }\r\n                if (sprite.skew.y) {\r\n                    topLeft.y += sprite.skew.y * sprite.origin.x;\r\n                    bottomLeft.y += sprite.skew.y * sprite.origin.x;\r\n                    topRight.y -= sprite.skew.y * (1 - sprite.origin.x);\r\n                    bottomRight.y -= sprite.skew.y * (1 - sprite.origin.x);\r\n                }\r\n            }\r\n\r\n            // apply rotation\r\n            if (sprite.rotation) {\r\n                let cos = Math.cos(sprite.rotation);\r\n                let sin = Math.sin(sprite.rotation);\r\n                function rotateVec(vector)\r\n                {\r\n                    let x = (vector.x * cos - vector.y * sin);\r\n                    let y = (vector.x * sin + vector.y * cos);\r\n                    vector.set(x, y);\r\n                }\r\n                rotateVec(topLeft);\r\n                rotateVec(topRight);\r\n                rotateVec(bottomLeft);\r\n                rotateVec(bottomRight);\r\n            }\r\n\r\n            // add sprite position\r\n            topLeft.addSelf(sprite.position);\r\n            topRight.addSelf(sprite.position);\r\n            bottomLeft.addSelf(sprite.position);\r\n            bottomRight.addSelf(sprite.position);\r\n\r\n            // snap pixels\r\n            if (this.snapPixels)\r\n            {\r\n                topLeft.floorSelf();\r\n                topRight.floorSelf();\r\n                bottomLeft.floorSelf();\r\n                bottomRight.floorSelf();\r\n            }\r\n\r\n            // optional z position\r\n            let z = sprite.position.z || 0;\r\n            let zDepth = sprite.size.z || 0;\r\n\r\n            // cull out-of-screen sprites\r\n            if (cullOutOfScreen)\r\n            {\r\n                let destRect = Rectangle.fromPoints([topLeft, topRight, bottomLeft, bottomRight]);\r\n                if (!region.collideRect(destRect)) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // update positions buffer\r\n            let pi = this._currBatchCount * 4 * 3;\r\n            positions[pi+0] = topLeft.x;             positions[pi+1] = topLeft.y;             positions[pi+2] = z;\r\n            positions[pi+3] = topRight.x;            positions[pi+4] = topRight.y;            positions[pi+5] = z;\r\n            positions[pi+6] = bottomLeft.x;          positions[pi+7] = bottomLeft.y;          positions[pi+8] = z + zDepth;\r\n            positions[pi+9] = bottomRight.x;         positions[pi+10] = bottomRight.y;        positions[pi+11] = z + zDepth;\r\n\r\n            // set uvs buffer\r\n            let uvi = this._currBatchCount * 4 * 2;\r\n            var uvTl;\r\n            var uvBr;\r\n\r\n            // got source rect, apply uvs\r\n            if (sprite.sourceRect) {\r\n                uvTl = {x: sprite.sourceRect.x / this._currTexture.width, y: sprite.sourceRect.y / this._currTexture.height};\r\n                uvBr = {x: uvTl.x + (sprite.sourceRect.width / this._currTexture.width), y: uvTl.y + (sprite.sourceRect.height / this._currTexture.height)};\r\n                if (sprite.rotation && this.applyAntiBleeding) {\r\n                    let marginX = 0.015 / this._currTexture.width;\r\n                    let marginY = 0.015 / this._currTexture.height;\r\n                    uvTl.x += marginX;\r\n                    uvBr.x -= marginX * 2;\r\n                    uvTl.y += marginY;\r\n                    uvBr.y -= marginY * 2;\r\n                }\r\n                uvs[uvi+0] = uvTl.x;  uvs[uvi+1] = uvTl.y;\r\n                uvs[uvi+2] = uvBr.x;  uvs[uvi+3] = uvTl.y;\r\n                uvs[uvi+4] = uvTl.x;  uvs[uvi+5] = uvBr.y;\r\n                uvs[uvi+6] = uvBr.x;  uvs[uvi+7] = uvBr.y;\r\n            }\r\n            // no source rect, take entire texture\r\n            else {\r\n                uvs[uvi+0] = 0;  uvs[uvi+1] = 0;\r\n                uvs[uvi+2] = 1;  uvs[uvi+3] = 0;\r\n                uvs[uvi+4] = 0;  uvs[uvi+5] = 1;\r\n                uvs[uvi+6] = 1;  uvs[uvi+7] = 1;\r\n            }\r\n\r\n            // set cached vertices\r\n            if (sprite.static) {\r\n                sprite._cachedVertices = [\r\n                    {position: topLeft, uv: uvTl || {x:0, y:0}},\r\n                    {position: topRight},\r\n                    {position: bottomLeft},\r\n                    {position: bottomRight, uv: uvBr || {x:1, y:1}},\r\n                ];\r\n            }\r\n                    \r\n            // increase sprites count\r\n            this._currBatchCount++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Push vertices directly to batch.\r\n     * @param {Array<Vertex>} vertices Vertices to push.\r\n     */\r\n    pushVertices(vertices)\r\n    {\r\n        // sanity\r\n        if (!vertices || vertices.length !== 4) {\r\n            throw new Error(\"Vertices must be array of 4 values!\");\r\n        }\r\n\r\n        // get buffers and offset\r\n        let positions = this._positions;\r\n        let uvs = this._uvs;\r\n        let colors = this._colors;\r\n\r\n        // push colors\r\n        for (let i = 0; i < vertices.length; ++i) \r\n        {\r\n            let vertex = vertices[i];\r\n            let ci = (this._currBatchCount * (4 * 4)) + (i * 4);\r\n            colors[ci + 0] = vertex.color.r;\r\n            colors[ci + 1] = vertex.color.g;\r\n            colors[ci + 2] = vertex.color.b;\r\n            colors[ci + 3] = vertex.color.a;\r\n        }\r\n\r\n        // push positions\r\n        let topLeft = vertices[0].position;\r\n        let topRight = vertices[1].position;\r\n        let bottomLeft = vertices[2].position;\r\n        let bottomRight = vertices[3].position;\r\n        let pi = this._currBatchCount * 4 * 3;\r\n        positions[pi+0] = topLeft.x;             positions[pi+1] = topLeft.y;             positions[pi+2] = topLeft.z || 0;\r\n        positions[pi+3] = topRight.x;            positions[pi+4] = topRight.y;            positions[pi+5] = topRight.z || 0;\r\n        positions[pi+6] = bottomLeft.x;          positions[pi+7] = bottomLeft.y;          positions[pi+8] = bottomLeft.z || 0;\r\n        positions[pi+9] = bottomRight.x;         positions[pi+10] = bottomRight.y;        positions[pi+11] = bottomRight.z || 0;\r\n\r\n        // set texture coords\r\n        let uvi = (this._currBatchCount * (4 * 2));\r\n        uvs[uvi++] = vertices[0].textureCoord.x / this._currTexture.width; \r\n        uvs[uvi++] = vertices[0].textureCoord.y / this._currTexture.height;\r\n        uvs[uvi++] = vertices[1].textureCoord.x / this._currTexture.width; \r\n        uvs[uvi++] = vertices[1].textureCoord.y / this._currTexture.height;\r\n        uvs[uvi++] = vertices[2].textureCoord.x / this._currTexture.width; \r\n        uvs[uvi++] = vertices[2].textureCoord.y / this._currTexture.height;\r\n        uvs[uvi++] = vertices[3].textureCoord.x / this._currTexture.width; \r\n        uvs[uvi++] = vertices[3].textureCoord.y / this._currTexture.height;\r\n\r\n        // increase batch count\r\n        this._currBatchCount++;\r\n    }\r\n\r\n    /**\r\n     * How many sprites we can have in batch, in total.\r\n     */\r\n    get batchSpritesCount()\r\n    {\r\n        return this._gfx.batchSpritesCount;\r\n    }\r\n\r\n    /**\r\n     * Draw current batch.\r\n     * @private\r\n     */\r\n    _drawCurrentBatch()\r\n    {\r\n        // get some members\r\n        let gl = this._gl;\r\n        let transform = this._transform;\r\n        let positionArray = this._positions;\r\n        let textureArray = this._uvs;\r\n        let colorsArray = this._colors;\r\n        let positionBuffer = this._positionsBuff;\r\n        let textureCoordBuffer = this._uvsBuff;\r\n        let colorsBuffer = this._colorsBuff;\r\n        let indexBuffer = this._indexBuff;\r\n\r\n        // some sanity checks\r\n        if (this._effect !== this._gfx._activeEffect) {\r\n            _logger.error(\"Effect changed while drawing batch!\");\r\n        }\r\n\r\n        // set blend mode if needed\r\n        this._gfx._setBlendMode(this._currBlend);\r\n\r\n        // prepare effect and texture\r\n        let mesh = new Mesh(positionBuffer, textureCoordBuffer, colorsBuffer, indexBuffer, this._currBatchCount * 6);\r\n        this._gfx._activeEffect.prepareToDrawBatch(mesh, transform || Matrix.identity);\r\n        this._gfx._setActiveTexture(this._currTexture);\r\n\r\n        // should we slice the arrays?\r\n        let shouldSliceArrays = this._currBatchCount < this.batchSpritesCount / 2;\r\n\r\n        // copy position buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, \r\n            shouldSliceArrays ? positionArray.slice(0, this._currBatchCount * 4 * 3) : positionArray, \r\n            gl.DYNAMIC_DRAW);\r\n\r\n        // copy texture buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, \r\n            shouldSliceArrays ? textureArray.slice(0, this._currBatchCount * 4 * 2) : textureArray, \r\n            gl.DYNAMIC_DRAW);\r\n\r\n        // copy color buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, \r\n            shouldSliceArrays ? colorsArray.slice(0, this._currBatchCount * 4 * 4) : colorsArray, \r\n            gl.DYNAMIC_DRAW);\r\n\r\n        // set indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        this._currIndices = null;\r\n\r\n        // draw elements\r\n        gl.drawElements(gl.TRIANGLES, this._currBatchCount * 6, gl.UNSIGNED_SHORT, 0);\r\n        this._gfx._drawCallsCount++;\r\n        this._gfx._drawQuadsCount += this._currBatchCount;\r\n\r\n        // reset current counter\r\n        this._currBatchCount = 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * A vertex we can push to sprite batch.\r\n */\r\nclass Vertex\r\n{\r\n    /**\r\n     * Create the vertex data.\r\n     * @param {Vector2|Vector3} position Vertex position.\r\n     * @param {Vector2} textureCoord Vertex texture coord (in pixels).\r\n     * @param {Color} color Vertex color (undefined will default to white).\r\n     */\r\n    constructor(position, textureCoord, color)\r\n    {\r\n        this.position = position;\r\n        this.textureCoord = textureCoord;\r\n        this.color = color || Color.white;\r\n    }\r\n}\r\n\r\n\r\n// export the sprite batch class\r\nmodule.exports = SpriteBatch;", "/**\r\n * Implement the gfx manager.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\gfx.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst IManager = require('../manager.js');\r\nconst Color = require('../utils/color.js');\r\nconst BlendModes = require('./blend_modes.js');\r\nconst Rectangle = require('../utils/rectangle.js');\r\nconst { Effect, BasicEffect } = require('./effects');\r\nconst TextureAsset = require('../assets/texture_asset.js');\r\nconst TextureFilterModes = require('./texture_filter_modes.js');\r\nconst TextureWrapModes = require('./texture_wrap_modes.js');\r\nconst MeshGenerator = require('./mesh_generator.js');\r\nconst Matrix = require('./matrix.js');\r\nconst Camera = require('./camera.js');\r\nconst Sprite = require('./sprite.js');\r\nconst SpritesGroup = require('./sprites_group.js');\r\nconst Vector2 = require('../utils/vector2.js');\r\nconst FontTextureAsset = require('../assets/font_texture_asset.js');\r\nconst TextAlignment = require('./text_alignment.js');\r\nconst Mesh = require('./mesh.js');\r\nconst Circle = require('../utils/circle.js');\r\nconst SpriteBatch = require('./sprite_batch.js');\r\nconst Vector3 = require('../utils/vector3.js');\r\nconst _whiteColor = Color.white;\r\nconst _logger = require('../logger.js').getLogger('gfx');\r\n\r\n\r\n/**\r\n * Gfx is the graphics manager. \r\n * Everything related to rendering and managing your game canvas goes here.\r\n * \r\n * To access the Graphics manager you use `Shaku.gfx`. \r\n */\r\nclass Gfx extends IManager\r\n{\r\n    /**\r\n     * Create the manager.\r\n     */\r\n    constructor()\r\n    {\r\n        super();\r\n        this._gl = null;\r\n        this._initSettings = { antialias: true, alpha: true, depth: false, premultipliedAlpha: true, desynchronized: false };\r\n        this._canvas = null;\r\n        this._lastBlendMode = null;\r\n        this._activeEffect = null;\r\n        this._camera = null;\r\n        this._projection = null;\r\n        this._currIndices = null;\r\n        this._dynamicBuffers = null;\r\n        this._fb = null;\r\n        this.builtinEffects = {};\r\n        this.meshes = {};\r\n        this.defaultTextureFilter = TextureFilterModes.Nearest;\r\n        this.defaultTextureWrapMode = TextureWrapModes.Clamp;\r\n        this.whiteTexture = null;\r\n        this._renderTarget = null;\r\n        this._viewport = null;\r\n        this._drawCallsCount = 0;\r\n        this._drawQuadsCount = 0;\r\n        this.spritesBatch = null;\r\n    }\r\n\r\n    /**\r\n     * Get how many sprites we can draw in a single batch.\r\n     * @private\r\n     * @returns {Number} batch max sprites count.\r\n     */\r\n    get batchSpritesCount()\r\n    {\r\n        return 2048;\r\n    }\r\n\r\n    /**\r\n     * Maximum number of vertices we allow when drawing lines.\r\n     * @private\r\n     * @returns {Number} max vertices per lines strip.\r\n     */\r\n    get maxLineSegments()\r\n    {\r\n        return 512;\r\n    }\r\n\r\n    /**\r\n     * Set WebGL init flags (passed as additional params to the getContext() call). \r\n     * You must call this *before* initializing *Shaku*.\r\n     * \r\n     * By default, *Shaku* will init WebGL context with the following flags:\r\n     * - antialias: true.\r\n     * - alpha: true.\r\n     * - depth: false.\r\n     * - premultipliedAlpha: true.\r\n     * - desynchronized: false.\r\n     * @example\r\n     * Shaku.gfx.setContextAttributes({ antialias: true, alpha: false });\r\n     * @param {Dictionary} flags WebGL init flags to set.\r\n     */\r\n    setContextAttributes(flags)\r\n    {\r\n        if (this._gl) { throw new Error(\"Can't call setContextAttributes() after gfx was initialized!\"); }\r\n        this._initSettings = flags;\r\n    }\r\n\r\n    /**\r\n     * Set the canvas element to initialize on.\r\n     * You must call this *before* initializing Shaku. Calling this will prevent Shaku from creating its own canvas.\r\n     * @example\r\n     * Shaku.gfx.setCanvas(document.getElementById('my-canvas')); \r\n     * @param {HTMLCanvasElement} element Canvas element to initialize on.\r\n     */\r\n    setCanvas(element)\r\n    {\r\n        if (this._gl) { throw new Error(\"Can't call setCanvas() after gfx was initialized!\"); }\r\n        this._canvas = element;\r\n    }\r\n\r\n    /**\r\n     * Get the canvas element controlled by the gfx manager.\r\n     * If you didn't provide your own canvas before initialization, you must add this canvas to your document after initializing `Shaku`.\r\n     * @example\r\n     * document.body.appendChild(Shaku.gfx.canvas);\r\n     * @returns {HTMLCanvasElement} Canvas we use for rendering.\r\n     */\r\n    get canvas()\r\n    {\r\n        return this._canvas;\r\n    }\r\n\r\n    /**\r\n     * Get the Effect base class, which is required to implement custom effects.\r\n     * @see Effect\r\n     */\r\n    get Effect()\r\n    {\r\n        return Effect;\r\n    }\r\n\r\n    /**\r\n     * Get the default Effect class, which is required to implement custom effects that inherit and reuse parts from the default effect.\r\n     * @see BasicEffect\r\n     */\r\n    get BasicEffect()\r\n    {\r\n        return BasicEffect;\r\n    }\r\n    \r\n    /**\r\n     * Get the sprite class.\r\n     * @see Sprite\r\n     */\r\n    get Sprite()\r\n    {\r\n        return Sprite;\r\n    }\r\n\r\n    /**\r\n     * Get the sprites group object.\r\n     * @see SpritesGroup\r\n     */\r\n    get SpritesGroup()\r\n    {\r\n        return SpritesGroup;\r\n    }\r\n\r\n    /**\r\n     * Get the matrix object.\r\n     * @see Matrix\r\n     */\r\n    get Matrix()\r\n    {\r\n        return Matrix;\r\n    }\r\n\r\n    /**\r\n     * Get the text alignments options.\r\n     * * Left: align text to the left.\r\n     * * Right: align text to the right.\r\n     * * Center: align text to center.\r\n     * @see TextAlignment\r\n     */\r\n    get TextAlignment()\r\n    {\r\n        return TextAlignment;\r\n    }\r\n\r\n    /**\r\n     * Create and return a new camera instance.\r\n     * @param {Boolean} withViewport If true, will create camera with viewport value equal to canvas' size.\r\n     * @returns {Camera} New camera object.\r\n     */\r\n    createCamera(withViewport)\r\n    {\r\n        let ret = new Camera(this);\r\n        if (withViewport) {\r\n            ret.viewport = this.getRenderingRegion();\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Set default orthographic camera from offset.\r\n     * @param {Vector2} offset Camera top-left corner.\r\n     * @returns {Camera} Camera instance.\r\n     */\r\n    setCameraOrthographic(offset)\r\n    {\r\n        let camera = this.createCamera();\r\n        camera.orthographicOffset(offset);\r\n        this.applyCamera(camera);\r\n        return camera;\r\n    }\r\n    \r\n    /**\r\n     * Create and return an effect instance.\r\n     * @see Effect\r\n     * @param {Class} type Effect class type. Must inherit from Effect base class.\r\n     * @returns {Effect} Effect instance.\r\n     */\r\n    createEffect(type)\r\n    {\r\n        if (!(type.prototype instanceof Effect)) { throw new Error(\"'type' must be a class type that inherits from 'Effect'.\"); }\r\n        let effect = new type();\r\n        effect._build(this._gl);\r\n        return effect;\r\n    }\r\n\r\n    /**\r\n     * Set resolution and canvas to the max size of its parent element or screen.\r\n     * If the canvas is directly under document body, it will take the max size of the page.\r\n     * @param {Boolean} limitToParent if true, will use parent element size. If false, will stretch on entire document.\r\n     * @param {Boolean} allowOddNumbers if true, will permit odd numbers, which could lead to small artefacts when drawing pixel art. If false (default) will round to even numbers.\r\n     */\r\n    maximizeCanvasSize(limitToParent, allowOddNumbers)\r\n    {\r\n        // new width and height\r\n        let width = 0;\r\n        let height = 0;\r\n\r\n        // parent\r\n        if (limitToParent) {\r\n            let parent = this._canvas.parentElement;\r\n            width = parent.clientWidth - this._canvas.offsetLeft;\r\n            height = parent.clientHeight - this._canvas.offsetTop;\r\n        }\r\n        // entire screen\r\n        else {\r\n            width = window.innerWidth;\r\n            height = window.innerHeight;\r\n            this._canvas.style.left = '0px';\r\n            this._canvas.style.top = '0px';\r\n        }\r\n\r\n        // make sure even numbers\r\n        if (!allowOddNumbers) {\r\n            if (width % 2 !== 0) { width++; }\r\n            if (height % 2 !== 0) { height++; }\r\n        }\r\n\r\n        // if changed, set resolution\r\n        if ((this._canvas.width !== width) || (this._canvas.height !== height)) {\r\n            this.setResolution(width, height, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a render target (texture) to render on.\r\n     * @example\r\n     * // create render target\r\n     * let renderTarget = await Shaku.assets.createRenderTarget('_my_render_target', 800, 600);\r\n     * \r\n     * // use render target\r\n     * Shaku.gfx.setRenderTarget(renderTarget);\r\n     * // .. draw some stuff here\r\n     * \r\n     * // reset render target and present it on screen\r\n     * // note the negative height - render targets end up with flipped Y axis\r\n     * Shaku.gfx.setRenderTarget(null);\r\n     * Shaku.gfx.draw(renderTarget, new Shaku.utils.Vector2(screenX / 2, screenY / 2), new Shaku.utils.Vector2(screenX, -screenY));\r\n     * @param {TextureAsset|Array<TextureAsset>|null} texture Render target texture to set as render target, or null to reset and render back on canvas. Can also be array for multiple targets, which will take layouts 0-15 by their order.\r\n     * @param {Boolean} keepCamera If true, will keep current camera settings. If false (default) will reset camera.\r\n     */\r\n    setRenderTarget(texture, keepCamera)\r\n    {\r\n        // present buffered data\r\n        this.presentBufferedData();\r\n\r\n        // if texture is null, remove any render target\r\n        if (texture === null) {\r\n            this._renderTarget = null;\r\n            //this._gl.drawBuffers([this._gl.BACK]);\r\n            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);\r\n            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, false);\r\n            if (!keepCamera) {\r\n                this.resetCamera();\r\n            }\r\n            return;\r\n        }\r\n\r\n        // convert texture to array\r\n        if (!(texture instanceof Array)) {\r\n            texture = [texture];\r\n        }\r\n\r\n        // bind the framebuffer\r\n        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb);\r\n        this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, false);\r\n        \r\n        // set render targets\r\n        var drawBuffers = [];\r\n        for (let index = 0; index < texture.length; ++index) {\r\n            \r\n            // attach the texture as the first color attachment\r\n            const attachmentPoint = this._gl['COLOR_ATTACHMENT' + index];\r\n            this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, attachmentPoint, this._gl.TEXTURE_2D, texture[index].texture, 0);\r\n\r\n            // index 0 is the \"main\" render target\r\n            if (index === 0) {\r\n                this._renderTarget = texture[index];\r\n            }\r\n\r\n            // to set drawBuffers in the end\r\n            drawBuffers.push(attachmentPoint);\r\n        }\r\n\r\n        // set draw buffers\r\n        this._gl.drawBuffers(drawBuffers);\r\n\r\n        // unbind frame buffer\r\n        //this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);\r\n\r\n        // reset camera\r\n        if (!keepCamera) {\r\n            this.resetCamera();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set effect to use for future draw calls.\r\n     * @example\r\n     * let effect = Shaku.gfx.createEffect(MyEffectType);\r\n     * Shaku.gfx.useEffect(effect);\r\n     * @param {Effect} effect Effect to use or null to use the basic builtin effect.\r\n     */\r\n    useEffect(effect)\r\n    {\r\n        // present buffered data\r\n        this.presentBufferedData();\r\n\r\n        // if null, use default\r\n        if (effect === null) {\r\n            this.useEffect(this.builtinEffects.Basic);\r\n            return;\r\n        }\r\n\r\n        // same effect? skip\r\n        if (this._activeEffect === effect) {\r\n            return;\r\n        }\r\n\r\n        // set effect\r\n        effect.setAsActive();\r\n        this._activeEffect = effect;\r\n        if (this._projection) { this._activeEffect.setProjectionMatrix(this._projection); }\r\n    }\r\n\r\n    /**\r\n     * Set resolution and canvas size.\r\n     * @example\r\n     * // set resolution and size of 800x600.\r\n     * Shaku.gfx.setResolution(800, 600, true);\r\n     * @param {Number} width Resolution width.\r\n     * @param {Number} height Resolution height.\r\n     * @param {Boolean} updateCanvasStyle If true, will also update the canvas *css* size in pixels.\r\n     */\r\n    setResolution(width, height, updateCanvasStyle)\r\n    {\r\n        this.presentBufferedData();\r\n\r\n        this._canvas.width = width;\r\n        this._canvas.height = height;\r\n\r\n        if (width % 2 !== 0 || height % 2 !== 0) {\r\n            _logger.warn(\"Resolution to set is not even numbers; This might cause minor artefacts when using texture atlases. Consider using even numbers instead.\");\r\n        }\r\n        \r\n        if (updateCanvasStyle) {\r\n            this._canvas.style.width = width + 'px';\r\n            this._canvas.style.height = height + 'px';\r\n        }\r\n\r\n        this._gl.viewport(0, 0, width, height);\r\n        this.resetCamera();\r\n    }\r\n\r\n    /**\r\n     * Reset camera properties to default camera.\r\n     */\r\n    resetCamera()\r\n    {\r\n        this._camera = this.createCamera();\r\n        let size = this.getRenderingSize();\r\n        this._camera.orthographic(new Rectangle(0, 0, size.x, size.y));\r\n        this.applyCamera(this._camera);\r\n    }\r\n\r\n    /**\r\n     * Set viewport, projection and other properties from a camera instance.\r\n     * Changing the camera properties after calling this method will *not* update the renderer, until you call applyCamera again.\r\n     * @param {Camera} camera Camera to apply.\r\n     */\r\n    applyCamera(camera)\r\n    {\r\n        this.presentBufferedData();\r\n        this._viewport = camera.viewport;\r\n        let viewport = this.getRenderingRegion(true);\r\n        this._gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);\r\n        this._projection = camera.projection.clone();\r\n        if (this._activeEffect) { this._activeEffect.setProjectionMatrix(this._projection); }\r\n    }\r\n\r\n    /**\r\n     * Get current rendering region.\r\n     * @param {Boolean} includeOffset If true (default) will include viewport offset, if exists.\r\n     * @returns {Rectangle} Rectangle with rendering region.\r\n     */\r\n    getRenderingRegion(includeOffset)\r\n    {\r\n        if (this._viewport) {\r\n            let ret = this._viewport.clone();\r\n            if (includeOffset === false) {\r\n                ret.x = ret.y = 0;\r\n            }\r\n            return ret;\r\n        }\r\n        return new Rectangle(0, 0, (this._renderTarget || this._canvas).width, (this._renderTarget || this._canvas).height);\r\n    }\r\n\r\n    /**\r\n     * Get current rendering size.\r\n     * Unlike 'canvasSize', this takes viewport and render target into consideration.\r\n     * @returns {Vector2} rendering size.\r\n     */\r\n    getRenderingSize()\r\n    {\r\n        let region = this.getRenderingRegion();\r\n        return region.getSize();\r\n    }\r\n    \r\n    /**\r\n     * Get canvas size as vector.\r\n     * @returns {Vector2} Canvas size.\r\n     */\r\n    getCanvasSize()\r\n    {\r\n        return new Vector2(this._canvas.width, this._canvas.height);\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc\r\n     * @private\r\n     */\r\n    setup()\r\n    {        \r\n        return new Promise(async (resolve, reject) => {  \r\n\r\n            _logger.info(\"Setup gfx manager..\");\r\n\r\n            // if no canvas is set, create one\r\n            if (!this._canvas) {\r\n                this._canvas = document.createElement('canvas');\r\n            }\r\n\r\n            // get gl context\r\n            this._gl = this._canvas.getContext('webgl2', this._initSettings) || this._canvas.getContext('webgl', this._initSettings);\r\n            if (!this._gl) {\r\n                _logger.error(\"Can't get WebGL context!\");\r\n                return reject(\"Failed to get WebGL context from canvas!\");\r\n            }\r\n\r\n            // create default effects\r\n            this.builtinEffects.Basic = this.createEffect(BasicEffect);\r\n\r\n            // setup textures assets gl context\r\n            TextureAsset._setWebGl(this._gl);\r\n\r\n            // create framebuffer (used for render targets)\r\n            this._fb = this._gl.createFramebuffer();\r\n\r\n            // create base meshes\r\n            let _meshGenerator = new MeshGenerator(this._gl);\r\n            this.meshes = {\r\n                quad: _meshGenerator.quad()\r\n            }\r\n            Object.freeze(this.meshes);\r\n\r\n            // create a useful single white pixel texture\r\n            let whitePixelImage = new Image();\r\n            whitePixelImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=';\r\n            await new Promise((resolve, reject) => { whitePixelImage.onload = resolve; });\r\n            this.whiteTexture = new TextureAsset('__runtime_white_pixel__');\r\n            this.whiteTexture.fromImage(whitePixelImage);\r\n\r\n            // dynamic buffers, used for batch rendering\r\n            this._dynamicBuffers = {\r\n                \r\n                positionBuffer: this._gl.createBuffer(),\r\n                positionArray: new Float32Array(3 * 4 * this.batchSpritesCount),\r\n\r\n                textureCoordBuffer: this._gl.createBuffer(),\r\n                textureArray: new Float32Array(2 * 4 * this.batchSpritesCount),\r\n\r\n                colorsBuffer: this._gl.createBuffer(),\r\n                colorsArray: new Float32Array(4 * 4 * this.batchSpritesCount),\r\n\r\n                indexBuffer: this._gl.createBuffer(),\r\n\r\n                linesIndexBuffer: this._gl.createBuffer(),\r\n            }\r\n\r\n            // create the indices buffer for batching\r\n            let indices = new Uint16Array(this.batchSpritesCount * 6); // 6 = number of indices per sprite\r\n            let inc = 0;\r\n            for(let i = 0; i < indices.length; i += 6) {\r\n                \r\n                indices[i] = inc;\r\n                indices[i+1] = inc + 1;\r\n                indices[i+2] = inc + 2;\r\n\r\n                indices[i+3] = inc + 1;\r\n                indices[i+4] = inc + 3;\r\n                indices[i+5] = inc + 2;\r\n\r\n                inc += 4;\r\n            }\r\n            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._dynamicBuffers.indexBuffer);\r\n            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, indices, this._gl.STATIC_DRAW);\r\n\r\n            // create the indices buffer for drawing lines\r\n            let lineIndices = new Uint16Array(this.maxLineSegments);\r\n            for (let i = 0; i < lineIndices.length; i += 6) {          \r\n                lineIndices[i] = i;\r\n            }\r\n            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._dynamicBuffers.linesIndexBuffer);\r\n            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, lineIndices, this._gl.STATIC_DRAW);\r\n            \r\n            // create sprites batch\r\n            this.spritesBatch = new SpriteBatch(this);\r\n\r\n            // use default effect\r\n            this.useEffect(null);\r\n\r\n            // create default camera\r\n            this._camera = this.createCamera();\r\n            this.applyCamera(this._camera);\r\n\r\n            // success!\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generate a sprites group to render a string using a font texture.\r\n     * Take the result of this method and use with gfx.drawGroup() to render the text.\r\n     * This is what you use when you want to draw texts with `Shaku`.\r\n     * Note: its best to always draw texts with *batching* enabled.\r\n     * @example\r\n     * // load font texture\r\n     * let fontTexture = await Shaku.assets.loadFontTexture('assets/DejaVuSansMono.ttf', {fontName: 'DejaVuSansMono'});\r\n     * \r\n     * // generate 'hello world!' text (note: you don't have to regenerate every frame if text didn't change)\r\n     * let text1 = Shaku.gfx.buildText(fontTexture, \"Hello World!\");\r\n     * text1.position.set(40, 40);\r\n     * \r\n     * // draw text\r\n     * Shaku.gfx.drawGroup(text1, true);\r\n     * @param {FontTextureAsset} fontTexture Font texture asset to use.\r\n     * @param {String} text Text to generate sprites for.\r\n     * @param {Number} fontSize Font size, or undefined to use font texture base size.\r\n     * @param {Color|Array<Color>} color Text sprites color. If array is set, will assign each color to different vertex, starting from top-left.\r\n     * @param {TextAlignment} alignment Text alignment.\r\n     * @param {Vector2} offset Optional starting offset.\r\n     * @param {Vector2} marginFactor Optional factor for characters and line spacing. For example value of 2,1 will make double horizontal spacing. \r\n     * @returns {SpritesGroup} Sprites group containing the needed sprites to draw the given text with its properties.\r\n     */\r\n    buildText(fontTexture, text, fontSize, color, alignment, offset, marginFactor)\r\n    {\r\n        // make sure text is a string\r\n        if (typeof text !== 'string') {\r\n            text = '' + text;\r\n        }\r\n\r\n        // sanity\r\n        if (!fontTexture || !fontTexture.valid) {\r\n            throw new Error(\"Font texture is invalid!\");\r\n        }\r\n\r\n        // default alignment\r\n        alignment = alignment || TextAlignment.Left;\r\n\r\n        // default color\r\n        color = color || Color.black;\r\n\r\n        // default font size\r\n        fontSize = fontSize || fontTexture.fontSize;\r\n\r\n        // default margin factor\r\n        marginFactor = marginFactor || Vector2.one;\r\n\r\n        // get character scale factor\r\n        let scale = fontSize / fontTexture.fontSize;\r\n\r\n        // current character offset\r\n        let position = new Vector2(0, 0);\r\n\r\n        // current line characters and width\r\n        let currentLineSprites = [];\r\n        let lineWidth = 0;\r\n\r\n        // go line down\r\n        function breakLine()\r\n        {\r\n            // add offset to update based on alignment\r\n            let offsetX = 0;\r\n            switch (alignment) {\r\n\r\n                case TextAlignment.Right:\r\n                    offsetX = -lineWidth;\r\n                    break;\r\n\r\n                case TextAlignment.Center:\r\n                    offsetX = -lineWidth / 2;\r\n                    break;\r\n\r\n            }\r\n\r\n            // if we need to shift characters for alignment, do it\r\n            if (offsetX != 0) {\r\n                for (let i = 0; i < currentLineSprites.length; ++i) {\r\n                    currentLineSprites[i].position.x += offsetX;\r\n                }\r\n            }\r\n\r\n            // update offset\r\n            position.x = 0;\r\n            position.y += fontTexture.lineHeight * scale * marginFactor.y;\r\n\r\n            // reset line width and sprites\r\n            currentLineSprites = [];\r\n            lineWidth = 0;\r\n        }\r\n\r\n        // create group to return and build sprites\r\n        let ret = new SpritesGroup();\r\n        for (let i = 0; i < text.length; ++i) \r\n        {\r\n            // get character and source rect\r\n            let character = text[i];\r\n            let sourceRect = fontTexture.getSourceRect(character);\r\n\r\n            // special case - break line\r\n            if (character === '\\n') {\r\n                breakLine();\r\n                continue;\r\n            }\r\n\r\n            // calculate character size\r\n            let size = new Vector2(sourceRect.width * scale, sourceRect.height * scale);\r\n\r\n            // create sprite (unless its space)\r\n            if (character !== ' ') {\r\n\r\n                // create sprite and add to group\r\n                let sprite = new Sprite(fontTexture.texture, sourceRect);\r\n                sprite.size = size;\r\n                sprite.position.copy(position);\r\n                if (color instanceof Color) {\r\n                    sprite.color.copy(color);\r\n                }\r\n                else {\r\n                    sprite.color = [];\r\n                    for (let col of color) {\r\n                        sprite.color.push(col.clone());\r\n                    }\r\n                }\r\n                sprite.origin.x = 0;\r\n                ret.add(sprite);\r\n\r\n                // add to current line sprites\r\n                currentLineSprites.push(sprite);\r\n            }\r\n\r\n            // update current line width\r\n            lineWidth += size.x * marginFactor.x;\r\n\r\n            // set position for next character\r\n            position.x += size.x * marginFactor.x;\r\n        }\r\n\r\n        // call break line on last line, to adjust alignment for last line\r\n        breakLine();\r\n\r\n        // set position\r\n        if (offset) {\r\n            ret.position.set(offset.x, offset.y);\r\n        }\r\n\r\n        // return group\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Draw a SpritesGroup object. \r\n     * A SpritesGroup is a collection of sprites we can draw in bulks with transformations to apply on the entire group.\r\n     * @example\r\n     * // load texture\r\n     * let texture = await Shaku.assets.loadTexture('assets/sprite.png');\r\n     * \r\n     * // create group and set entire group's position and scale\r\n     * let group = new Shaku.gfx.SpritesGroup();\r\n     * group.position.set(125, 300);\r\n     * group.scale.set(2, 2);\r\n     *\r\n     * // create 5 sprites and add to group\r\n     * for (let i = 0; i < 5; ++i) {\r\n     *   let sprite = new Shaku.gfx.Sprite(texture);\r\n     *   sprite.position.set(100 * i, 150);\r\n     *   sprite.size.set(50, 50);\r\n     *   group.add(sprite)\r\n     * }\r\n     * \r\n     * // draw the group with automatic culling of invisible sprites\r\n     * Shaku.gfx.drawGroup(group, true);\r\n     * @param {SpritesGroup} group Sprites group to draw.\r\n     * @param {Boolean} cullOutOfScreen If true and in batching mode, will cull automatically any quad that is completely out of screen.\r\n     */\r\n    drawGroup(group, cullOutOfScreen)\r\n    {\r\n        this._drawBatch(group, Boolean(cullOutOfScreen));\r\n    }\r\n\r\n    /**\r\n     * Draw a single sprite object.\r\n     * Sprites are optional objects that store all the parameters for a `draw()` call. They are also used for batch rendering.\r\n     * @example\r\n     * // load texture and create sprite\r\n     * let texture = await Shaku.assets.loadTexture('assets/sprite.png');\r\n     * let sprite = new Shaku.gfx.Sprite(texture);\r\n     * \r\n     * // set position and size\r\n     * sprite.position.set(100, 150);\r\n     * sprite.size.set(50, 50);\r\n     * \r\n     * // draw sprite\r\n     * Shaku.gfx.drawSprite(sprite);\r\n     * @param {Sprite} sprite Sprite object to draw.\r\n     */\r\n    drawSprite(sprite)\r\n    {\r\n        if (!sprite.texture || !sprite.texture.valid) { return; }\r\n        this.__startDrawingSprites(this._activeEffect, null);\r\n        this.spritesBatch.draw(sprite);\r\n    }\r\n\r\n    /**\r\n     * Draw a texture to cover a given destination rectangle.\r\n     * @example\r\n     * // cover the entire screen with an image\r\n     * let texture = await Shaku.assets.loadTexture('assets/sprite.png');\r\n     * Shaku.gfx.cover(texture, Shaku.gfx.getRenderingRegion());\r\n     * @example\r\n     * // draw with additional params\r\n     * let sourceRect = new Shaku.utils.Rectangle(0, 0, 64, 64);\r\n     * let color = Shaku.utils.Color.blue;\r\n     * let blendMode = Shaku.gfx.BlendModes.Multiply;\r\n     * let rotation = Math.PI / 4;\r\n     * let origin = new Shaku.utils.Vector2(0.5, 0.5);\r\n     * Shaku.gfx.draw(texture, position, size, sourceRect, color, blendMode, rotation, origin);\r\n     * @param {TextureAsset} texture Texture to draw.\r\n     * @param {Rectangle|Vector2} destRect Destination rectangle to draw on. If vector is provided, will draw from 0,0 with vector as size.\r\n     * @param {Rectangle} sourceRect Source rectangle, or undefined to use the entire texture.\r\n     * @param {Color|Array<Color>} color Tint color, or undefined to not change color. If array is set, will assign each color to different vertex, starting from top-left.\r\n     * @param {BlendModes} blendMode Blend mode, or undefined to use alpha blend.\r\n     */\r\n    cover(texture, destRect, sourceRect, color, blendMode)\r\n    {\r\n        if ((destRect instanceof Vector2) || (destRect instanceof Vector3)) {\r\n            destRect = new Rectangle(0, 0, destRect.x, destRect.y);\r\n        }\r\n        return this.draw(texture, destRect.getCenter(), destRect.getSize(), sourceRect, color, blendMode);\r\n    }\r\n\r\n    /**\r\n     * Draw a texture.\r\n     * @example\r\n     * // a simple draw with position and size\r\n     * let texture = await Shaku.assets.loadTexture('assets/sprite.png');\r\n     * let position = new Shaku.utils.Vector2(100, 100);\r\n     * let size = new Shaku.utils.Vector2(75, 125); // if width == height, you can pass as a number instead of vector\r\n     * Shaku.gfx.draw(texture, position, size);\r\n     * @example\r\n     * // draw with additional params\r\n     * let sourceRect = new Shaku.utils.Rectangle(0, 0, 64, 64);\r\n     * let color = Shaku.utils.Color.blue;\r\n     * let blendMode = Shaku.gfx.BlendModes.Multiply;\r\n     * let rotation = Math.PI / 4;\r\n     * let origin = new Shaku.utils.Vector2(0.5, 0.5);\r\n     * Shaku.gfx.draw(texture, position, size, sourceRect, color, blendMode, rotation, origin);\r\n     * @param {TextureAsset} texture Texture to draw.\r\n     * @param {Vector2|Vector3} position Drawing position (at origin). If vector3 is provided, will pass z value to the shader code position attribute.\r\n     * @param {Vector2|Vector3|Number} size Drawing size. If vector3 is provided, will pass z value to the shader code position attribute for the bottom vertices, as position.z + size.z.\r\n     * @param {Rectangle} sourceRect Source rectangle, or undefined to use the entire texture.\r\n     * @param {Color|Array<Color>} color Tint color, or undefined to not change color. If array is set, will assign each color to different vertex, starting from top-left.\r\n     * @param {BlendModes} blendMode Blend mode, or undefined to use alpha blend.\r\n     * @param {Number} rotation Rotate sprite.\r\n     * @param {Vector2} origin Drawing origin. This will be the point at 'position' and rotation origin.\r\n     * @param {Vector2} skew Skew the drawing corners on X and Y axis, around the origin point.\r\n     */\r\n    draw(texture, position, size, sourceRect, color, blendMode, rotation, origin, skew)\r\n    {\r\n        let sprite = new Sprite(texture, sourceRect);\r\n        sprite.position = position;\r\n        sprite.size = (typeof size === 'number') ? new Vector2(size, size) : size;\r\n        if (color) { sprite.color = color; }\r\n        if (blendMode) { sprite.blendMode = blendMode; }\r\n        if (rotation !== undefined) { sprite.rotation = rotation; }\r\n        if (origin) { sprite.origin = origin; }\r\n        if (skew) { sprite.skew = skew; }\r\n        this.drawSprite(sprite);\r\n    }\r\n\r\n    /**\r\n     * Draw a filled colored rectangle.\r\n     * @example\r\n     * // draw a 50x50 red rectangle at position 100x100, that will rotate over time\r\n     * Shaku.gfx.fillRect(new Shaku.utils.Rectangle(100, 100, 50, 50), Shaku.utils.Color.red, null, Shaku.gameTime.elapsed);\r\n     * @param {Rectangle} destRect Rectangle to fill.\r\n     * @param {Color|Array<Color>} color Rectangle fill color.\r\n     * @param {BlendModes} blend Blend mode.\r\n     * @param {Number} rotation Rotate the rectangle around its center.\r\n     */\r\n    fillRect(destRect, color, blend, rotation)\r\n    {\r\n        this.draw(this.whiteTexture, \r\n            new Vector2(destRect.x + destRect.width / 2, destRect.y + destRect.height / 2),\r\n            new Vector2(destRect.width, destRect.height), null, color, blend || BlendModes.Opaque, rotation, null, null);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of filled colored rectangles as a batch.\r\n     * @example\r\n     * // draw a 50x50 red rectangle at position 100x100, that will rotate over time\r\n     * Shaku.gfx.fillRects([new Shaku.utils.Rectangle(100, 100, 50, 50), new Shaku.utils.Rectangle(150, 150, 25, 25)], Shaku.utils.Color.red, null, Shaku.gameTime.elapsed);\r\n     * @param {Array<Rectangle>} destRects Rectangles to fill.\r\n     * @param {Array<Color>|Color} colors Rectangles fill color. If array is set, will assign each color to different vertex, starting from top-left.\r\n     * @param {BlendModes} blend Blend mode.\r\n     * @param {Array<Number>|Number} rotation Rotate the rectangles around its center.\r\n     */\r\n    fillRects(destRects, colors, blend, rotation)\r\n    {\r\n        // build group\r\n        if (rotation === undefined) { rotation = 0; }\r\n        let group = new SpritesGroup();\r\n        for (let i = 0; i < destRects.length; ++i) {\r\n            let sprite = new Sprite(this.whiteTexture);\r\n            sprite.color = colors[i] || colors;\r\n            sprite.rotation = rotation.length ? rotation[i] : rotation;\r\n            sprite.blendMode = blend || BlendModes.Opaque;\r\n            let destRect = destRects[i];\r\n            sprite.size.set(destRect.width, destRect.height);\r\n            sprite.position.set(destRect.x + destRect.width / 2, destRect.y + destRect.width / 2);\r\n            sprite.origin.set(0.5, 0.5);\r\n            group.add(sprite);\r\n        }\r\n\r\n        // draw group\r\n        this.drawGroup(group);\r\n    }\r\n\r\n    /**\r\n     * Draw an outline colored rectangle.\r\n     * @example\r\n     * // draw a 50x50 red rectangle at position 100x100, that will rotate over time\r\n     * Shaku.gfx.outlineRect(new Shaku.utils.Rectangle(100, 100, 50, 50), Shaku.utils.Color.red, null, Shaku.gameTime.elapsed);\r\n     * @param {Rectangle} destRect Rectangle to draw outline for.\r\n     * @param {Color} color Rectangle outline color.\r\n     * @param {BlendModes} blend Blend mode.\r\n     * @param {Number} rotation Rotate the rectangle around its center.\r\n     */\r\n    outlineRect(destRect, color, blend, rotation)\r\n    {\r\n        // get corners\r\n        let topLeft = destRect.getTopLeft();\r\n        let topRight = destRect.getTopRight();\r\n        let bottomRight = destRect.getBottomRight();\r\n        let bottomLeft = destRect.getBottomLeft();\r\n\r\n        // rotate vertices\r\n        if (rotation) {\r\n\r\n            // center rect\r\n            let center = destRect.getCenter();\r\n            topLeft.subSelf(center);\r\n            topRight.subSelf(center);\r\n            bottomLeft.subSelf(center);\r\n            bottomRight.subSelf(center);\r\n\r\n            // do rotation\r\n            let cos = Math.cos(rotation);\r\n            let sin = Math.sin(rotation);\r\n            function rotateVec(vector)\r\n            {\r\n                let x = (vector.x * cos - vector.y * sin);\r\n                let y = (vector.x * sin + vector.y * cos);\r\n                vector.set(x, y);\r\n            }\r\n            rotateVec(topLeft);\r\n            rotateVec(topRight);\r\n            rotateVec(bottomLeft);\r\n            rotateVec(bottomRight);\r\n\r\n            // return to original position\r\n            topLeft.addSelf(center);\r\n            topRight.addSelf(center);\r\n            bottomLeft.addSelf(center);\r\n            bottomRight.addSelf(center);\r\n        }\r\n        \r\n        // draw rectangle with lines strip\r\n        this.drawLinesStrip([topLeft, topRight, bottomRight, bottomLeft], color, blend, true);\r\n    }\r\n\r\n    /**\r\n     * Draw an outline colored circle.\r\n     * @example\r\n     * // draw a circle at 50x50 with radius of 85\r\n     * Shaku.gfx.outlineCircle(new Shaku.utils.Circle(new Shaku.utils.Vector2(50, 50), 85), Shaku.utils.Color.red);\r\n     * @param {Circle} circle Circle to draw.\r\n     * @param {Color} color Circle outline color.\r\n     * @param {BlendModes} blend Blend mode.\r\n     * @param {Number} lineAmount How many lines to compose the circle from (bigger number = smoother circle).\r\n     */\r\n    outlineCircle(circle, color, blend, lineAmount)\r\n    {\r\n        // defaults\r\n        if (lineAmount === undefined) { lineAmount = 32; }\r\n\r\n        // generate list of lines to draw circle\r\n        let lines = [];\r\n        const twicePi = 2 * Math.PI;\r\n        for (let i = 0; i <= lineAmount; i++) {\r\n            let point = new Vector2(\r\n                circle.center.x + (circle.radius * Math.cos(i * twicePi / lineAmount)), \r\n                circle.center.y + (circle.radius * Math.sin(i * twicePi / lineAmount))\r\n            );\r\n            lines.push(point);\r\n        }\r\n\r\n        // draw lines\r\n        this.drawLinesStrip(lines, color, blend);\r\n    }\r\n\r\n    /**\r\n     * Draw a filled colored circle.\r\n     * @example\r\n     * // draw a filled circle at 50x50 with radius of 85\r\n     * Shaku.gfx.fillCircle(new Shaku.utils.Circle(new Shaku.utils.Vector2(50, 50), 85), Shaku.utils.Color.red);\r\n     * @param {Circle} circle Circle to draw.\r\n     * @param {Color} color Circle fill color.\r\n     * @param {BlendModes} blend Blend mode.\r\n     * @param {Number} lineAmount How many lines to compose the circle from (bigger number = smoother circle).\r\n     */\r\n    fillCircle(circle, color, blend, lineAmount)\r\n    {\r\n        // defaults\r\n        if (lineAmount === undefined) { lineAmount = 32; }\r\n\r\n        // generate list of lines to draw circle\r\n        let lines = [circle.center];\r\n        const twicePi = 2 * Math.PI;\r\n        for (let i = 0; i <= lineAmount; i++) {\r\n            let point = new Vector2(\r\n                circle.center.x + (circle.radius * Math.cos(i * twicePi / lineAmount)), \r\n                circle.center.y + (circle.radius * Math.sin(i * twicePi / lineAmount))\r\n            );\r\n            lines.push(point);\r\n        }\r\n\r\n        // prepare effect and buffers\r\n        let gl = this._gl;\r\n        this._fillShapesBuffer(lines, color, blend, (verts) => {\r\n            gl.drawArrays(gl.TRIANGLE_FAN, 0, verts.length);\r\n            this._drawCallsCount++;\r\n        }, true, 1);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of filled colored circles using batches.\r\n     * @example\r\n     * // draw a filled circle at 50x50 with radius of 85\r\n     * Shaku.gfx.fillCircles([new Shaku.utils.Circle(new Shaku.utils.Vector2(50, 50), 85), new Shaku.utils.Circle(new Shaku.utils.Vector2(150, 125), 35)], Shaku.utils.Color.red);\r\n     * @param {Array<Circle>} circles Circles list to draw.\r\n     * @param {Color|Array<Color>} colors Circles fill color or a single color for all circles.\r\n     * @param {BlendModes} blend Blend mode.\r\n     * @param {Number} lineAmount How many lines to compose the circle from (bigger number = smoother circle).\r\n     */\r\n    fillCircles(circles, colors, blend, lineAmount)\r\n    {\r\n        // defaults\r\n        if (lineAmount === undefined) { lineAmount = 32; }\r\n\r\n        // build vertices and colors arrays\r\n        let vertsArr = [];\r\n        let colorsArr = colors.length ? [] : null;\r\n\r\n        // generate vertices and colors\r\n        for (let i = 0; i < circles.length; ++i) {\r\n\r\n            let circle = circles[i];\r\n            let color = colors[i] || colors;\r\n\r\n            const twicePi = 2 * Math.PI;\r\n            for (let i = 0; i <= lineAmount; i++) {\r\n\r\n                // set vertices\r\n                vertsArr.push(new Vector2(\r\n                    circle.center.x + (circle.radius * Math.cos(i * twicePi / lineAmount)), \r\n                    circle.center.y + (circle.radius * Math.sin(i * twicePi / lineAmount))\r\n                ));\r\n                vertsArr.push(new Vector2(\r\n                    circle.center.x + (circle.radius * Math.cos((i+1) * twicePi / lineAmount)), \r\n                    circle.center.y + (circle.radius * Math.sin((i+1) * twicePi / lineAmount))\r\n                ));\r\n                vertsArr.push(circle.center);\r\n\r\n                // set colors\r\n                if (colorsArr) {\r\n                    colorsArr.push(color);\r\n                    colorsArr.push(color);\r\n                    colorsArr.push(color);\r\n                }\r\n            }\r\n        }\r\n\r\n        // prepare effect and buffers\r\n        let gl = this._gl;\r\n        this._fillShapesBuffer(vertsArr, colorsArr || colors, blend, (verts) => {\r\n            gl.drawArrays(gl.TRIANGLES, 0, verts.length);\r\n            this._drawCallsCount++;\r\n        }, false, 3);\r\n    }\r\n\r\n    /**\r\n     * Draw a single line between two points.\r\n     * @example\r\n     * Shaku.gfx.drawLine(new Shaku.utils.Vector2(50,50), new Shaku.utils.Vector2(150,50), Shaku.utils.Color.red);\r\n     * @param {Vector2} startPoint Line start point.\r\n     * @param {Vector2} endPoint Line end point.\r\n     * @param {Color} color Line color.\r\n     * @param {BlendModes} blendMode Blend mode to draw lines with (default to Opaque).\r\n     */\r\n    drawLine(startPoint, endPoint, color, blendMode)\r\n    {\r\n        return this.drawLines([startPoint, endPoint], color, blendMode, false);\r\n    }\r\n\r\n    /**\r\n     * Draw a strip of lines between an array of points.\r\n     * @example\r\n     * let lines = [new Shaku.utils.Vector2(50,50), new Shaku.utils.Vector2(150,50), new Shaku.utils.Vector2(150,150)];\r\n     * let colors = [Shaku.utils.Color.random(), Shaku.utils.Color.random(), Shaku.utils.Color.random()];\r\n     * Shaku.gfx.drawLinesStrip(lines, colors);\r\n     * @param {Array<Vector2>} points Points to draw line between.\r\n     * @param {Color|Array<Color>} colors Single lines color if you want one color for all lines, or an array of colors per segment.\r\n     * @param {BlendModes} blendMode Blend mode to draw lines with (default to Opaque).\r\n     * @param {Boolean} looped If true, will also draw a line from last point back to first point.\r\n     */\r\n    drawLinesStrip(points, colors, blendMode, looped)\r\n    {\r\n        // prepare effect and buffers\r\n        let gl = this._gl;\r\n\r\n        // do loop - note: we can't use gl.LINE_LOOPED in case we need multiple buffers inside '_fillShapesBuffer' which will invoke more than one draw\r\n        if (looped) {\r\n            points = points.slice(0);\r\n            points.push(points[0]);\r\n            if (colors && colors.length) {\r\n                colors = colors.slice(0);\r\n                colors.push(colors[0]);\r\n            }\r\n        }\r\n\r\n        // draw lines\r\n        this._fillShapesBuffer(points, colors, blendMode, (verts) => {\r\n            gl.drawArrays(gl.LINE_STRIP, 0, verts.length);\r\n            this._drawCallsCount++;\r\n        }, true, 2);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of lines from an array of points.\r\n     * @example\r\n     * let lines = [new Shaku.utils.Vector2(50,50), new Shaku.utils.Vector2(150,50), new Shaku.utils.Vector2(150,150)];\r\n     * let colors = [Shaku.utils.Color.random(), Shaku.utils.Color.random(), Shaku.utils.Color.random()];\r\n     * Shaku.gfx.drawLines(lines, colors);\r\n     * @param {Array<Vector2>} points Points to draw line between.\r\n     * @param {Color|Array<Color>} colors Single lines color if you want one color for all lines, or an array of colors per segment.\r\n     * @param {BlendModes} blendMode Blend mode to draw lines with (default to Opaque).\r\n     */\r\n    drawLines(points, colors, blendMode)\r\n    {\r\n        // prepare effect and buffers\r\n        let gl = this._gl;\r\n        this._fillShapesBuffer(points, colors, blendMode, (verts) => {\r\n            gl.drawArrays(gl.LINES, 0, verts.length);\r\n            this._drawCallsCount++;\r\n        }, true, 2);\r\n    }\r\n\r\n    /**\r\n     * Draw a single point from vector.\r\n     * @example\r\n     * Shaku.gfx.drawPoint(new Shaku.utils.Vector2(50,50), Shaku.utils.Color.random());\r\n     * @param {Vector2} point Point to draw.\r\n     * @param {Color} color Point color.\r\n     * @param {BlendModes} blendMode Blend mode to draw point with (default to Opaque).\r\n     */\r\n    drawPoint(point, color, blendMode)\r\n    {\r\n        return this.drawPoints([point], [color], blendMode);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of points from an array of vectors.\r\n     * @example\r\n     * let points = [new Shaku.utils.Vector2(50,50), new Shaku.utils.Vector2(150,50), new Shaku.utils.Vector2(150,150)];\r\n     * let colors = [Shaku.utils.Color.random(), Shaku.utils.Color.random(), Shaku.utils.Color.random()];\r\n     * Shaku.gfx.drawPoints(points, colors);\r\n     * @param {Array<Vector2>} points Points to draw.\r\n     * @param {Color|Array<Color>} colors Single color if you want one color for all points, or an array of colors per point.\r\n     * @param {BlendModes} blendMode Blend mode to draw points with (default to Opaque).\r\n     */\r\n    drawPoints(points, colors, blendMode)\r\n    {\r\n        let gl = this._gl;\r\n        this._fillShapesBuffer(points, colors, blendMode, (verts) => {\r\n            gl.drawArrays(gl.POINTS, 0, verts.length);\r\n            this._drawCallsCount++;\r\n        }, false, 1);\r\n    }\r\n\r\n    /**\r\n     * Make the renderer canvas centered.\r\n     */\r\n    centerCanvas()\r\n    {\r\n        let canvas = this._canvas;\r\n        let parent = canvas.parentElement;\r\n        let pwidth = Math.min(parent.clientWidth, window.innerWidth);\r\n        let pheight = Math.min(parent.clientHeight, window.innerHeight);\r\n        canvas.style.left = Math.round(pwidth / 2 - canvas.clientWidth / 2) + 'px';\r\n        canvas.style.top = Math.round(pheight / 2 - canvas.clientHeight / 2) + 'px';\r\n        canvas.style.display = 'block';\r\n        canvas.style.position = 'relative';\r\n    }\r\n        \r\n    /**\r\n     * Check if a given shape is currently in screen bounds, not taking camera into consideration.\r\n     * @param {Circle|Vector|Rectangle|Line} shape Shape to check.\r\n     * @returns {Boolean} True if given shape is in visible region.\r\n     */\r\n    inScreen(shape)\r\n    {\r\n        let region = this.getRenderingRegion();\r\n\r\n        if (shape instanceof Circle) {\r\n            return region.collideCircle(shape);\r\n        }\r\n        else if (shape instanceof Vector2) {\r\n            return region.containsVector(shape);\r\n        }\r\n        else if (shape instanceof Rectangle) {\r\n            return region.collideRect(shape);\r\n        }\r\n        else if (shape instanceof Line) {\r\n            return region.collideLine(shape);\r\n        }\r\n        else {\r\n            throw new Error(\"Unknown shape type to check!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Make a given vector the center of the camera.\r\n     * @param {Vector2} position Camera position.\r\n     * @param {Boolean} useCanvasSize If true, will always use cancas size when calculating center. If false and render target is set, will use render target's size.\r\n     */\r\n    centerCamera(position, useCanvasSize)\r\n    {\r\n        let renderSize = useCanvasSize ? this.getCanvasSize() : this.getRenderingSize();\r\n        let halfScreenSize = renderSize.mul(0.5);\r\n        let centeredPos = position.sub(halfScreenSize);\r\n        this.setCameraOrthographic(centeredPos);\r\n    }\r\n        \r\n    /**\r\n     * Prepare buffers, effect and blend mode for shape rendering.\r\n     * @private\r\n     */\r\n    _fillShapesBuffer(points, colors, blendMode, onReady, isStrip, groupsSize)\r\n    {\r\n        // finish whatever we were drawing before\r\n        this.presentBufferedData();\r\n\r\n        // some defaults\r\n        colors = colors || _whiteColor;\r\n        blendMode = blendMode || BlendModes.Opaque;\r\n\r\n        // sanity - make sure colors and vertices match\r\n        if (colors.length !== undefined && colors.length !== points.length) {\r\n            _logger.error(\"When drawing shapes with colors array, the colors array and points array must have the same length!\");\r\n            return;\r\n        }\r\n\r\n        // calculate actual max buffer size\r\n        let maxWithMargin = isStrip ? (this.maxLineSegments-1) : this.maxLineSegments;\r\n        if (groupsSize != 1) {\r\n            while (maxWithMargin % groupsSize !== 0) { maxWithMargin--; }\r\n        }\r\n\r\n        // if we have too many vertices, break to multiple calls\r\n        if (points.length > maxWithMargin) {\r\n            let sliceI = 0;\r\n            while (true) {\r\n                let start = sliceI * maxWithMargin;\r\n                let end = start + maxWithMargin;\r\n                if (isStrip && sliceI > 0) { start--; }\r\n                let subpoints = points.slice(start, end);\r\n                if (subpoints.length === 0) { break; }\r\n                let subcolors = (colors && colors.length) ? colors.slice(start, end) : colors;\r\n                this._fillShapesBuffer(subpoints, subcolors, blendMode, onReady, isStrip, groupsSize);\r\n                sliceI++;\r\n            }\r\n            return;\r\n        }\r\n\r\n       // basic params\r\n       let gl = this._gl;\r\n       let positionsBuff = this._dynamicBuffers.positionArray;\r\n       let colorsBuff = this._dynamicBuffers.colorsArray;\r\n\r\n       for (let i = 0; i < points.length; ++i) {\r\n\r\n           // set positions\r\n           positionsBuff[i*3 + 0] = points[i].x;\r\n           positionsBuff[i*3 + 1] = points[i].y;\r\n           positionsBuff[i*3 + 2] = points[i].z || 0;\r\n           \r\n           // set colors\r\n           let color = colors[i] || colors;\r\n           colorsBuff[i*4 + 0] = color.r;\r\n           colorsBuff[i*4 + 1] = color.g;\r\n           colorsBuff[i*4 + 2] = color.b;\r\n           colorsBuff[i*4 + 3] = color.a;\r\n       }\r\n\r\n       // set blend mode if needed\r\n       this._setBlendMode(blendMode);\r\n\r\n       // prepare effect and texture\r\n       let mesh = new Mesh(this._dynamicBuffers.positionBuffer, null, this._dynamicBuffers.colorsBuffer, this._dynamicBuffers.indexBuffer, points.length);\r\n       this._activeEffect.prepareToDrawBatch(mesh, Matrix.identity);\r\n       this._setActiveTexture(this.whiteTexture);\r\n\r\n       // should we slice the arrays to more optimal size?\r\n       let shouldSliceArrays = points.length <= 8;\r\n\r\n       // copy position buffer\r\n       this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._dynamicBuffers.positionBuffer);\r\n       this._gl.bufferData(this._gl.ARRAY_BUFFER, \r\n           shouldSliceArrays ? this._dynamicBuffers.positionArray.slice(0, points.length * 3) : this._dynamicBuffers.positionArray, \r\n           this._gl.DYNAMIC_DRAW);\r\n\r\n       // copy color buffer\r\n       this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._dynamicBuffers.colorsBuffer);\r\n       this._gl.bufferData(this._gl.ARRAY_BUFFER, \r\n           shouldSliceArrays ? this._dynamicBuffers.colorsArray.slice(0, points.length * 4) : this._dynamicBuffers.colorsArray, \r\n           this._gl.DYNAMIC_DRAW);\r\n\r\n       // set indices\r\n       gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._dynamicBuffers.linesIndexBuffer);\r\n       this._currIndices = null;\r\n\r\n       // invoke the on-ready callback\r\n       onReady(points);\r\n    }\r\n\r\n    /**\r\n     * Draw sprites group as a batch.\r\n     * @private\r\n     * @param {SpritesGroup} group Group to draw.\r\n     * @param {Boolean} cullOutOfScreen If true will cull quads that are out of screen.\r\n     */\r\n    _drawBatch(group, cullOutOfScreen)\r\n    {\r\n        // skip if empty\r\n        if (group._sprites.length === 0) { return; }\r\n\r\n        // finish previous drawings\r\n        this.presentBufferedData();\r\n\r\n        // get transform\r\n        let transform = group.getTransform();\r\n\r\n        // draw batch\r\n        this.spritesBatch.begin(this._activeEffect, transform);\r\n        this.spritesBatch.draw(group._sprites, cullOutOfScreen);\r\n        this.spritesBatch.end();\r\n    }\r\n\r\n    /**\r\n     * Set the currently active texture.\r\n     * @private\r\n     * @param {TextureAsset} texture Texture to set.\r\n     */\r\n    _setActiveTexture(texture)\r\n    {\r\n        if (this._activeEffect.setTexture(texture)) {\r\n            this._setTextureFilter(texture.filter || this.defaultTextureFilter);\r\n            this._setTextureWrapMode(texture.wrapMode || this.defaultTextureWrapMode);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the blend modes enum.\r\n     * * AlphaBlend\r\n     * * Opaque\r\n     * * Additive\r\n     * * Multiply\r\n     * * Subtract\r\n     * * Screen\r\n     * * Overlay\r\n     * * Invert\r\n     * * DestIn\r\n     * * DestOut\r\n     * \r\n     * ![Blend Modes](resources/blend-modes.png)\r\n     * @see BlendModes\r\n     */\r\n    get BlendModes()\r\n    {\r\n        return BlendModes;\r\n    }\r\n \r\n    /**\r\n     * Get the wrap modes enum.\r\n     * * Clamp: when uv position exceed texture boundaries it will be clamped to the nearest border, ie repeat the edge pixels.\r\n     * * Repeat: when uv position exceed texture boundaries it will wrap back to the other side.\r\n     * * RepeatMirrored: when uv position exceed texture boundaries it will wrap back to the other side but also mirror the texture.\r\n     * \r\n     * ![Wrap Modes](resources/wrap-modes.png)\r\n     * @see TextureWrapModes\r\n     */\r\n    get TextureWrapModes()\r\n    {\r\n        return TextureWrapModes;\r\n    }\r\n\r\n    /**\r\n     * Get texture filter modes.\r\n     * * Nearest: no filtering, no mipmaps (pixelated).\r\n     * * Linear: simple filtering, no mipmaps (smooth).\r\n     * * NearestMipmapNearest: no filtering, sharp switching between mipmaps,\r\n     * * LinearMipmapNearest: filtering, sharp switching between mipmaps.\r\n     * * NearestMipmapLinear: no filtering, smooth transition between mipmaps.\r\n     * * LinearMipmapLinear: filtering, smooth transition between mipmaps.\r\n     * \r\n     * ![Filter Modes](resources/filter-modes.png)\r\n     * @see TextureFilterModes\r\n     */\r\n    get TextureFilterModes()\r\n    {\r\n        return TextureFilterModes;\r\n    }\r\n\r\n    /**\r\n     * Get number of actual WebGL draw calls we performed since the beginning of the frame.\r\n     * @returns {Number} Number of WebGL draw calls this frame.\r\n     */\r\n    get drawCallsCount()\r\n    {\r\n        return this._drawCallsCount;\r\n    }\r\n\r\n    /**\r\n     * Get number of textured / colored quads we drawn since the beginning of the frame.\r\n     * @returns {Number} Number of quads drawn in this frame..\r\n     */\r\n    get quadsDrawCount()\r\n    {\r\n        return this._drawQuadsCount;\r\n    }\r\n\r\n    /**\r\n     * Clear screen to a given color.\r\n     * @example\r\n     * Shaku.gfx.clear(Shaku.utils.Color.cornflowerblue);\r\n     * @param {Color} color Color to clear screen to, or black if not set.\r\n     */\r\n    clear(color)\r\n    {\r\n        this.presentBufferedData();\r\n        color = color || Color.black;\r\n        this._gl.clearColor(color.r, color.g, color.b, color.a);\r\n        this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);\r\n    }\r\n    \r\n    /**\r\n     * Set texture mag and min filters.\r\n     * @private\r\n     * @param {TextureFilterModes} filter Texture filter to set.\r\n     */\r\n    _setTextureFilter(filter)\r\n    {\r\n        if (!TextureFilterModes._values.has(filter)) { throw new Error(\"Invalid texture filter mode! Please pick a value from 'TextureFilterModes'.\"); }\r\n        let glMode = this._gl[filter];\r\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, glMode);\r\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, glMode);\r\n    }\r\n\r\n    /**\r\n     * Set texture wrap mode on X and Y axis.\r\n     * @private\r\n     * @param {WrapModes} wrapX Wrap mode on X axis.\r\n     * @param {WrapModes} wrapY Wrap mode on Y axis.\r\n     */\r\n    _setTextureWrapMode(wrapX, wrapY)\r\n    {\r\n        if (wrapY === undefined) { wrapY = wrapX; }\r\n        if (!TextureWrapModes._values.has(wrapX)) { throw new Error(\"Invalid texture wrap mode! Please pick a value from 'WrapModes'.\"); }\r\n        if (!TextureWrapModes._values.has(wrapY)) { throw new Error(\"Invalid texture wrap mode! Please pick a value from 'WrapModes'.\"); }\r\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl[wrapX]);\r\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl[wrapY]);\r\n    }\r\n\r\n    /**\r\n     * Set blend mode before drawing.\r\n     * @private\r\n     * @param {BlendModes} blendMode New blend mode to set.\r\n     */\r\n    _setBlendMode(blendMode)\r\n    {\r\n        if (this._lastBlendMode !== blendMode) {\r\n\r\n            // get gl context and set defaults\r\n            var gl = this._gl;\r\n            switch (blendMode) \r\n            {\r\n                case BlendModes.AlphaBlend:\r\n                    gl.enable(gl.BLEND);\r\n                    gl.blendEquation(gl.FUNC_ADD);\r\n                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n                    break;\r\n\r\n                case BlendModes.Opaque:\r\n                    gl.disable(gl.BLEND);\r\n                    break;\r\n\r\n                case BlendModes.Additive:\r\n                    gl.enable(gl.BLEND);\r\n                    gl.blendEquation(gl.FUNC_ADD);\r\n                    gl.blendFunc(gl.ONE, gl.ONE);\r\n                    break;\r\n                    \r\n                case BlendModes.Multiply:\r\n                    gl.enable(gl.BLEND);\r\n                    gl.blendEquation(gl.FUNC_ADD);\r\n                    gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n                    break;\r\n\r\n                case BlendModes.Screen:\r\n                    gl.enable(gl.BLEND);\r\n                    gl.blendEquation(gl.FUNC_ADD);\r\n                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n                    break;\r\n\r\n                case BlendModes.Subtract:\r\n                    gl.enable(gl.BLEND);\r\n                    gl.blendEquation(gl.FUNC_ADD);\r\n                    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);\r\n                    gl.blendEquationSeparate(gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD);\r\n                    break;\r\n\r\n                case BlendModes.Invert:\r\n                    gl.enable(gl.BLEND);\r\n                    gl.blendEquation(gl.FUNC_ADD);\r\n                    gl.blendFunc(gl.ONE_MINUS_DST_COLOR, gl.ZERO);\r\n                    gl.blendFuncSeparate(gl.ONE_MINUS_DST_COLOR, gl.ZERO, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n                    break;\r\n\r\n                case BlendModes.Overlay:\r\n                    gl.enable(gl.BLEND);\r\n                    if (gl.MAX) {\r\n                        gl.blendEquation(gl.MAX);\r\n                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n                    } else {\r\n                        gl.blendEquation(gl.FUNC_ADD);\r\n                        gl.blendFunc(gl.ONE, gl.ONE);\r\n                    }\r\n                    break;\r\n\r\n                case BlendModes.Darken:\r\n                    gl.enable(gl.BLEND);\r\n                    gl.blendEquation(gl.MIN);\r\n                    gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n                    break;\r\n\r\n                case BlendModes.DestIn:\r\n                    gl.enable(gl.BLEND);\r\n                    gl.blendEquation(gl.FUNC_ADD);\r\n                    gl.blendFunc(gl.ZERO, gl.SRC_ALPHA);\r\n                    break;\r\n\r\n                case BlendModes.DestOut:\r\n                    gl.enable(gl.BLEND);\r\n                    gl.blendEquation(gl.FUNC_ADD);\r\n                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);\r\n                    // can also use: gl.blendFunc(gl.ONE_MINUS_DST_COLOR, gl.ONE_MINUS_SRC_COLOR);\r\n                    break;\r\n\r\n                default:\r\n                    throw new Error(`Unknown blend mode '${blendMode}'!`);\r\n            }\r\n\r\n            // store last blend mode\r\n            this._lastBlendMode = blendMode;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Present all currently buffered data.\r\n     */\r\n    presentBufferedData()\r\n    {\r\n        this.__finishDrawingSprites();\r\n    }\r\n\r\n    /**\r\n     * Called internally before drawing a sprite to prepare some internal stuff.\r\n     * @private\r\n     */\r\n    __startDrawingSprites(activeEffect, transform)\r\n    {\r\n        // check if should break due to effect or transform change\r\n        if (this.spritesBatch.drawing) {\r\n            if (this.spritesBatch._effect !== activeEffect || this.spritesBatch._transform !== transform) {\r\n                this.spritesBatch.end();\r\n            }\r\n        }\r\n\r\n        // start sprites batch\r\n        if (!this.spritesBatch.drawing) {\r\n            this.spritesBatch.begin(activeEffect, transform);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Called internally to present sprites batch, if currently drawing sprites.\r\n     * @private\r\n     */\r\n    __finishDrawingSprites()\r\n    {\r\n        if (this.spritesBatch.drawing) {\r\n            this.spritesBatch.end();\r\n        }\r\n    }\r\n    \r\n    /** \r\n     * @inheritdoc\r\n     * @private\r\n     */\r\n    startFrame()\r\n    {\r\n        // reset some states\r\n        this._lastBlendMode = null;\r\n        this._drawCallsCount = 0;\r\n        this._drawQuadsCount = 0;\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc\r\n     * @private\r\n     */\r\n    endFrame()\r\n    {\r\n        this.presentBufferedData();\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc\r\n     * @private\r\n     */\r\n    destroy()\r\n    {\r\n        _logger.warn(\"Cleaning up WebGL is not supported yet!\");\r\n    }\r\n}\r\n\r\n// export main object\r\nmodule.exports = new Gfx();", "/**\r\n * Just an alias to main manager so we can require() this folder as a package.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\gfx\\index.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n module.exports = require('./gfx');", "/**\r\n * Implement sound asset type.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\assets\\sound_asset.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Asset = require(\"./asset\");\r\n\r\n \r\n/**\r\n * A loadable sound asset.\r\n * This is the asset type you use to play sounds.\r\n */\r\nclass SoundAsset extends Asset\r\n{\r\n    /** @inheritdoc */\r\n    constructor(url)\r\n    {\r\n        super(url);\r\n        this._valid = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Load the sound asset from its URL.\r\n     * Note that loading sounds isn't actually necessary to play sounds, this method merely pre-load the asset (so first time we play\r\n     * the sound would be immediate and not delayed) and validate the data is valid. \r\n     * @returns {Promise} Promise to resolve when fully loaded.\r\n     */\r\n    load()\r\n    {\r\n        // for audio files we force preload and validation of the audio file.\r\n        // note: we can't use the Audio object as it won't work without page interaction.\r\n        return new Promise((resolve, reject) => {\r\n\r\n            // create request to load audio file\r\n            let audioCtx = new (window.AudioContext || window.webkitAudioContext)();\r\n            var request = new XMLHttpRequest();\r\n            request.open('GET', this.url, true);\r\n            request.responseType = 'arraybuffer';     \r\n\r\n            // on load, validate audio content\r\n            request.onload = () => \r\n            {\r\n                var audioData = request.response;\r\n                this._valid = true; // <-- good enough for now, as decodeAudio won't work before user's input\r\n                this._notifyReady();\r\n                audioCtx.decodeAudioData(audioData, function(buffer) {\r\n                    resolve();\r\n                },\r\n                (e) => { \r\n                    reject(e.err); \r\n                });\r\n            }\r\n\r\n            // on load error, reject\r\n            request.onerror = (e) => {\r\n                reject(e);\r\n            }\r\n\r\n            // initiate request\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    get valid()\r\n    {\r\n        return this._valid;\r\n    }\r\n    \r\n    /** @inheritdoc */\r\n    destroy()\r\n    {\r\n        this._valid = false;\r\n    }\r\n}\r\n\r\n \r\n// export the asset type.\r\nmodule.exports = SoundAsset;", "/**\r\n * Implement a sound effect instance.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\sfx\\sound_instance.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst _logger = require('../logger.js').getLogger('sfx');\r\n\r\n\r\n/**\r\n * A sound effect instance you can play and stop.\r\n */\r\nclass SoundInstance\r\n{\r\n    /**\r\n    * Create a sound instance.\r\n    * @param {Sfx} sfxManager Sfx manager instance.\r\n    * @param {String} url Sound URL or source.\r\n    */\r\n    constructor(sfxManager, url)\r\n    {\r\n        if (!url) {\r\n            _logger.error(\"Sound type can't be null or invalid!\");\r\n            throw new Error(\"Invalid sound type to play in SoundInstance!\");\r\n        }\r\n        this._sfx = sfxManager;\r\n        this._audio = new Audio(url);\r\n        this._volume = 1;\r\n    }\r\n\r\n    /**\r\n     * Dispose the audio object when done playing the sound.\r\n     * This will call dispose() automatically when audio ends.\r\n     */\r\n    disposeWhenDone()\r\n    {\r\n        this._audio.onended = () => {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the audio object and clear its resources.\r\n     * When playing lots of sounds its important to call dispose on sounds you no longer use, to avoid getting hit by\r\n     * \"Blocked attempt to create a WebMediaPlayer\" exception.\r\n     */\r\n    dispose()\r\n    {\r\n        this._audio.src = \"\";\r\n        this._audio.srcObject = null;\r\n        this._audio.remove();\r\n        this._audio = null;\r\n    }\r\n\r\n    /**\r\n    * Play sound.\r\n    */\r\n    play()\r\n    {\r\n        if (this.playing) { return; }\r\n        this._audio.play();\r\n        this._sfx._playingSounds.add(this);\r\n    }\r\n\r\n    /**\r\n    * Get sound effect playback rate.\r\n    * @returns {Number} Playback rate.\r\n    */\r\n    get playbackRate()\r\n    {\r\n        return this._audio.playbackRate;\r\n    }\r\n\r\n    /**\r\n    * Set playback rate.\r\n    * @param {Number} val Playback value to set.\r\n    */\r\n    set playbackRate(val)\r\n    {\r\n        if (val < 0.1) { _logger.error(\"playbackRate value set is too low, value was capped to 0.1.\"); }\r\n        if (val > 10) { _logger.error(\"playbackRate value set is too high, value was capped to 10.\"); }\r\n        this._audio.playbackRate = val;\r\n    }\r\n    \r\n    /**\r\n    * Get if to preserve pitch while changing playback rate.\r\n    * @returns {Boolean} Preserve pitch state of the sound instance.\r\n    */\r\n    get preservesPitch()\r\n    {\r\n        return Boolean(this._audio.preservesPitch || this._audio.mozPreservesPitch);\r\n    }\r\n\r\n    /**\r\n    * Set if to preserve pitch while changing playback rate.\r\n    * @param {Boolean} val New preserve pitch value to set.\r\n    */\r\n    set preservesPitch(val)\r\n    {\r\n        return this._audio.preservesPitch = this._audio.mozPreservesPitch = Boolean(val);\r\n    }\r\n\r\n    /**\r\n    * Pause the sound.\r\n    */\r\n    pause()\r\n    {\r\n        this._audio.pause();\r\n    }\r\n\r\n    /**\r\n    * Replay sound from start.\r\n    */\r\n    replay()\r\n    {\r\n        this.stop();\r\n        this.play();\r\n    }\r\n\r\n    /**\r\n    * Stop the sound and go back to start.\r\n    */\r\n    stop()\r\n    {\r\n        this.pause();\r\n        this.currentTime = 0;\r\n    }\r\n\r\n    /**\r\n    * Get if playing in loop.\r\n    * @returns {Boolean} If this sound should play in loop.\r\n    */\r\n    get loop()\r\n    {\r\n        return this._audio.loop;\r\n    }\r\n\r\n    /**\r\n    * Set if playing in loop.\r\n    * @param {Boolean} value If this sound should play in loop.\r\n    */\r\n    set loop(value)\r\n    {\r\n        this._audio.loop = value;\r\n        return this._audio.loop;\r\n    }\r\n\r\n    /**\r\n    * Get volume.\r\n    * @returns {Number} Sound effect volume.\r\n    */\r\n    get volume()\r\n    {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n    * Set volume.\r\n    * @param {Number} value Sound effect volume to set.\r\n    */\r\n    set volume(value)\r\n    {\r\n        this._volume = value;\r\n        var volume = (value * SoundInstance._masterVolume);\r\n        if (volume < 0) { volume = 0; }\r\n        if (volume > 1) { volume = 1; }\r\n        this._audio.volume = volume;\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n    * Get current time in track.\r\n    * @returns {Number} Current time in playing sound.\r\n    */\r\n    get currentTime()\r\n    {\r\n        return this._audio.currentTime;\r\n    }\r\n\r\n    /**\r\n    * Set current time in track.\r\n    * @param {Number} value Set current playing time in sound track.\r\n    */\r\n    set currentTime(value)\r\n    {\r\n        return this._audio.currentTime = value;\r\n    }\r\n\r\n    /**\r\n    * Get track duration.\r\n    * @returns {Number} Sound duration in seconds.\r\n    */\r\n    get duration()\r\n    {\r\n        return this._audio.duration;\r\n    }\r\n\r\n    /**\r\n    * Get if sound is currently paused.\r\n    * @returns {Boolean} True if sound is currently paused.\r\n    */\r\n    get paused()\r\n    {\r\n        return this._audio.paused;\r\n    }\r\n\r\n    /**\r\n    * Get if sound is currently playing.\r\n    * @returns {Boolean} True if sound is currently playing.\r\n    */\r\n    get playing()\r\n    {\r\n        return !this.paused && !this.finished;\r\n    }\r\n\r\n    /**\r\n    * Get if finished playing.\r\n    * @returns {Boolean} True if sound reached the end and didn't loop.\r\n    */\r\n    get finished()\r\n    {\r\n        return this._audio.ended;\r\n    }\r\n}\r\n\r\n\r\n// master volume\r\nSoundInstance._masterVolume = 1;\r\n\r\n\r\n// export main object\r\nmodule.exports = SoundInstance;", "/**\r\n * Implement a sound mixer class.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\sfx\\sound_mixer.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst SoundInstance = require(\"./sound_instance.js\");\r\n\r\n\r\n/**\r\n * A utility class to mix between two sounds.\r\n */\r\nclass SoundMixer\r\n{\r\n    /**\r\n     * Create the sound mixer.\r\n     * @param {SoundInstance} sound1 Sound to mix from. Can be null to just fade in.\r\n     * @param {SoundInstance} sound2 Sound to mix to. Can be null to just fade out.\r\n     * @param {Boolean} allowOverlapping If true (default), will mix while overlapping sounds. \r\n     *                                   If false, will first finish first sound before begining next.\r\n     */\r\n    constructor(sound1, sound2, allowOverlapping)\r\n    {\r\n        this._sound1 = sound1;\r\n        this._sound2 = sound2;\r\n        this.fromSoundVolume = this._sound1 ? this._sound1.volume : 0;\r\n        this.toSoundVolume = this._sound2 ? this._sound2.volume : 0;\r\n        this.allowOverlapping = allowOverlapping;\r\n        this.update(0);\r\n    }\r\n\r\n    /**\r\n     * Stop both sounds.\r\n     */\r\n    stop()\r\n    {\r\n        if (this._sound1) { this._sound1.stop(); }\r\n        if (this._sound2) { this._sound2.stop(); }\r\n    }\r\n\r\n    /**\r\n     * Get first sound.\r\n     * @returns {SoundInstance} First sound instance.\r\n     */\r\n    get fromSound()\r\n    {\r\n        return this._sound1;\r\n    }\r\n\r\n    /**\r\n     * Get second sound.\r\n     * @returns {SoundInstance} Second sound instance.\r\n     */\r\n    get toSound()\r\n    {\r\n        return this._sound2;\r\n    }\r\n\r\n    /**\r\n     * Return current progress.\r\n     * @returns {Number} Mix progress from 0 to 1.\r\n     */\r\n    get progress()\r\n    {\r\n        return this._progress;\r\n    }\r\n\r\n    /**\r\n     * Update the mixer progress with time delta instead of absolute value.\r\n     * @param {Number} delta Progress delta, in seconds.\r\n     */\r\n    updateDelta(delta)\r\n    {\r\n        this.update(this._progress + delta);\r\n    }\r\n\r\n    /**\r\n     * Update the mixer progress.\r\n     * @param {Number} progress Transition progress from sound1 to sound2. Values must be between 0.0 to 1.0.\r\n     */\r\n    update(progress)\r\n    {\r\n        // special case - start\r\n        if (progress <= 0) {\r\n            if (this._sound1) { \r\n                this._sound1.volume = this.fromSoundVolume;\r\n            }\r\n            if (this._sound2) {\r\n                this._sound2.volume = 0;\r\n                this._sound2.stop();\r\n            }\r\n            this._progress = 0;\r\n        }\r\n        // special case - finish\r\n        if (progress >= 1) {\r\n            if (this._sound2) {\r\n                this._sound2.volume = this.toSoundVolume;\r\n            }\r\n            if (this._sound1) { \r\n                this._sound1.volume = 0;\r\n                this._sound1.stop();\r\n            }\r\n            this._progress = 1;\r\n        }\r\n        // transition\r\n        else\r\n        {\r\n            this._progress = progress;\r\n            if (this._sound1) { this._sound1.play(); }\r\n            if (this._sound2) { this._sound2.play(); }\r\n\r\n            if (this.allowOverlapping) {\r\n                if (this._sound1) { this._sound1.volume =  this.fromSoundVolume * (1 - progress); }  \r\n                if (this._sound2) { this._sound2.volume =  this.toSoundVolume * progress; }\r\n            }\r\n            else {\r\n                progress *= 2;\r\n                if (this._sound1) { this._sound1.volume =  Math.max(this.fromSoundVolume * (1 - progress), 0); }\r\n                if (this._sound2) { this._sound2.volume =  Math.max(this.toSoundVolume * (progress - 1), 0); }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// export the sound mixer\r\nmodule.exports = SoundMixer;", "/**\r\n * Implement the sfx manager.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\sfx\\sfx.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst SoundAsset = require('../assets/sound_asset.js');\r\nconst IManager = require('../manager.js');\r\nconst _logger = require('../logger.js').getLogger('sfx');\r\nconst SoundInstance = require('./sound_instance.js');\r\nconst SoundMixer = require('./sound_mixer.js');\r\n \r\n\r\n/**\r\n * Sfx manager. \r\n * Used to play sound effects and music.\r\n * \r\n * To access the Sfx manager use `Shaku.sfx`. \r\n */\r\nclass Sfx extends IManager\r\n{\r\n    /**\r\n     * Create the manager.\r\n     */\r\n    constructor()\r\n    {\r\n        super();\r\n        this._playingSounds = null;\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc \r\n     * @private\r\n     **/\r\n    setup()\r\n    {        \r\n        return new Promise((resolve, reject) => {    \r\n            _logger.info(\"Setup sfx manager..\");\r\n            this._playingSounds = new Set();\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc \r\n     * @private\r\n     **/\r\n    startFrame()\r\n    {\r\n        var playingSounds = Array.from(this._playingSounds);\r\n        for (var i = 0; i < playingSounds.length; ++i) {\r\n            var sound = playingSounds[i];\r\n            if (!sound.isPlaying) {\r\n                this._playingSounds.delete(sound);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc \r\n     * @private\r\n     **/\r\n    endFrame()\r\n    {\r\n        var playingSounds = Array.from(this._playingSounds);\r\n        for (var i = 0; i < playingSounds.length; ++i) {\r\n            var sound = playingSounds[i];\r\n            if (!sound.isPlaying) {\r\n                this._playingSounds.delete(sound);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc \r\n     * @private\r\n     **/\r\n    destroy()\r\n    {\r\n        this.stopAll();\r\n        this._playingSounds = new Set();\r\n    }\r\n\r\n    /**\r\n     * Get the SoundMixer class.\r\n     * @see SoundMixer\r\n     */\r\n    get SoundMixer()\r\n    {\r\n        return SoundMixer;\r\n    }\r\n\r\n    /**\r\n     * Play a sound once without any special properties and without returning a sound instance.\r\n     * Its a more convinient method to play sounds, but less efficient than 'createSound()' if you want to play multiple times.\r\n     * @example\r\n     * let sound = await Shaku.assets.loadSound(\"assets/my_sound.ogg\");\r\n     * Shaku.sfx.play(sound, 0.75);\r\n     * @param {SoundAsset} sound Sound asset to play.\r\n     * @param {Number} volume Volume to play sound (default to max).\r\n     * @param {Number} playbackRate Optional playback rate factor.\r\n     * @param {Boolean} preservesPitch Optional preserve pitch when changing rate factor.\r\n     */\r\n    play(sound, volume, playbackRate, preservesPitch)\r\n    {\r\n        var sound = this.createSound(sound);\r\n        sound.volume = volume !== undefined ? volume : 1;\r\n        if (playbackRate !== undefined) { sound.playbackRate = playbackRate; }\r\n        if (preservesPitch !== undefined) { sound.preservesPitch = preservesPitch; }\r\n        sound.play();\r\n        sound.disposeWhenDone();\r\n    }\r\n\r\n    /**\r\n     * Stop all playing sounds.\r\n     * @example\r\n     * Shaku.sfx.stopAll();\r\n     */\r\n    stopAll()\r\n    {\r\n        var playingSounds = Array.from(this._playingSounds);\r\n        for (var i = 0; i < playingSounds.length; ++i) {\r\n            var sound = playingSounds[i];\r\n            sound.stop();\r\n        }\r\n        this._playingSounds = new Set();\r\n    }\r\n\r\n    /**\r\n     * Get currently playing sounds count.\r\n     * @returns {Number} Number of sounds currently playing.\r\n     */\r\n    get playingSoundsCount()\r\n    {\r\n        return this._playingSounds.size;\r\n    }\r\n\r\n    /**\r\n     * Create and return a sound instance you can use to play multiple times.\r\n     * @example\r\n     * let sound = await Shaku.assets.loadSound(\"assets/my_sound.ogg\");\r\n     * let soundInstance = Shaku.sfx.createSound(sound);\r\n     * soundInstance.play();\r\n     * @param {SoundAsset} sound Sound asset to play.\r\n     * @returns {SoundInstance} Newly created sound instance.\r\n     */\r\n    createSound(sound)\r\n    {\r\n        if (!(sound instanceof SoundAsset)) { throw new Error(\"Sound type must be an instance of SoundAsset!\"); }\r\n        var ret = new SoundInstance(this, sound.url);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get master volume.\r\n     * This affect all sound effects volumes.\r\n     * @returns {Number} Current master volume value.\r\n     */\r\n    get masterVolume()\r\n    {\r\n        return SoundInstance._masterVolume;\r\n    }\r\n    \r\n    /**\r\n     * Set master volume.\r\n     * This affect all sound effects volumes.\r\n     * @param {Number} value Master volume to set.\r\n     */\r\n    set masterVolume(value)\r\n    {\r\n        SoundInstance._masterVolume = value;\r\n        return value;\r\n    }\r\n}\r\n\r\n// export main object\r\nmodule.exports = new Sfx();", "/**\r\n * Just an alias to main manager so we can require() this folder as a package.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\sfx\\index.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n module.exports = require('./sfx');", "/**\r\n * Define keyboard and mouse key codes.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\input\\key_codes.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n/**\r\n * Define mouse button codes.\r\n */\r\nconst MouseButtons = {\r\n    left: 0,\r\n    middle: 1,\r\n    right: 2,\r\n};\r\n\r\n/**\r\n * Define all keyboard key codes.\r\n */\r\nconst KeyboardKeys = {\r\n    backspace: 8,\r\n    tab: 9,\r\n    enter: 13,\r\n    shift: 16,\r\n    ctrl: 17,\r\n    alt: 18,\r\n    break: 19,\r\n    caps_lock: 20,\r\n    escape: 27,\r\n    page_up: 33,\r\n    page_down: 34,\r\n    end: 35,\r\n    home: 36,\r\n    left: 37,\r\n    up: 38,\r\n    right: 39,\r\n    down: 40,\r\n    insert: 45,\r\n    delete: 46,\r\n    space: 32,\r\n    n0: 48,\r\n    n1: 49,\r\n    n2: 50,\r\n    n3: 51,\r\n    n4: 52,\r\n    n5: 53,\r\n    n6: 54,\r\n    n7: 55,\r\n    n8: 56,\r\n    n9: 57,\r\n    a: 65,\r\n    b: 66,\r\n    c: 67,\r\n    d: 68,\r\n    e: 69,\r\n    f: 70,\r\n    g: 71,\r\n    h: 72,\r\n    i: 73,\r\n    j: 74,\r\n    k: 75,\r\n    l: 76,\r\n    m: 77,\r\n    n: 78,\r\n    o: 79,\r\n    p: 80,\r\n    q: 81,\r\n    r: 82,\r\n    s: 83,\r\n    t: 84,\r\n    u: 85,\r\n    v: 86,\r\n    w: 87,\r\n    x: 88,\r\n    y: 89,\r\n    z: 90,\r\n    left_window_key: 91,\r\n    right_window_key: 92,\r\n    select_key: 93,\r\n    numpad_0: 96,\r\n    numpad_1: 97,\r\n    numpad_2: 98,\r\n    numpad_3: 99,\r\n    numpad_4: 100,\r\n    numpad_5: 101,\r\n    numpad_6: 102,\r\n    numpad_7: 103,\r\n    numpad_8: 104,\r\n    numpad_9: 105,\r\n    multiply: 106,\r\n    add: 107,\r\n    subtract: 109,\r\n    decimal_point: 110,\r\n    divide: 111,\r\n    f1: 112,\r\n    f2: 113,\r\n    f3: 114,\r\n    f4: 115,\r\n    f5: 116,\r\n    f6: 117,\r\n    f7: 118,\r\n    f8: 119,\r\n    f9: 120,\r\n    f10: 121,\r\n    f11: 122,\r\n    f12: 123,\r\n    numlock: 144,\r\n    scroll_lock: 145,\r\n    semicolon: 186,\r\n    equal_sign: 187,\r\n    plus: 187,\r\n    comma: 188,\r\n    dash: 189,\r\n    minus: 189,\r\n    period: 190,\r\n    forward_slash: 191,\r\n    grave_accent: 192,\r\n    open_bracket: 219,\r\n    back_slash: 220,\r\n    close_braket: 221,\r\n    single_quote: 222,\r\n};\r\n\r\n// export keyboard keys and mouse buttons\r\nmodule.exports = { KeyboardKeys: KeyboardKeys, MouseButtons: MouseButtons };", "/**\r\n * Implement the input manager.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\input\\input.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst IManager = require('../manager.js');\r\nconst Vector2 = require('../utils/vector2.js');\r\nconst { MouseButtons, KeyboardKeys } = require('./key_codes.js');\r\nconst _logger = require('../logger.js').getLogger('input');\r\n\r\n\r\n/**\r\n * Input manager. \r\n * Used to recieve input from keyboard and mouse.\r\n * \r\n * To access the Input manager use `Shaku.input`. \r\n */\r\nclass Input extends IManager\r\n{\r\n    /**\r\n     * Create the manager.\r\n     */\r\n    constructor()\r\n    {\r\n        super();\r\n        \r\n        // callbacks and target we listen to input on\r\n        this._callbacks = null;\r\n        this._targetElement = window;\r\n\r\n        // export mouse and keyboard keys\r\n        this.MouseButtons = MouseButtons;\r\n        this.KeyboardKeys = KeyboardKeys;\r\n\r\n        // if true, will prevent default events by calling preventDefault()\r\n        this.preventDefaults = false;\r\n\r\n        // by default, when holding wheel button down browsers will turn into special page scroll mode and will not emit mouse move events.\r\n        // if this property is set to true, StInput will prevent this behavior, so we could still get mouse delta while mouse wheel is held down.\r\n        this.enableMouseDeltaWhileMouseWheelDown = true;\r\n\r\n        // if true, will disable the context menu (right click)\r\n        this.disableContextMenu = true;\r\n\r\n        // should we reset on focus lost?\r\n        this.resetOnFocusLoss = true;\r\n\r\n        // set base state members\r\n        this._resetAll();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     * @private\r\n     **/\r\n    setup()\r\n    {        \r\n        return new Promise((resolve, reject) => {\r\n\r\n            _logger.info(\"Setup input manager..\");\r\n\r\n            // if target element is a method, invoke it\r\n            if (typeof this._targetElement === 'function') {\r\n                this._targetElement = this._targetElement();\r\n                if (!this._targetElement) {\r\n                    throw new Error(\"Input target element was set to be a method, but the returned value was invalid!\");\r\n                }\r\n            }\r\n\r\n            // get element to attach to\r\n            let element = this._targetElement;\r\n\r\n            // to make sure keyboard input would work if provided with canvas entity\r\n            if (element.tabIndex === -1 || element.tabIndex === undefined) {\r\n                element.tabIndex = 1000;\r\n            }\r\n\r\n            // focus on target element\r\n            window.setTimeout(() => element.focus(), 0);\r\n\r\n            // set all the events to listen to\r\n            var _this = this;\r\n            this._callbacks = {\r\n                'mousedown': function(event) {_this._onMouseDown(event); if (this.preventDefaults) event.preventDefault(); },\r\n                'mouseup': function(event) {_this._onMouseUp(event); if (this.preventDefaults) event.preventDefault(); },\r\n                'mousemove': function(event) {_this._onMouseMove(event); if (this.preventDefaults) event.preventDefault(); },\r\n                'keydown': function(event) {_this._onKeyDown(event); if (this.preventDefaults) event.preventDefault(); },\r\n                'keyup': function(event) {_this._onKeyUp(event); if (this.preventDefaults) event.preventDefault(); },\r\n                'blur': function(event) {_this._onBlur(event); if (this.preventDefaults) event.preventDefault(); },\r\n                'wheel': function(event) {_this._onMouseWheel(event); },\r\n                'touchstart': function(event) {_this._onTouchStart(event); if (this.preventDefaults) event.preventDefault(); },\r\n                'touchend': function(event) {_this._onMouseUp(event); if (this.preventDefaults) event.preventDefault(); },\r\n                'touchmove': function(event) {_this._onTouchMove(event); if (this.preventDefaults) event.preventDefault(); },\r\n                'contextmenu': function(event) { if (_this.disableContextMenu) { event.preventDefault(); } },\r\n            };\r\n\r\n            // reset all data to init initial state\r\n            this._resetAll();\r\n                    \r\n            // register all callbacks\r\n            for (var event in this._callbacks) {\r\n                element.addEventListener(event, this._callbacks[event], false);\r\n            }\r\n\r\n            // if we have a specific element, still capture mouse release outside of it\r\n            if (element !== window) {\r\n                window.addEventListener('mouseup', this._callbacks['mouseup'], false);\r\n                window.addEventListener('touchend', this._callbacks['touchend'], false);\r\n            }\r\n\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     * @private\r\n     **/\r\n    startFrame()\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     * @private\r\n     **/\r\n    destroy()\r\n    {\r\n        // unregister all callbacks\r\n        if (this._callbacks)\r\n        {\r\n            let element = this._targetElement;\r\n\r\n            for (var event in this._callbacks) {\r\n                element.removeEventListener(event, this._callbacks[event]);\r\n            }\r\n\r\n            if (element !== window) {\r\n                window.removeEventListener('mouseup', this._callbacks['mouseup'], false);\r\n                window.removeEventListener('touchend', this._callbacks['touchend'], false);\r\n            }\r\n            \r\n            this._callbacks = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the target element to attach input to. If not called, will just use the entire document.\r\n     * Must be called *before* initializing Shaku. This can also be a method to invoke while initializing.\r\n     * @example\r\n     * // the following will use whatever canvas the gfx manager uses as input element.\r\n     * // this means mouse offset will also be relative to this element.\r\n     * Shaku.input.setTargetElement(() => Shaku.gfx.canvas);\r\n     * @param {Element} element Element to attach input to.\r\n     */\r\n    setTargetElement(element)\r\n    {\r\n        if (this._callbacks) { throw new Error(\"'setTargetElement() must be called before initializing the input manager!\"); }\r\n        this._targetElement = element;\r\n    }\r\n\r\n    /**\r\n     * Reset all internal data and states.\r\n     * @private\r\n     */\r\n    _resetAll()\r\n    {\r\n        // mouse states\r\n        this._mousePos = new Vector2();\r\n        this._mousePrevPos = new Vector2();\r\n        this._mouseState = {};\r\n        this._mousePrevState = {};\r\n        this._mouseWheel = 0;\r\n\r\n        // keyboard keys\r\n        this._keyboardState = {};\r\n        this._keyboardPrevState = {};\r\n\r\n        // reset touch started state\r\n        this._touchStarted = false;\r\n    }\r\n    \r\n    /**\r\n     * Get mouse position.\r\n     * @returns {Vector2} Mouse position.\r\n     */\r\n    get mousePosition()\r\n    {\r\n        return this._mousePos.clone();\r\n    }\r\n        \r\n    /**\r\n     * Get mouse previous position (before the last endFrame() call).\r\n     * @returns {Vector2} Mouse position in previous frame.\r\n     */\r\n    get prevMousePosition()\r\n    {\r\n        return (this._mousePrevPos || this._mousePos).clone();\r\n    }\r\n\r\n    /**\r\n     * Get mouse movement since last endFrame() call.\r\n     * @returns {Vector2} Mouse change since last frame.\r\n     */\r\n    get mouseDelta()\r\n    {\r\n        // no previous position? return 0,0.\r\n        if (!this._mousePrevPos) {\r\n            return Vector2.zero;\r\n        }\r\n\r\n        // return mouse delta\r\n        return new Vector2(this._mousePos.x - this._mousePrevPos.x, this._mousePos.y - this._mousePrevPos.y);\r\n    }\r\n\r\n    /**\r\n     * Get if mouse is currently moving.\r\n     * @returns {Boolean} True if mouse moved since last frame, false otherwise.\r\n     */\r\n    get mouseMoving()\r\n    {\r\n        return (this._mousePrevPos && !this._mousePrevPos.equals(this._mousePos));\r\n    }\r\n\r\n    /**\r\n     * Get if mouse button was pressed this frame.\r\n     * @param {MouseButtons} button Button code (defults to MouseButtons.left).\r\n     * @returns {Boolean} True if mouse button is currently down, but was up in previous frame.\r\n     */\r\n    mousePressed(button = 0)\r\n    {\r\n        if (button === undefined) throw new Error(\"Invalid button code!\");\r\n        return Boolean(this._mouseState[button] && !this._mousePrevState[button]);\r\n    }\r\n\r\n    /**\r\n     * Get if mouse button is currently pressed.\r\n     * @param {MouseButtons} button Button code (defults to MouseButtons.left).  \r\n     * @returns {Boolean} true if mouse button is currently down, false otherwise.\r\n     */\r\n    mouseDown(button = 0)\r\n    {\r\n        if (button === undefined) throw new Error(\"Invalid button code!\");\r\n        return Boolean(this._mouseState[button]);\r\n    }\r\n\r\n    /**\r\n     * Get if mouse button is currently not down.\r\n     * @param {MouseButtons} button Button code (defults to MouseButtons.left).\r\n     * @returns {Boolean} true if mouse button is currently up, false otherwise.\r\n     */\r\n    mouseUp(button = 0)\r\n    {\r\n        if (button === undefined) throw new Error(\"Invalid button code!\");\r\n        return Boolean(!this.mouseDown(button));\r\n    }\r\n    \r\n    /**\r\n     * Get if mouse button was released in current frame.\r\n     * @param {MouseButtons} button Button code (defults to MouseButtons.left).\r\n     * @returns {Boolean} True if mouse was down last frame, but released in current frame.\r\n     */\r\n    mouseReleased(button = 0)\r\n    {\r\n        if (button === undefined) throw new Error(\"Invalid button code!\");\r\n        return Boolean(!this._mouseState[button] && this._mousePrevState[button]);\r\n    }\r\n\r\n    /**\r\n     * Get if keyboard key is currently pressed down.\r\n     * @param {KeyboardKeys} key Keyboard key code.\r\n     * @returns {boolean} True if keyboard key is currently down, false otherwise.\r\n     */\r\n    keyDown(key)\r\n    {\r\n        if (key === undefined) throw new Error(\"Invalid key code!\");\r\n        return Boolean(this._keyboardState[key]);\r\n    }\r\n\r\n    /**\r\n     * Get if keyboard key is currently not down.\r\n     * @param {KeyboardKeys} key Keyboard key code.\r\n     * @returns {Boolean} True if keyboard key is currently up, false otherwise.\r\n     */\r\n    keyUp(key)\r\n    {\r\n        if (key === undefined) throw new Error(\"Invalid key code!\");\r\n        return Boolean(!this.keyDown(key));\r\n    }\r\n\r\n    /**\r\n     * Get if a keyboard button was released in current frame.\r\n     * @param {KeyboardKeys} button Keyboard key code.\r\n     * @returns {Boolean} True if key was down last frame, but released in current frame.\r\n     */\r\n    keyReleased(key)\r\n    {\r\n        if (key === undefined) throw new Error(\"Invalid key code!\");\r\n        return Boolean(!this._keyboardState[key] && this._keyboardPrevState[key]);\r\n    }\r\n    \r\n    /**\r\n     * Get if keyboard key was pressed this frame.\r\n     * @param {KeyboardKeys} key Keyboard key code.\r\n     * @returns {Boolean} True if key is currently down, but was up in previous frame.\r\n     */\r\n    keyPressed(key)\r\n    {\r\n        if (key === undefined) throw new Error(\"Invalid key code!\");\r\n        return Boolean(this._keyboardState[key] && !this._keyboardPrevState[key]);\r\n    }\r\n\r\n    /**\r\n     * Get if any of the shift keys are currently down.\r\n     * @returns {Boolean} True if there's a shift key pressed down.\r\n     */\r\n    get shiftDown()\r\n    {\r\n        return Boolean(this.keyDown(this.KeyboardKeys.shift));\r\n    }\r\n\r\n    /**\r\n     * Get if any of the Ctrl keys are currently down.\r\n     * @returns {Boolean} True if there's a Ctrl key pressed down.\r\n     */\r\n    get ctrlDown()\r\n    {\r\n        return Boolean(this.keyDown(this.KeyboardKeys.ctrl));\r\n    }\r\n\r\n    /**\r\n     * Get if any of the Alt keys are currently down.\r\n     * @returns {Boolean} True if there's an Alt key pressed down.\r\n     */\r\n    get altDown()\r\n    {\r\n        return Boolean(this.keyDown(this.KeyboardKeys.alt));\r\n    }\r\n\r\n    /**\r\n     * Get if any keyboard key is currently down.\r\n     * @returns {Boolean} True if there's a key pressed down.\r\n     */\r\n    get anyKeyDown()\r\n    {\r\n        for (var key in this._keyboardState) {\r\n            if (this._keyboardState[key]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get if any mouse button is down.\r\n     * @returns {Boolean} True if any of the mouse buttons are pressed.\r\n     */\r\n    get anyMouseButtonDown()\r\n    {\r\n        for (var key in this._mouseState) {\r\n            if (this._mouseState[key]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return if a mouse or keyboard state in a generic way, used internally.\r\n     * @private\r\n     * @param {string} code Keyboard or mouse code. \r\n     *                          For mouse buttons: mouse_left, mouse_right or mouse_middle.\r\n     *                          For keyboard buttons: use one of the keys of KeyboardKeys (for example 'a', 'alt', 'up_arrow', etc..)\r\n     *                          For numbers (0-9): you can use the number.\r\n     * @param {Function} mouseCheck Callback to use to return value if its a mouse button code.\r\n     * @param {Function} keyboardCheck Callback to use to return value if its a keyboard key code.\r\n     */\r\n    _getValueWithCode(code, mouseCheck, keyboardCheck)\r\n    {\r\n        // make sure code is string\r\n        code = String(code);\r\n\r\n        // if starts with 'mouse' its for mouse button events\r\n        if (code.indexOf('mouse_') === 0) {\r\n\r\n            // get mouse code name\r\n            var codename = code.split('_')[1];\r\n\r\n            // return if mouse down\r\n            return mouseCheck.call(this, this.MouseButtons[codename]);\r\n        }\r\n\r\n        // if its just a number, add the 'n' prefix\r\n        if (!isNaN(parseInt(code)) && code.length === 1) {\r\n            code = 'n' + code;\r\n        }\r\n\r\n        // if not start with 'mouse', treat it as a keyboard key\r\n        return keyboardCheck.call(this, this.KeyboardKeys[code]);\r\n    }\r\n\r\n    /**\r\n     * Return if a mouse or keyboard button is currently down.\r\n     * @param {string|Array<String>} code Keyboard or mouse code. Can be array of codes to test if any of them is down.\r\n     *                          For mouse buttons: mouse_left, mouse_right or mouse_middle.\r\n     *                          For keyboard buttons: use one of the keys of KeyboardKeys (for example 'a', 'alt', 'up_arrow', etc..)\r\n     *                          For numbers (0-9): you can use the number.\r\n     * @returns {Boolean} True if key or mouse button are down.\r\n     */\r\n    down(code)\r\n    {\r\n        if (!(code instanceof Array)) { code = [code]; }\r\n        for (let c of code) {\r\n            if (Boolean(this._getValueWithCode(c, this.mouseDown, this.keyDown))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return if a mouse or keyboard button was released in this frame.\r\n     * @param {string|Array<String>} code Keyboard or mouse code. Can be array of codes to test if any of them is released.\r\n     *                          For mouse buttons: mouse_left, mouse_right or mouse_middle.\r\n     *                          For keyboard buttons: use one of the keys of KeyboardKeys (for example 'a', 'alt', 'up_arrow', etc..)\r\n     *                          For numbers (0-9): you can use the number.\r\n     * @returns {Boolean} True if key or mouse button were down in previous frame, and released this frame.\r\n     */\r\n    released(code)\r\n    {\r\n        if (!(code instanceof Array)) { code = [code]; }\r\n        for (let c of code) {\r\n            if (Boolean(this._getValueWithCode(c, this.mouseReleased, this.keyReleased))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return if a mouse or keyboard button was pressed in this frame.\r\n     * @param {string|Array<String>} code Keyboard or mouse code. Can be array of codes to test if any of them is pressed.\r\n     *                          For mouse buttons: mouse_left, mouse_right or mouse_middle.\r\n     *                          For keyboard buttons: use one of the keys of KeyboardKeys (for example 'a', 'alt', 'up_arrow', etc..)\r\n     *                          For numbers (0-9): you can use the number.\r\n     * @returns {Boolean} True if key or mouse button where up in previous frame, and pressed this frame.\r\n     */\r\n    pressed(code)\r\n    {\r\n        if (!(code instanceof Array)) { code = [code]; }\r\n        for (let c of code) {\r\n            if (Boolean(this._getValueWithCode(c, this.mousePressed, this.keyPressed))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get mouse wheel sign.\r\n     * @returns {Number} Mouse wheel sign (-1 or 1) for wheel scrolling that happened during this frame.\r\n     * Will return 0 if mouse wheel is not currently being used.\r\n     */\r\n    get mouseWheelSign()\r\n    {\r\n        return Math.sign(this._mouseWheel);\r\n    }\r\n\r\n    /**\r\n     * Get mouse wheel value.\r\n     * @returns {Number} Mouse wheel value.\r\n     */\r\n    get mouseWheel()\r\n    {\r\n        return this._mouseWheel;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     * @private\r\n     **/\r\n    endFrame()\r\n    {\r\n        // set mouse previous position and clear mouse move cache\r\n        this._mousePrevPos = this._mousePos.clone();\r\n\r\n        // set previous keyboard state\r\n        this._keyboardPrevState = {};\r\n        for (var key in this._keyboardState) {\r\n            this._keyboardPrevState[key] = this._keyboardState[key];\r\n        }\r\n\r\n        // set previous mouse state\r\n        this._mousePrevState = {};\r\n        for (var key in this._mouseState) {\r\n            this._mousePrevState[key] = this._mouseState[key];\r\n        }\r\n\r\n        // apply touch start event\r\n        if (this._touchStarted)\r\n        {\r\n            this._mouseState[this.MouseButtons.left] = true;\r\n            this._touchStarted = false;\r\n        }\r\n\r\n        // reset mouse wheel\r\n        this._mouseWheel = 0;\r\n    }\r\n\r\n    /**\r\n     * Get keyboard key code from event.\r\n     * @private\r\n     */\r\n    _getKeyboardKeyCode(event)\r\n    {\r\n        event = this._getEvent(event);\r\n        return event.keyCode !== undefined ? event.keyCode : event.key.charCodeAt(0);\r\n    }\r\n\r\n    /**\r\n     * Called when window loses focus - clear all input states to prevent keys getting stuck.\r\n     * @private\r\n     */\r\n    _onBlur(event)\r\n    {\r\n        if (this.resetOnFocusLoss) {\r\n            this._resetAll();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle mouse wheel events.\r\n     * @private\r\n     * @param {*} event Event data from browser.\r\n     */\r\n    _onMouseWheel(event)\r\n    {\r\n        this._mouseWheel = event.deltaY;\r\n    }\r\n\r\n    /**\r\n     * Handle keyboard down event.\r\n     * @private\r\n     * @param {*} event Event data from browser.\r\n     */\r\n    _onKeyDown(event)\r\n    {\r\n        var keycode = this._getKeyboardKeyCode(event);\r\n        this._keyboardState[keycode] = true;\r\n    }\r\n\r\n    /**\r\n     * Handle keyboard up event.\r\n     * @private\r\n     * @param {*} event Event data from browser.\r\n     */\r\n    _onKeyUp(event)\r\n    {\r\n        var keycode = this._getKeyboardKeyCode(event);\r\n        this._keyboardState[keycode || 0] = false;\r\n    }\r\n\r\n    /**\r\n     * Handle touch start event.\r\n     * @private\r\n     * @param {*} event Event data from browser.\r\n     */\r\n    _onTouchStart(event)\r\n    {\r\n        // also update mouse position - this is important for touch events on mobile, where touch move only works while touching,\r\n        // so we want to update mouse position on the moment touch starts\r\n        var touches = event.changedTouches;\r\n        if (touches && touches.length)\r\n        {\r\n            var touch = touches[0];\r\n            var x = touch.pageX || touch.offsetX || touch.clientX;\r\n            var y = touch.pageY || touch.offsetY || touch.clientY;\r\n            if (x !== undefined && y !== undefined) {\r\n                this._mousePos.x = x;\r\n                this._mousePos.y = y;\r\n                this._normalizeMousePos()\r\n            }\r\n        }\r\n\r\n        // mark that touch started - will update state next frame\r\n        this._touchStarted = true;\r\n    }\r\n\r\n    /**\r\n     * Handle mouse down event.\r\n     * @private\r\n     * @param {*} event Event data from browser.\r\n     */\r\n    _onMouseDown(event)\r\n    {\r\n        // update mouse down state\r\n        event = this._getEvent(event);\r\n        if (this.enableMouseDeltaWhileMouseWheelDown && (event.button === this.MouseButtons.middle))\r\n        { \r\n            event.preventDefault(); \r\n        }\r\n        this._mouseState[event.button || 0] = true;\r\n    }\r\n\r\n    /**\r\n     * Handle mouse up event.\r\n     * @private\r\n     * @param {*} event Event data from browser.\r\n     */\r\n    _onMouseUp(event)\r\n    {\r\n        event = this._getEvent(event);\r\n        this._mouseState[event.button || 0] = false;\r\n    }\r\n\r\n    /**\r\n     * Handle touch move event.\r\n     * @private\r\n     * @param {*} event Event data from browser.\r\n     */\r\n    _onTouchMove(event)\r\n    {\r\n        event = this._getEvent(event);\r\n        this._mousePos.x = event.touches[0].pageX;\r\n        this._mousePos.y = event.touches[0].pageY;\r\n        this._normalizeMousePos();\r\n    }\r\n\r\n    /**\r\n     * Handle mouse move event.\r\n     * @private\r\n     * @param {*} event Event data from browser.\r\n     */\r\n    _onMouseMove(event)\r\n    {\r\n        // get event in a cross-browser way\r\n        event = this._getEvent(event);\r\n\r\n        // try to get position from event with some fallbacks\r\n        var pageX = event.clientX; \r\n        if (pageX === undefined) { pageX = event.x; } \r\n        if (pageX === undefined) { pageX = event.offsetX; } \r\n        if (pageX === undefined) { pageX = event.pageX; }\r\n\r\n        var pageY = event.clientY; \r\n        if (pageY === undefined) { pageY = event.y; } \r\n        if (pageY === undefined) { pageY = event.offsetY; } \r\n        if (pageY === undefined) { pageY = event.pageY; }\r\n\r\n        // if pageX and pageY are not supported, use clientX and clientY instead\r\n        if (pageX === undefined) {\r\n            pageX = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\r\n            pageY = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;\r\n        }\r\n\r\n        // set current mouse position\r\n        this._mousePos.x = pageX;\r\n        this._mousePos.y = pageY;\r\n        this._normalizeMousePos();\r\n    }\r\n\r\n    /**\r\n     * Normalize current _mousePos value to be relative to target element.\r\n     * @private\r\n     */\r\n    _normalizeMousePos()\r\n    {\r\n        if (this._targetElement && this._targetElement.getBoundingClientRect) {\r\n            var rect = this._targetElement.getBoundingClientRect();\r\n            this._mousePos.x -= rect.left;\r\n            this._mousePos.y -= rect.top;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get event either from event param or from window.event. \r\n     * This is for older browsers support.\r\n     * @private\r\n     */\r\n    _getEvent(event)\r\n    {\r\n        return event || window.event;\r\n    }\r\n}\r\n\r\n\r\n// export main object\r\nmodule.exports = new Input();", "/**\r\n * Just an alias to main manager so we can require() this folder as a package.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\input\\index.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n module.exports = require('./input');", "/**\r\n * Implement binary data asset type.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\assets\\binary_asset.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Asset = require(\"./asset\");\r\n\r\n\r\n/**\r\n * A loadable binary data asset.\r\n * This asset type loads array of bytes from a remote file.\r\n */\r\nclass BinaryAsset extends Asset\r\n{\r\n    /** @inheritdoc */\r\n    constructor(url)\r\n    {\r\n        super(url);\r\n        this._data = null;\r\n    }\r\n\r\n    /**\r\n     * Load the binary data from the asset URL.\r\n     * @returns {Promise} Promise to resolve when fully loaded.\r\n     */\r\n    load()\r\n    {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            var request = new XMLHttpRequest();\r\n            request.open('GET', this.url, true);\r\n            request.responseType = 'arraybuffer';     \r\n\r\n            // on load, validate audio content\r\n            request.onload = () => \r\n            {\r\n                if (request.readyState == 4) {\r\n                    if (request.response) {\r\n                        this._data = new Uint8Array(request.response);\r\n                        this._notifyReady();\r\n                        resolve();\r\n                    }\r\n                    else {\r\n                        reject(request.statusText);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // on load error, reject\r\n            request.onerror = (e) => {\r\n                reject(e);\r\n            }\r\n\r\n            // initiate request\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create the binary data asset from array or Uint8Array.\r\n     * @param {Array<Number>|Uint8Array} source Data to create asset from.\r\n     * @returns {Promise} Promise to resolve when asset is ready.\r\n     */\r\n    create(source)\r\n    {\r\n        return new Promise((resolve, reject) => {\r\n            if (source instanceof Array) { source = new Uint8Array(source); }\r\n            if (!(source instanceof Uint8Array)) { return reject(\"Binary asset source must be of type 'Uint8Array'!\"); }\r\n            this._data = source;\r\n            this._notifyReady();\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    get valid()\r\n    {\r\n        return Boolean(this._data);\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    destroy()\r\n    {\r\n        this._data = null;\r\n    }\r\n\r\n    /**\r\n     * Get binary data.\r\n     * @returns {Uint8Array} Data as bytes array.\r\n     */\r\n    get data()\r\n    {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * Convert and return data as string.\r\n     * @returns {String} Data converted to string.\r\n     */\r\n    string()\r\n    {\r\n        return (new TextDecoder()).decode(this._data);\r\n    }\r\n}\r\n\r\n\r\n// export the asset type.\r\nmodule.exports = BinaryAsset;", "/**\r\n * Implement json asset type.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\assets\\json_asset.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Asset = require(\"./asset\");\r\n\r\n\r\n/**\r\n * A loadable json asset.\r\n * This asset type loads JSON from a remote file.\r\n */\r\nclass JsonAsset extends Asset\r\n{\r\n    /** @inheritdoc */\r\n    constructor(url)\r\n    {\r\n        super(url);\r\n        this._data = null;\r\n    }\r\n\r\n    /**\r\n     * Load the JSON data from the asset URL.\r\n     * @returns {Promise} Promise to resolve when fully loaded.\r\n     */\r\n    load()\r\n    {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            var request = new XMLHttpRequest();\r\n            request.open('GET', this.url, true);\r\n            request.responseType = 'json';     \r\n\r\n            // on load, validate audio content\r\n            request.onload = () => \r\n            {\r\n                if (request.readyState == 4) {\r\n                    if (request.response) {\r\n                        this._data = request.response;\r\n                        this._notifyReady();\r\n                        resolve();\r\n                    }\r\n                    else {\r\n                        if (request.status === 200) {\r\n                            reject(\"Response is not a valid JSON!\");\r\n                        }\r\n                        else {\r\n                            reject(request.statusText);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // on load error, reject\r\n            request.onerror = (e) => {\r\n                reject(e);\r\n            }\r\n\r\n            // initiate request\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create the JSON data asset from object or string.\r\n     * @param {Object|String} source Data to create asset from.\r\n     * @returns {Promise} Promise to resolve when asset is ready.\r\n     */\r\n    create(source)\r\n    {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            // make sure data is a valid json + clone it\r\n            try\r\n            {\r\n                if (source) {\r\n                    if (typeof source === 'string') {\r\n                        source = JSON.parse(source);\r\n                    }\r\n                    else {\r\n                        source = JSON.parse(JSON.stringify(source));\r\n                    }\r\n                }\r\n                else {\r\n                    source = {};\r\n                }\r\n            }\r\n            catch (e)\r\n            {\r\n                return reject(\"Data is not a valid JSON serializable object!\");\r\n            }\r\n\r\n            // store data and resolve\r\n            this._data = source;\r\n            this._notifyReady();\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get json data.\r\n     * @returns {*} Data as dictionary.\r\n     */\r\n    get data()\r\n    {\r\n        return this._data;\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    get valid()\r\n    {\r\n        return Boolean(this._data);\r\n    }\r\n    \r\n    /** @inheritdoc */\r\n    destroy()\r\n    {\r\n        this._data = null;\r\n    }\r\n}\r\n\r\n\r\n// export the asset type.\r\nmodule.exports = JsonAsset;", "/**\r\n * Implement the assets manager.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\assets\\assets.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst SoundAsset = require('../assets/sound_asset.js');\r\nconst IManager = require('../manager.js');\r\nconst BinaryAsset = require('./binary_asset.js');\r\nconst JsonAsset = require('./json_asset.js');\r\nconst TextureAsset = require('./texture_asset.js');\r\nconst FontTextureAsset = require('./font_texture_asset');\r\nconst Asset = require('./asset.js');\r\nconst _logger = require('../logger.js').getLogger('assets');\r\n\r\n\r\n/**\r\n * Assets manager class.\r\n * Used to create, load and cache game assets, which includes textures, audio files, JSON objects, etc.\r\n * As a rule of thumb, all methods to load or create assets are async and return a promise.\r\n * \r\n * To access the Assets manager you use `Shaku.assets`. \r\n */\r\nclass Assets extends IManager\r\n{\r\n    /**\r\n     * Create the manager.\r\n     */\r\n    constructor()\r\n    {\r\n        super();\r\n        this._loaded = null;\r\n        this._waitingAssets = new Set();\r\n\t\tthis._failedAssets = new Set();\r\n        this._successfulLoadedAssetsCount = 0;\r\n\r\n        /**\r\n         * Optional URL root to prepend to all loaded assets URLs.\r\n         * For example, if all your assets are under '/static/assets/', you can set this url as root and omit it when loading assets later.\r\n         */\r\n        this.root = '';\r\n\r\n        /**\r\n         * Optional suffix to add to all loaded assets URLs.\r\n         * You can use this for anti-cache mechanism if you want to reload all assets. For example, you can set this value to \"'?dt=' + Date.now()\".\r\n         */\r\n        this.suffix = '';\r\n    }\r\n\r\n    /**\r\n     * Wrap a URL with 'root' and 'suffix'.\r\n     * @param {String} url Url to wrap.\r\n     * @returns {String} Wrapped URL.\r\n     */\r\n    _wrapUrl(url)\r\n    {\r\n        if (!url) { return url; }\r\n        return this.root + url + this.suffix;\r\n    }\r\n\r\n    /**\r\n     * Get list of assets waiting to be loaded.\r\n     * This list will be reset if you call clearCache().\r\n     * @returns {Array<string>} URLs of assets waiting to be loaded.\r\n     */\r\n    get pendingAssets()\r\n    {\r\n        return Array.from(this._waitingAssets);\r\n    }\r\n\t\r\n    /**\r\n     * Get list of assets that failed to load.\r\n     * This list will be reset if you call clearCache().\r\n     * @returns {Array<string>} URLs of assets that had error loading.\r\n     */\t\r\n\tget failedAssets()\r\n\t{\r\n\t\treturn Array.from(this._failedAssets);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Return a promise that will be resolved only when all pending assets are loaded.\r\n\t * If an asset fails, will reject.\r\n     * @example\r\n     * await Shaku.assets.waitForAll();\r\n     * console.log(\"All assets are loaded!\");\r\n     * @returns {Promise} Promise to resolve when all assets are loaded, or reject if there are failed assets.\r\n\t */\r\n\twaitForAll()\r\n\t{\r\n\t\treturn new Promise((resolve, reject) => {\r\n            \r\n            _logger.debug(\"Waiting for all assets..\");\r\n\r\n            // check if all assets are loaded or if there are errors\r\n\t\t\tlet checkAssets = () => {\r\n\r\n                // got errors?\r\n                if (this._failedAssets.size !== 0) {\r\n                    _logger.warn(\"Done waiting for assets: had errors.\");\r\n                    return reject(this.failedAssets);\r\n                }\r\n\r\n                // all done?\r\n\t\t\t\tif (this._waitingAssets.size === 0) {\r\n                    _logger.debug(\"Done waiting for assets: everything loaded successfully.\");\r\n\t\t\t\t\treturn resolve();\r\n\t\t\t\t}\r\n\r\n                // try again in 1 ms\r\n\t\t\t\tsetTimeout(checkAssets, 1);\r\n\t\t\t};\r\n\r\n\t\t\tcheckAssets();\r\n\t\t});\r\n\t}\r\n\r\n    /** \r\n     * @inheritdoc\r\n     * @private\r\n     */\r\n    setup()\r\n    {        \r\n        return new Promise((resolve, reject) => {\r\n            _logger.info(\"Setup assets manager..\");\r\n            this._loaded = {};\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc\r\n     * @private\r\n     */\r\n    startFrame()\r\n    {\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc\r\n     * @private\r\n     */\r\n    endFrame()\r\n    {\r\n    }\r\n\r\n    /**\r\n     * Get already-loaded asset from cache.\r\n     * @private\r\n     * @param {String} url Asset URL.\r\n     * @param {type} type If provided will make sure asset is of this type. If asset found but have wrong type, will throw exception.\r\n     * @returns Loaded asset or null if not found.\r\n     */\r\n    _getFromCache(url, type)\r\n    {\r\n        let cached = this._loaded[url] || null;\r\n        if (cached && type) {\r\n            if (!(cached instanceof type)) { \r\n                throw new Error(`Asset with URL '${url}' is already loaded, but has unexpected type (expecting ${type})!`); \r\n            }\r\n        }\r\n        return cached;\r\n    }\r\n\r\n    /**\r\n     * Load an asset of a given type and add to cache when done.\r\n     * @private\r\n     * @param {Asset} newAsset Asset instance to load.\r\n     * @param {*} params Optional loading params.\r\n     */\r\n    async _loadAndCacheAsset(newAsset, params)\r\n    {\r\n        // extract url and typename, and add to cache\r\n        let url = newAsset.url;\r\n        let typeName = newAsset.constructor.name;\r\n        this._loaded[url] = newAsset;\r\n        this._waitingAssets.add(url);\r\n\r\n        // initiate loading\r\n        return new Promise(async (resolve, reject) => {\r\n\r\n            // load asset\r\n            _logger.debug(`Load asset [${typeName}] from URL '${url}'.`);\r\n            try {\r\n                await newAsset.load(params);\r\n            }\r\n            catch (e) {\r\n                _logger.warn(`Failed to load asset [${typeName}] from URL '${url}'.`);\r\n                this._failedAssets.add(url);\r\n                return reject(e);\r\n            }\r\n\r\n            // update waiting assets count\r\n            this._waitingAssets.delete(url);\r\n\r\n            // make sure valid\r\n            if (!newAsset.valid) {\r\n                _logger.warn(`Failed to load asset [${typeName}] from URL '${url}'.`);\r\n                this._failedAssets.add(url);\r\n                return reject(\"Loaded asset is not valid!\");\r\n            }\r\n\r\n            _logger.debug(`Successfully loaded asset [${typeName}] from URL '${url}'.`);\r\n\r\n            // resolve\r\n            this._successfulLoadedAssetsCount++;\r\n            resolve(newAsset);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get asset directly from cache, synchronous and without a Promise.\r\n     * @param {String} url Asset URL or name. \r\n     * @returns {Asset} Asset or null if not loaded.\r\n     */\r\n    getCached(url)\r\n    {\r\n        url = this._wrapUrl(url);\r\n        return this._loaded[url] || null;\r\n    }\r\n\r\n    /**\r\n     * Get / load asset of given type, and return a promise to be resolved when ready.\r\n     * @private\r\n     */\r\n    _loadAssetType(url, typeClass, params)\r\n    {\r\n        // normalize URL\r\n        url = this._wrapUrl(url);\r\n\r\n        // try to get from cache\r\n        let _asset = this._getFromCache(url, typeClass);\r\n        \r\n        // check if need to create new and load\r\n        var needLoad = false;\r\n        if (!_asset) {\r\n            _asset = new typeClass(url);\r\n            needLoad = true;\r\n        }\r\n        \r\n        // create promise to load asset\r\n        let promise = new Promise(async (resolve, reject) => {\r\n            if (needLoad) {\r\n                await this._loadAndCacheAsset(_asset, params);\r\n            }\r\n            _asset.onReady(() => {\r\n                resolve(_asset);\r\n            });\r\n        });\r\n\r\n        // return promise with asset attached to it\r\n        promise.asset = _asset;\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Create and init asset of given class type.\r\n     * @private\r\n     */\r\n    _createAsset(name, classType, initMethod)\r\n    {\r\n        // create asset\r\n        name = this._wrapUrl(name);\r\n        var _asset = new classType(name || generateRandomAssetName());\r\n\r\n        // generate render target in async\r\n        let promise = new Promise(async (resolve, reject) => {\r\n\r\n            // make sure not in cache\r\n            if (name && this._loaded[name]) { return reject(`Asset of type '${classType.name}' to create with URL '${name}' already exist in cache!`); }\r\n\r\n            // create and return\r\n            initMethod(_asset);\r\n            if (name) { this._loaded[name] = _asset; }\r\n            resolve(_asset);\r\n        });\r\n\r\n        // attach asset to promise\r\n        promise.asset = _asset;\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Load a sound asset. If already loaded, will use cache.\r\n     * @example\r\n     * let sound = await Shaku.assets.loadSound(\"assets/my_sound.ogg\");\r\n     * @param {String} url Asset URL.\r\n     * @returns {Promise<SoundAsset>} promise to resolve with asset instance, when loaded. You can access the loading asset with `.asset` on the promise.\r\n     */\r\n    loadSound(url)\r\n    {\r\n        return this._loadAssetType(url, SoundAsset, undefined);\r\n    }\r\n\r\n    /**\r\n     * Load a texture asset. If already loaded, will use cache.\r\n     * @example\r\n     * let texture = await Shaku.assets.loadTexture(\"assets/my_texture.png\", {generateMipMaps: false});\r\n     * @param {String} url Asset URL.\r\n     * @param {*} params Optional params dictionary. See TextureAsset.load() for more details.\r\n     * @returns {Promise<TextureAsset>} promise to resolve with asset instance, when loaded. You can access the loading asset with `.asset` on the promise.\r\n     */\r\n    loadTexture(url, params)\r\n    {\r\n        return this._loadAssetType(url, TextureAsset, params);\r\n    }\r\n\r\n    /**\r\n     * Create a render target texture asset. If already loaded, will use cache.\r\n     * @example\r\n     * let width = 512;\r\n     * let height = 512;\r\n     * let renderTarget = await Shaku.assets.createRenderTarget(\"optional_render_target_asset_id\", width, height);\r\n     * @param {String | null} name Asset name (matched to URLs when using cache). If null, will not add to cache.\r\n     * @param {Number} width Texture width.\r\n     * @param {Number} height Texture height.\r\n     * @param {Number} channels Texture channels count. Defaults to 4 (RGBA).\r\n     * @returns {Promise<TextureAsset>} promise to resolve with asset instance, when loaded. You can access the loading asset with `.asset` on the promise.\r\n     */\r\n    createRenderTarget(name, width, height, channels)\r\n    {\r\n        // make sure we have valid size\r\n        if (!width || !height) {\r\n            throw new Error(\"Missing or invalid size!\");\r\n        }\r\n\r\n        // create asset and return promise\r\n        return this._createAsset(name, TextureAsset, (asset) => {\r\n            asset.createRenderTarget(width, height, channels);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Load a font texture asset. If already loaded, will use cache.\r\n     * @example\r\n     * let fontTexture = await Shaku.assets.loadFontTexture('assets/DejaVuSansMono.ttf', {fontName: 'DejaVuSansMono'});\r\n     * @param {String} url Asset URL.\r\n     * @param {*} params Optional params dictionary. See FontTextureAsset.load() for more details.\r\n     * @returns {Promise<Asset>} promise to resolve with asset instance, when loaded. You can access the loading asset with `.asset` on the promise.\r\n     */\r\n    loadFontTexture(url, params)\r\n    {\r\n        return this._loadAssetType(url, FontTextureAsset, params);\r\n    }\r\n    \r\n    /**\r\n     * Load a json asset. If already loaded, will use cache.\r\n     * @example\r\n     * let jsonData = await Shaku.assets.loadJson('assets/my_json_data.json');\r\n     * console.log(jsonData.data);\r\n     * @param {String} url Asset URL.\r\n     * @returns {Promise<Asset>} promise to resolve with asset instance, when loaded. You can access the loading asset with `.asset` on the promise.\r\n     */\r\n    loadJson(url)\r\n    {\r\n        return this._loadAssetType(url, JsonAsset);\r\n    }\r\n \r\n    /**\r\n     * Create a new json asset. If already exist, will reject promise.\r\n     * @example\r\n     * let jsonData = await Shaku.assets.createJson('optional_json_data_id', {\"foo\": \"bar\"});\r\n     * // you can now load this asset from anywhere in your code using 'optional_json_data_id' as url\r\n     * @param {String} name Asset name (matched to URLs when using cache). If null, will not add to cache.\r\n     * @param {Object|String} data Optional starting data.\r\n     * @returns {Promise<Asset>} promise to resolve with asset instance, when ready. You can access the loading asset with `.asset` on the promise.\r\n     */\r\n    createJson(name, data)\r\n    {\r\n        // make sure we have valid data\r\n        if (!data) {\r\n            return reject(\"Missing or invalid data!\");\r\n        }\r\n\r\n        // create asset and return promise\r\n        return this._createAsset(name, JsonAsset, (asset) => {\r\n            asset.create(data);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a binary data asset. If already loaded, will use cache.\r\n     * @example\r\n     * let binData = await Shaku.assets.loadBinary('assets/my_bin_data.dat');\r\n     * console.log(binData.data);\r\n     * @param {String} url Asset URL.\r\n     * @returns {Promise<Asset>} promise to resolve with asset instance, when loaded. You can access the loading asset with `.asset` on the promise.\r\n     */\r\n    loadBinary(url)\r\n    {\r\n        return this._loadAssetType(url, BinaryAsset);\r\n    }\r\n\r\n    /**\r\n     * Create a new binary asset. If already exist, will reject promise.\r\n     * @example\r\n     * let binData = await Shaku.assets.createBinary('optional_bin_data_id', [1,2,3,4]);\r\n     * // you can now load this asset from anywhere in your code using 'optional_bin_data_id' as url\r\n     * @param {String} name Asset name (matched to URLs when using cache). If null, will not add to cache.\r\n     * @param {Array<Number>|Uint8Array} data Binary data to set.\r\n     * @returns {Promise<Asset>} promise to resolve with asset instance, when ready. You can access the loading asset with `.asset` on the promise.\r\n     */\r\n    createBinary(name, data)\r\n    {\r\n        // make sure we have valid data\r\n        if (!data) {\r\n            return reject(\"Missing or invalid data!\");\r\n        }\r\n\r\n        // create asset and return promise\r\n        return this._createAsset(name, BinaryAsset, (asset) => {\r\n            asset.create(data);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Destroy and free asset from cache.\r\n     * @example\r\n     * Shaku.assets.free(\"my_asset_url\");\r\n     * @param {String} url Asset URL to free.\r\n     */\r\n    free(url)\r\n    {\r\n        url = this._wrapUrl(url);\r\n        let asset = this._loaded[url];\r\n        if (asset) {\r\n            asset.destroy();\r\n            delete this._loaded[url];\r\n        }\r\n    }\r\n\t\r\n\t/**\r\n\t * Free all loaded assets from cache.\r\n     * @example\r\n     * Shaku.assets.clearCache();\r\n\t */\r\n\tclearCache()\r\n\t{\r\n\t\tfor (let key in this._loaded) {\r\n            this._loaded[key].destroy();\r\n        }\r\n        this._loaded = {};\r\n        this._waitingAssets = new Set();\r\n\t\tthis._failedAssets = new Set();\r\n\t}\r\n\r\n    /** \r\n     * @inheritdoc\r\n     * @private\r\n     */\r\n    destroy()\r\n    {\r\n\t\tthis.clearCache();\r\n    }\r\n}\r\n\r\n// generate a random asset URL, for when creating assets that are outside of cache.\r\nvar _nextRandomAssetId = 0;\r\nfunction generateRandomAssetName()\r\n{\r\n    return \"_runtime_asset_\" + (_nextRandomAssetId++) + \"_\";\r\n}\r\n \r\n// export assets manager\r\nmodule.exports = new Assets();", "/**\r\n * Just an alias to main manager so we can require() this folder as a package.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\assets\\index.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n module.exports = require('./assets');", "/**\r\n * Implement collision shape base class.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\shapes\\shape.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Color = require(\"../../utils/color\");\r\nconst Rectangle = require(\"../../utils/rectangle\");\r\nconst Vector2 = require(\"../../utils/vector2\");\r\nconst CollisionWorld = require(\"../collision_world\");\r\n\r\n \r\n/**\r\n * Collision shape base class.\r\n */\r\nclass CollisionShape\r\n{\r\n    /**\r\n     * Create the collision shape.\r\n     */\r\n    constructor()\r\n    {\r\n        this._world = null;\r\n        this._worldRange = null;\r\n        this._debugColor = null;\r\n        this._forceDebugColor = null;\r\n        this._collisionFlags = Number.MAX_SAFE_INTEGER;\r\n    }\r\n\r\n    /**\r\n     * Get the collision shape's unique identifier.\r\n     * @returns {String} Shape's unique identifier\r\n     */\r\n    get shapeId()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Get collision flags (matched against collision mask when checking collision).\r\n     */\r\n    get collisionFlags()\r\n    {\r\n        return this._collisionFlags;\r\n    }\r\n\r\n    /**\r\n     * Set collision flags (matched against collision mask when checking collision).\r\n     */\r\n    set collisionFlags(value)\r\n    {\r\n        this._debugColor = null;\r\n        this._collisionFlags = value;\r\n        return this._collisionFlags;\r\n    }\r\n\r\n    /**\r\n     * Set the debug color to use to draw this shape.\r\n     * @param {Color} color Color to set or null to use default.\r\n     */\r\n    setDebugColor(color)\r\n    {\r\n        this._forceDebugColor = color;\r\n    }\r\n\r\n    /**\r\n     * Debug draw this shape.\r\n     * @param {Number} opacity Shape opacity factor.\r\n     */\r\n    debugDraw(opacity)\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n    \r\n    /**\r\n     * Get shape center position.\r\n     * @returns {Vector2} Center position.\r\n     */\r\n    getCenter()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Remove self from parent world object.\r\n     */\r\n    remove()\r\n    {\r\n        if (this._world) {\r\n            this._world.removeShape(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get debug drawing color.\r\n     * @private\r\n     */\r\n    _getDebugColor()\r\n    {\r\n        // use forced debug color\r\n        if (this._forceDebugColor) {\r\n            return this._forceDebugColor.clone();\r\n        }\r\n\r\n        // calculate debug color\r\n        if (!this._debugColor) {\r\n            this._debugColor = this._getDefaultDebugColorFor(this.collisionFlags);\r\n        }\r\n\r\n        // return color\r\n        return this._debugColor.clone();\r\n    }\r\n\r\n    /**\r\n     * Get default debug colors for given collision flags.\r\n     * @private\r\n     */\r\n    _getDefaultDebugColorFor(flags)\r\n    {\r\n        return defaultDebugColors[flags % defaultDebugColors.length];\r\n    }\r\n\r\n    /**\r\n     * Get collision shape's estimated radius box.\r\n     * @private\r\n     * @returns {Number} Shape's radius\r\n     */\r\n    _getRadius()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n\r\n    /**\r\n     * Get collision shape's bounding box.\r\n     * @private\r\n     * @returns {Rectangle} Shape's bounding box.\r\n     */\r\n    _getBoundingBox()\r\n    {\r\n        throw new Error(\"Not Implemented!\");\r\n    }\r\n    \r\n    /**\r\n     * Set the parent collision world this shape is currently in.\r\n     * @private\r\n     * @param {CollisionWorld} world New parent collision world or null to remove.\r\n     */\r\n    _setParent(world)\r\n    {\r\n        // same world? skip\r\n        if (world === this._world) {\r\n            return;\r\n        }\r\n\r\n        // we already have a world but try to set a new one? error\r\n        if (this._world && world) {\r\n            throw new Error(\"Cannot add collision shape to world while its already in another world!\");\r\n        }\r\n\r\n        // set new world\r\n        this._world = world;\r\n        this._worldRange = null;\r\n    }\r\n\r\n    /**\r\n     * Called when the collision shape changes and we need to update the parent world.\r\n     * @private\r\n     */\r\n    _shapeChanged()\r\n    {\r\n        if (this._world) {\r\n            this._world._queueUpdate(this);\r\n        }\r\n    }\r\n}\r\n\r\n// default debug colors to use\r\nconst defaultDebugColors = [Color.red, Color.blue, Color.green, Color.yellow, Color.purple, Color.teal, Color.brown, Color.orange, Color.khaki, Color.darkcyan, Color.cornflowerblue, Color.darkgray, Color.chocolate, Color.aquamarine, Color.cadetblue, Color.magenta, Color.seagreen, Color.pink, Color.olive, Color.violet];\r\n\r\n// export collision shape class\r\nmodule.exports = CollisionShape;", "/**\r\n * An object to store collision detection result.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\result.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Vector2 = require(\"../utils/vector2\");\r\nconst CollisionShape = require(\"./shapes/shape\");\r\n\r\n \r\n/**\r\n * Collision detection result.\r\n */\r\nclass CollisionTestResult\r\n{\r\n    /**\r\n     * Create the collision result.\r\n     * @param {Vector2} position Optional collision position.\r\n     * @param {CollisionShape} first First shape in the collision check.\r\n     * @param {CollisionShape} second Second shape in the collision check.\r\n     */\r\n    constructor(position, first, second)\r\n    {\r\n        /**\r\n         * Collision position, only relevant when there's a single touching point.\r\n         * For shapes with multiple touching points, this will be null.\r\n         */\r\n        this.position = position;\r\n\r\n        /**\r\n         * First collided shape.\r\n         */\r\n        this.first = first;\r\n\r\n        /**\r\n         * Second collided shape.\r\n         */\r\n        this.second = second;\r\n    }\r\n}\r\n\r\n// export collision shape class\r\nmodule.exports = CollisionTestResult;", "/**\r\n * Implement the collision resolver class.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\resolver.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Vector2 = require('../utils/vector2.js');\r\nconst CollisionTestResult = require('./result.js');\r\nconst CollisionShape = require('./shapes/shape.js');\r\nconst _logger = require('../logger.js').getLogger('collision');\r\n\r\n \r\n/**\r\n * The collision resolver is responsible to implement collision detection between pair of shapes of same or different types.\r\n */\r\nclass CollisionResolver\r\n{\r\n    /**\r\n     * Create the resolver.\r\n     */\r\n    constructor()\r\n    {\r\n        this._handlers = {};\r\n    }\r\n\r\n    /**\r\n     * Initialize the resolver.\r\n     * @private\r\n     */\r\n    _init()\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * Set the method used to test collision between two shapes.\r\n     * Note: you don't need to register the same handler twice for reverse order, its done automatically inside.\r\n     * @param {String} firstShapeId The shape identifier the handler recieves as first argument.\r\n     * @param {String} secondShapeId The shape identifier the handler recieves as second argument.\r\n     * @param {Function} handler Method to test collision between the shapes. Return false if don't collide, return either Vector2 with collision position or 'true' for collision.\r\n     */\r\n    setHandler(firstShapeId, secondShapeId, handler)\r\n    {\r\n        _logger.debug(`Register handler for shapes '${firstShapeId}' and '${secondShapeId}'.`);\r\n\r\n        // register handler\r\n        if (!this._handlers[firstShapeId]) { this._handlers[firstShapeId] = {}; }\r\n        this._handlers[firstShapeId][secondShapeId] = handler;\r\n\r\n        // register reverse order handler\r\n        if (firstShapeId !== secondShapeId) {\r\n            if (!this._handlers[secondShapeId]) { this._handlers[secondShapeId] = {}; }\r\n            this._handlers[secondShapeId][firstShapeId] = (f, s) => { return handler(s, f); };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check a collision between two shapes.\r\n     * @param {CollisionShape} first First collision shape to test.\r\n     * @param {CollisionShape} second Second collision shape to test.\r\n     * @returns {CollisionTestResult} collision detection result or null if they don't collide.\r\n     */\r\n    test(first, second)\r\n    {\r\n        let handler = this._getCollisionMethod(first, second);\r\n        return this.testWithHandler(first, second, handler);\r\n    }\r\n\r\n    /**\r\n     * Check a collision between two shapes.\r\n     * @param {CollisionShape} first First collision shape to test.\r\n     * @param {CollisionShape} second Second collision shape to test.\r\n     * @param {Function} handler Method to test collision between the shapes.\r\n     * @returns {CollisionTestResult} collision detection result or null if they don't collide.\r\n     */\r\n    testWithHandler(first, second, handler)\r\n    {\r\n        // missing handler?\r\n        if (!handler) {\r\n            _logger.warn(`Missing collision handler for shapes '${first.shapeId}' and '${second.shapeId}'.`);\r\n            return null;\r\n        }\r\n\r\n        // test collision\r\n        let result = handler(first, second);\r\n\r\n        // collision\r\n        if (result) {\r\n            let position = (result instanceof Vector2) ? result : null;\r\n            return new CollisionTestResult(position, first, second);\r\n        }\r\n\r\n        // no collision\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get handlers dictionary for a given shape.\r\n     */\r\n    getHandlers(shape)\r\n    {\r\n        return this._handlers[shape.shapeId];\r\n    }\r\n    \r\n    /**\r\n     * Get the collision detection method for two given shapes.\r\n     * @private\r\n     * @param {CollisionShape} first First collision shape to test.\r\n     * @param {CollisionShape} second Second collision shape to test.\r\n     * @returns {Function} collision detection method or null if not found.\r\n     */\r\n    _getCollisionMethod(first, second)\r\n    {\r\n        let handlersFrom = this._handlers[first.shapeId];\r\n        if (handlersFrom) {\r\n            return handlersFrom[second.shapeId] || null;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n// export the collision resolver\r\nmodule.exports = CollisionResolver;", "/**\r\n * Implement collision point.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\shapes\\point.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\nconst CollisionShape = require(\"./shape\");\r\nconst gfx = require('./../../gfx');\r\nconst Vector2 = require(\"../../utils/vector2\");\r\nconst Rectangle = require(\"../../utils/rectangle\");\r\nconst Circle = require(\"../../utils/circle\");\r\n\r\n\r\n/**\r\n * Collision point class.\r\n */\r\nclass PointShape extends CollisionShape\r\n{\r\n    /**\r\n     * Create the collision shape.\r\n     * @param {Vector2} position Point position.\r\n     */\r\n    constructor(position)\r\n    {\r\n        super();\r\n        this.setPosition(position);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get shapeId()\r\n    {\r\n        return \"point\";\r\n    }\r\n    \r\n    /**\r\n     * Set this collision shape from vector2.\r\n     * @param {Vector2} position Point position.\r\n     */\r\n    setPosition(position)\r\n    {\r\n        this._position = position.clone();\r\n        this._boundingBox = new Rectangle(position.x, position.y, 1, 1);\r\n        this._shapeChanged();\r\n    }\r\n\r\n    /**\r\n     * Get point position.\r\n     * @returns {Vector2} Point position.\r\n     */\r\n    getPosition()\r\n    {\r\n        return this._position.clone();\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    getCenter()\r\n    {\r\n        return this._position.clone();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    _getRadius()\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    _getBoundingBox()\r\n    {\r\n        return this._boundingBox;\r\n    }\r\n\r\n    /**\r\n     * Debug draw this shape.\r\n     * @param {Number} opacity Shape opacity factor.\r\n     */\r\n    debugDraw(opacity)\r\n    {\r\n        if (opacity === undefined) opacity = 1;\r\n        let color = this._getDebugColor();\r\n        color.a *= opacity;\r\n        gfx.outlineCircle(new Circle(this.getPosition(), 3), color, gfx.BlendModes.AlphaBlend, 4);\r\n    }\r\n}\r\n\r\n// export collision shape class\r\nmodule.exports = PointShape;", "/**\r\n * Implement collision circle.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\shapes\\circle.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\nconst CollisionShape = require(\"./shape\");\r\nconst gfx = require('./../../gfx');\r\nconst Circle = require(\"../../utils/circle\");\r\nconst Rectangle = require(\"../../utils/rectangle\");\r\n\r\n\r\n/**\r\n * Collision circle class.\r\n */\r\nclass CircleShape extends CollisionShape\r\n{\r\n    /**\r\n     * Create the collision shape.\r\n     * @param {Circle} circle the circle shape.\r\n     */\r\n    constructor(circle)\r\n    {\r\n        super();\r\n        this.setShape(circle);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get shapeId()\r\n    {\r\n        return \"circle\";\r\n    }\r\n\r\n    /**\r\n     * Set this collision shape from circle.\r\n     * @param {Circle} circle Circle shape.\r\n     */\r\n    setShape(circle)\r\n    {\r\n        this._circle = circle;\r\n        this._position = circle.center;\r\n        this._boundingBox = new Rectangle(circle.center.x - circle.radius, circle.center.y - circle.radius, circle.radius * 2, circle.radius * 2);\r\n        this._shapeChanged();\r\n    }\r\n \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    _getRadius()\r\n    {\r\n        return this._circle.radius;\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    getCenter()\r\n    {\r\n        return this._position.clone();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    _getBoundingBox()\r\n    {\r\n        return this._boundingBox;\r\n    }\r\n\r\n    /**\r\n     * Debug draw this shape.\r\n     * @param {Number} opacity Shape opacity factor.\r\n     */\r\n    debugDraw(opacity)\r\n    {\r\n        if (opacity === undefined) opacity = 1;\r\n        let color = this._getDebugColor();\r\n\r\n        color.a *= opacity;\r\n        gfx.outlineCircle(this._circle, color, gfx.BlendModes.AlphaBlend, 14);\r\n\r\n        color.a *= 0.25;\r\n        gfx.fillCircle(this._circle, color, gfx.BlendModes.AlphaBlend, 14);\r\n    }\r\n}\r\n\r\n// export collision shape class\r\nmodule.exports = CircleShape;", "/**\r\n * Implement the collision manager.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\collision_world.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst Color = require(\"../utils/color\");\r\nconst Vector2 = require(\"../utils/vector2\");\r\nconst Circle = require(\"../utils/circle\");\r\nconst CollisionTestResult = require(\"./result\");\r\nconst CollisionShape = require(\"./shapes/shape\");\r\nconst gfx = require('./../gfx');\r\nconst Rectangle = require(\"../utils/rectangle\");\r\nconst CollisionResolver = require(\"./resolver\");\r\nconst PointShape = require(\"./shapes/point\");\r\nconst CircleShape = require(\"./shapes/circle\");\r\nconst _logger = require('../logger.js').getLogger('collision');\r\n\r\n\r\n/**\r\n * A collision world is a set of collision shapes that interact with each other.\r\n * You can use different collision worlds to represent different levels or different parts of your game world.\r\n */\r\nclass CollisionWorld\r\n{\r\n    /**\r\n     * Create the collision world.\r\n     * @param {CollisionResolver} resolver Collision resolver to use for this world.\r\n     * @param {Number|Vector2} gridCellSize For optimize collision testing, the collision world is divided into a collision grid. This param determine the grid cell size.\r\n     */\r\n    constructor(resolver, gridCellSize)\r\n    {\r\n        /**\r\n         * Collision resolver used in this collision world.\r\n         * By default, will inherit the collision manager default resolver.\r\n         */\r\n        this.resolver = resolver;\r\n\r\n        // set grid cell size\r\n        if (typeof gridCellSize === 'undefined') { gridCellSize = new Vector2(512, 512); }\r\n        else if (typeof gridCellSize === 'number') { gridCellSize = new Vector2(gridCellSize, gridCellSize); }\r\n        else { gridCellSize = gridCellSize.clone(); }\r\n        this._gridCellSize = gridCellSize;\r\n\r\n        // create collision grid\r\n        this._grid = {};\r\n\r\n        // shapes that need updates and grid chunks to delete\r\n        this._shapesToUpdate = new Set();\r\n        this._cellsToDelete = new Set();\r\n    }\r\n\r\n    /**\r\n     * Do collision world updates, if we have any.\r\n     * @private\r\n     */\r\n    _performUpdates()\r\n    {\r\n        // delete empty grid cells\r\n        if (this._cellsToDelete.size > 0) {\r\n            for (let key of this._cellsToDelete) {\r\n                if (this._grid[key] && this._grid[key].size === 0) { \r\n                    delete this._grid[key];\r\n                }\r\n            }\r\n            this._cellsToDelete.clear();\r\n        }\r\n\r\n        // update all shapes\r\n        if (this._shapesToUpdate.size > 0) {\r\n            for (let shape of this._shapesToUpdate) {\r\n                this._updateShape(shape);\r\n            }\r\n            this._shapesToUpdate.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update a shape in collision world after it moved or changed.\r\n     * @private\r\n     */\r\n    _updateShape(shape)\r\n    {\r\n        // sanity - if no longer in this collision world, skip\r\n        if (shape._world !== this) {\r\n            return;\r\n        }\r\n\r\n        // get new range\r\n        let bb = shape._getBoundingBox();\r\n        let minx = Math.floor(bb.left / this._gridCellSize.x);\r\n        let miny = Math.floor(bb.top / this._gridCellSize.y);\r\n        let maxx = Math.ceil(bb.right / this._gridCellSize.x);\r\n        let maxy = Math.ceil(bb.bottom / this._gridCellSize.y);\r\n\r\n        // change existing grid cells\r\n        if (shape._worldRange)\r\n        {\r\n            // range is the same? skip\r\n            if (shape._worldRange[0] === minx && \r\n                shape._worldRange[1] === miny &&\r\n                shape._worldRange[2] === maxx && \r\n                shape._worldRange[3] === maxy) {\r\n                return;\r\n            }\r\n\r\n            // get old range\r\n            let ominx = shape._worldRange[0];\r\n            let ominy = shape._worldRange[1];\r\n            let omaxx = shape._worldRange[2];\r\n            let omaxy = shape._worldRange[3];\r\n\r\n            // first remove from old chunks we don't need\r\n            for (let i = ominx; i < omaxx; ++i) {\r\n                for (let j = ominy; j < omaxy; ++j) {\r\n\r\n                    // if also in new range, don't remove\r\n                    if (i >= minx && i < maxx && j >= miny && j < maxy) {\r\n                        continue;\r\n                    }\r\n\r\n                    // remove from cell\r\n                    let key = i + ',' + j;\r\n                    let currSet = this._grid[key];\r\n                    if (currSet) {\r\n                        currSet.delete(shape);\r\n                        if (currSet.size === 0) {\r\n                            this._cellsToDelete.add(key);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // now add to new cells\r\n            for (let i = minx; i < maxx; ++i) {\r\n                for (let j = miny; j < maxy; ++j) {\r\n\r\n                    // if was in old range, don't add\r\n                    if (i >= ominx && i < omaxx && j >= ominy && j < omaxy) {\r\n                        continue;\r\n                    }\r\n\r\n                    // add to new cell\r\n                    let key = i + ',' + j;\r\n                    let currSet = this._grid[key];\r\n                    if (!currSet) { \r\n                        this._grid[key] = currSet = new Set(); \r\n                    }\r\n                    currSet.add(shape);\r\n                }\r\n            }\r\n        }\r\n        // first-time adding to grid\r\n        else {\r\n            for (let i = minx; i < maxx; ++i) {\r\n                for (let j = miny; j < maxy; ++j) {\r\n                    let key = i + ',' + j;\r\n                    let currSet = this._grid[key];\r\n                    if (!currSet) { \r\n                        this._grid[key] = currSet = new Set(); \r\n                    }\r\n                    currSet.add(shape);\r\n                }\r\n            }\r\n        }\r\n\r\n        // update new range\r\n        shape._worldRange = [minx, miny, maxx, maxy];\r\n    }\r\n\r\n    /**\r\n     * Request update for this shape on next updates call.\r\n     * @private\r\n     */\r\n    _queueUpdate(shape)\r\n    {\r\n        this._shapesToUpdate.add(shape);\r\n    }\r\n\r\n    /**\r\n     * Iterate all shapes in world.\r\n     * @param {Function} callback Callback to invoke on all shapes. Return false to break iteration.\r\n     */\r\n    iterateShapes(callback)\r\n    {\r\n        for (let key in this._grid) {\r\n            let cell = this._grid[key];\r\n            if (cell) {\r\n                for (let shape of cell)\r\n                {\r\n                    if (callback(shape) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a collision shape to this world.\r\n     * @param {CollisionShape} shape Shape to add.\r\n     */\r\n    addShape(shape)\r\n    {\r\n        // add shape\r\n        shape._setParent(this);\r\n\r\n        // add shape to grid\r\n        this._updateShape(shape);\r\n\r\n        // do general updates\r\n        this._performUpdates();\r\n    }\r\n\r\n    /**\r\n     * Remove a collision shape from this world.\r\n     * @param {CollisionShape} shape Shape to remove.\r\n     */\r\n    removeShape(shape)\r\n    {\r\n        // sanity\r\n        if (shape._world !== this) {\r\n            _logger.warn(\"Shape to remove is not in this collision world!\");\r\n            return;\r\n        }\r\n\r\n        // remove from grid\r\n        if (shape._worldRange) {\r\n            let minx = shape._worldRange[0];\r\n            let miny = shape._worldRange[1];\r\n            let maxx = shape._worldRange[2];\r\n            let maxy = shape._worldRange[3];\r\n            for (let i = minx; i < maxx; ++i) {\r\n                for (let j = miny; j < maxy; ++j) {\r\n                    let key = i + ',' + j;\r\n                    let currSet = this._grid[key];\r\n                    if (currSet) {\r\n                        currSet.delete(shape);\r\n                        if (currSet.size === 0) {\r\n                            this._cellsToDelete.add(key);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // remove shape\r\n        this._shapesToUpdate.delete(shape);\r\n        shape._setParent(null);\r\n\r\n        // do general updates\r\n        this._performUpdates();\r\n    }\r\n\r\n    /**\r\n     * Iterate shapes that match broad phase test.\r\n     * @private\r\n     * @param {CollisionShape} shape Shape to test.\r\n     * @param {Function} handler Method to run on all shapes in phase. Return true to continue iteration, false to break.\r\n     * @param {Number} mask Optional mask of bits to match against shapes collisionFlags. Will only return shapes that have at least one common bit.\r\n     * @param {Function} predicate Optional filter to run on any shape we're about to test collision with.\r\n     */\r\n    _iterateBroadPhase(shape, handler, mask, predicate)\r\n    {\r\n        // get grid range\r\n        let bb = shape._getBoundingBox();\r\n        let minx = Math.floor(bb.left / this._gridCellSize.x);\r\n        let miny = Math.floor(bb.top / this._gridCellSize.y);\r\n        let maxx = Math.ceil(bb.right / this._gridCellSize.x);\r\n        let maxy = Math.ceil(bb.bottom / this._gridCellSize.y);\r\n\r\n        // shapes we checked\r\n        let checked = new Set();\r\n\r\n        // iterate options\r\n        for (let i = minx; i < maxx; ++i) {\r\n            for (let j = miny; j < maxy; ++j) {\r\n\r\n                // get current grid chunk\r\n                let key = i + ',' + j;\r\n                let currSet = this._grid[key];\r\n\r\n                // iterate shapes in grid chunk\r\n                if (currSet) { \r\n                    for (let other of currSet) {\r\n\r\n                        // check collision flags\r\n                        if (mask && ((other.collisionFlags & mask) === 0)) {\r\n                            continue;\r\n                        }\r\n\r\n                        // skip if checked\r\n                        if (checked.has(other)) {\r\n                            continue;\r\n                        }\r\n                        checked.add(other);\r\n\r\n                        // skip self\r\n                        if (other === shape) {\r\n                            continue;\r\n                        }\r\n\r\n                        // use predicate\r\n                        if (predicate && !predicate(other)) {\r\n                            continue;\r\n                        }\r\n\r\n                        // invoke handler on shape\r\n                        let proceedLoop = Boolean(handler(other));\r\n\r\n                        // break loop\r\n                        if (!proceedLoop) {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test collision with shapes in world, and return just the first result found.\r\n     * @param {CollisionShape} sourceShape Source shape to check collision for. If shape is in world, it will not collide with itself.\r\n     * @param {Boolean} sortByDistance If true will return the nearest collision found (based on center of shapes).\r\n     * @param {Number} mask Optional mask of bits to match against shapes collisionFlags. Will only return shapes that have at least one common bit.\r\n     * @param {Function} predicate Optional filter to run on any shape we're about to test collision with. If the predicate returns false, we will skip this shape.\r\n     * @returns {CollisionTestResult} A collision test result, or null if not found.\r\n     */\r\n    testCollision(sourceShape, sortByDistance, mask, predicate)\r\n    {\r\n        // do updates before check\r\n        this._performUpdates();\r\n\r\n        // result to return\r\n        var result = null;\r\n\r\n        // hard case - single result, sorted by distance\r\n        if (sortByDistance)\r\n        {\r\n            // build options array\r\n            var options = [];\r\n            this._iterateBroadPhase(sourceShape, (other) => {\r\n                options.push(other);\r\n                return true;\r\n            }, mask, predicate);\r\n\r\n            // sort options\r\n            sortByDistanceShapes(sourceShape, options);\r\n\r\n            // check collision sorted\r\n            var handlers = this.resolver.getHandlers(sourceShape);\r\n            for (let other of options) {\r\n                result = this.resolver.testWithHandler(sourceShape, other, handlers[other.shapeId]);\r\n                if (result) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // easy case - single result, not sorted\r\n        else\r\n        {\r\n            // iterate possible shapes and test collision\r\n            var handlers = this.resolver.getHandlers(sourceShape);\r\n            this._iterateBroadPhase(sourceShape, (other) => {\r\n\r\n                // test collision and continue iterating if we don't have a result\r\n                result = this.resolver.testWithHandler(sourceShape, other, handlers[other.shapeId]);\r\n                return !result;\r\n\r\n            }, mask, predicate);\r\n        }\r\n\r\n        // return result\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Test collision with shapes in world, and return all results found.\r\n     * @param {CollisionShape} sourceShape Source shape to check collision for. If shape is in world, it will not collide with itself.\r\n     * @param {Boolean} sortByDistance If true will sort results by distance.\r\n     * @param {Number} mask Optional mask of bits to match against shapes collisionFlags. Will only return shapes that have at least one common bit.\r\n     * @param {Function} predicate Optional filter to run on any shape we're about to test collision with. If the predicate returns false, we will skip this shape.\r\n     * @param {Function} intermediateProcessor Optional method to run after each positive result with the collision result as param. Return false to stop and return results.\r\n     * @returns {Array<CollisionTestResult>} An array of collision test results, or empty array if none found.\r\n     */\r\n    testCollisionMany(sourceShape, sortByDistance, mask, predicate, intermediateProcessor)\r\n    {\r\n        // do updates before check\r\n        this._performUpdates();\r\n\r\n        // get collisions\r\n        var ret = [];\r\n        var handlers = this.resolver.getHandlers(sourceShape);\r\n        this._iterateBroadPhase(sourceShape, (other) => {\r\n            let result = this.resolver.testWithHandler(sourceShape, other, handlers[other.shapeId]);\r\n            if (result) {\r\n                ret.push(result);\r\n                if (intermediateProcessor && intermediateProcessor(result) === false) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }, mask, predicate);\r\n\r\n        // sort by distance\r\n        if (sortByDistance) {\r\n            sortByDistanceResults(sourceShape, ret);\r\n        }\r\n\r\n        // return results\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Return array of shapes that touch a given position, with optional radius.\r\n     * @example\r\n     * let shapes = world.pick(Shaku.input.mousePosition);\r\n     * @param {*} position Position to pick.\r\n     * @param {*} radius Optional picking radius to use a circle instead of a point.\r\n     * @param {*} sortByDistance If true, will sort results by distance from point.\r\n     * @param {*} mask Collision mask to filter by.\r\n     * @param {*} predicate Optional predicate method to filter by.\r\n     * @returns {Array<CollisionShape>} Array with collision shapes we picked.\r\n     */\r\n    pick(position, radius, sortByDistance, mask, predicate)\r\n    {\r\n        let shape = ((radius || 0) <= 1) ? new PointShape(position) : new CircleShape(new Circle(position, radius));\r\n        let ret = this.testCollisionMany(shape, sortByDistance, mask, predicate);\r\n        return ret.map(x => x.second);\r\n    }\r\n\r\n    /**\r\n     * Debug-draw the current collision world.\r\n     * @param {Color} gridColor Optional grid color (default to black).\r\n     * @param {Color} gridHighlitColor Optional grid color for cells with shapes in them (default to red).\r\n     * @param {Number} opacity Optional opacity factor (default to 0.5).\r\n     * @param {Camera} camera Optional camera for offset and viewport.\r\n     */\r\n    debugDraw(gridColor, gridHighlitColor, opacity, camera)\r\n    {\r\n        // do updates before check\r\n        this._performUpdates();\r\n        \r\n        // default grid colors\r\n        if (!gridColor) {\r\n            gridColor = Color.black;\r\n            gridColor.a *= 0.75;\r\n        }\r\n        if (!gridHighlitColor) {\r\n            gridHighlitColor = Color.red;\r\n            gridHighlitColor.a *= 0.75;\r\n        }\r\n\r\n        // default opacity\r\n        if (opacity === undefined) { \r\n            opacity = 0.5;\r\n        }\r\n\r\n        // set grid color opacity\r\n        gridColor.a *= opacity;\r\n        gridHighlitColor.a *= opacity;\r\n\r\n        // all shapes we rendered\r\n        let renderedShapes = new Set();\r\n\r\n        // get visible grid cells\r\n        let bb = camera ? camera.getRegion() : gfx.getRenderingRegion(false);\r\n        let minx = Math.floor(bb.left / this._gridCellSize.x);\r\n        let miny = Math.floor(bb.top / this._gridCellSize.y);\r\n        let maxx = minx + Math.ceil(bb.width / this._gridCellSize.x);\r\n        let maxy = miny + Math.ceil(bb.height / this._gridCellSize.y);\r\n        for (let i = minx; i <= maxx; ++i) {\r\n            for (let j = miny; j <= maxy; ++j) {\r\n\r\n                // get current cell\r\n                let cell = this._grid[i + ',' + j];\r\n\r\n                // draw grid cell\r\n                let color = (cell && cell.size) ? gridHighlitColor : gridColor;\r\n                let cellRect = new Rectangle(i * this._gridCellSize.x, j * this._gridCellSize.y, this._gridCellSize.x-1, this._gridCellSize.y-1);\r\n                gfx.outlineRect(cellRect, color, gfx.BlendModes.AlphaBlend, 0);\r\n\r\n                // draw shapes in grid\r\n                if (cell) {\r\n                    for (let shape of cell)\r\n                    {\r\n                        if (renderedShapes.has(shape)) {\r\n                            continue;\r\n                        }\r\n                        renderedShapes.add(shape);\r\n                        shape.debugDraw(opacity);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Sort array by distance from source shape.\r\n * @private\r\n */\r\nfunction sortByDistanceShapes(sourceShape, options)\r\n{\r\n    let sourceCenter = sourceShape.getCenter();\r\n    options.sort((a, b) => \r\n        (a.getCenter().distanceTo(sourceCenter) - a._getRadius()) - \r\n        (b.getCenter().distanceTo(sourceCenter) - b._getRadius()));\r\n}\r\n\r\n/**\r\n * Sort array by distance from source shape.\r\n * @private\r\n */\r\n function sortByDistanceResults(sourceShape, options)\r\n {\r\n     let sourceCenter = sourceShape.getCenter();\r\n     options.sort((a, b) => \r\n        (a.second.getCenter().distanceTo(sourceCenter) - a.second._getRadius()) - \r\n        (b.second.getCenter().distanceTo(sourceCenter) - b.second._getRadius()));\r\n }\r\n\r\n// export collision world\r\nmodule.exports = CollisionWorld;", "/**\r\n * Implement collision rectangle.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\shapes\\rectangle.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\nconst Rectangle = require(\"../../utils/rectangle\");\r\nconst CollisionShape = require(\"./shape\");\r\nconst gfx = require('./../../gfx');\r\n\r\n\r\n/**\r\n * Collision rectangle class.\r\n */\r\nclass RectangleShape extends CollisionShape\r\n{\r\n    /**\r\n     * Create the collision shape.\r\n     * @param {Rectangle} rectangle the rectangle shape.\r\n     */\r\n    constructor(rectangle)\r\n    {\r\n        super();\r\n        this.setShape(rectangle);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get shapeId()\r\n    {\r\n        return \"rect\";\r\n    }\r\n\r\n    /**\r\n     * Set this collision shape from rectangle.\r\n     * @param {Rectangle} rectangle Rectangle shape.\r\n     */\r\n    setShape(rectangle)\r\n    {\r\n        this._rect = rectangle;\r\n        this._center = rectangle.getCenter();\r\n        this._radius = this._rect.getBoundingCircle().radius;\r\n        this._shapeChanged();\r\n    }\r\n       \r\n    /**\r\n     * @inheritdoc\r\n     */ \r\n    _getRadius()\r\n    {\r\n        return this._radius;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    _getBoundingBox()\r\n    {\r\n        return this._rect;\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    getCenter()\r\n    {\r\n        return this._center.clone();\r\n    }\r\n    \r\n    /**\r\n     * Debug draw this shape.\r\n     * @param {Number} opacity Shape opacity factor.\r\n     */\r\n    debugDraw(opacity)\r\n    {\r\n        if (opacity === undefined) opacity = 1;\r\n        let color = this._getDebugColor();\r\n\r\n        color.a *= opacity;\r\n        gfx.outlineRect(this._rect, color, gfx.BlendModes.AlphaBlend);\r\n                \r\n        color.a *= 0.25;\r\n        gfx.fillRect(this._rect, color, gfx.BlendModes.AlphaBlend);\r\n    }\r\n}\r\n\r\n// export collision shape class\r\nmodule.exports = RectangleShape;", "/**\r\n * All default collision detection implementations.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\resolvers_imp.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\n\r\n \r\n// export the main methods\r\nconst CollisionsImp = {\r\n    \r\n    /**\r\n     * Test collision between two points.\r\n     */\r\n    pointPoint: function(v1, v2) {\r\n        return v1._position.approximate(v2._position) ? v1._position : false;\r\n    },\r\n\r\n    /**\r\n     * Test collision between point and circle.\r\n     */\r\n    pointCircle: function(v1, c1) {\r\n        return (v1._position.distanceTo(c1._circle.center) <= c1._circle.radius) ? v1._position : false;\r\n    },\r\n\r\n    /**\r\n     * Test collision between point and rectangle.\r\n     */\r\n    pointRectangle: function(v1, r1) {\r\n        return r1._rect.containsVector(v1._position) ? v1._position : false;\r\n    },\r\n\r\n    /**\r\n     * Test collision between point and line.\r\n     */\r\n    pointLine: function(v1, l1) {\r\n        for (let i = 0; i < l1._lines.length; ++i) {\r\n            if (l1._lines[i].containsVector(v1._position)) {\r\n                return v1._position;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Test collision between a point and a tilemap.\r\n     */\r\n    pointTilemap: function(v1, tm) {\r\n        if (tm._intBoundingRect.containsVector(v1._position)) {\r\n            let tile = tm.getTileAt(v1._position);\r\n            return tile ? CollisionsImp.pointRectangle(v1, tile) : false;\r\n        }\r\n        if (tm._borderThickness && tm._boundingRect.containsVector(v1._position)) {\r\n            return v1._position;\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Test collision between circle and circle.\r\n     */\r\n    circleCircle: function(c1, c2) {\r\n        return c1._circle.center.distanceTo(c2._circle.center) <= (c1._circle.radius + c2._circle.radius);\r\n    },\r\n\r\n    /**\r\n     * Test collision between circle and rectangle.\r\n     */\r\n    circleRectangle: function(c1, r1) {\r\n        return r1._rect.collideCircle(c1._circle);\r\n    },\r\n\r\n    /**\r\n     * Test collision between circle and lines.\r\n     */\r\n    circleLine: function(c1, l1) {     \r\n        for (let i = 0; i < l1._lines.length; ++i) {\r\n            if (l1._lines[i].distanceToVector(c1._circle.center) <= c1._circle.radius) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n        \r\n    /**\r\n     * Test collision between circle and tilemap.\r\n     */\r\n    circleTilemap: function(c1, tm) {     \r\n        let collide = false;\r\n        tm.iterateTilesAtRegion(c1._getBoundingBox(), (tile) => {\r\n            if (CollisionsImp.circleRectangle(c1, tile)) {\r\n                collide = true;\r\n                return false;\r\n            }\r\n        });\r\n        return collide;\r\n    },\r\n\r\n    /**\r\n     * Test collision between rectangle and rectangle.\r\n     */\r\n    rectangleRectangle: function(r1, r2) {\r\n        return r1._rect.collideRect(r2._rect);\r\n    },\r\n    \r\n    /**\r\n     * Test collision between rectangle and line.\r\n     */\r\n    rectangleLine: function(r1, l1) {\r\n        for (let i = 0; i < l1._lines.length; ++i) {\r\n            if (r1._rect.collideLine(l1._lines[i])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    \r\n    /**\r\n     * Test collision between rectangle and tilemap.\r\n     */\r\n    rectangleTilemap: function(r1, tm) {     \r\n        let collide = false;\r\n        tm.iterateTilesAtRegion(r1._getBoundingBox(), (tile) => {\r\n            collide = true;\r\n            return false;\r\n        });\r\n        return collide;\r\n    },\r\n\r\n    /**\r\n     * Test collision between line and line.\r\n     */\r\n    lineLine: function(l1, l2) {\r\n        for (let i = 0; i < l1._lines.length; ++i) {\r\n            for (let j = 0; j < l2._lines.length; ++j) {\r\n                if (l1._lines[i].collideLine(l2._lines[j])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Test collision between line and tilemap.\r\n     */\r\n    lineTilemap: function(l1, tm) {     \r\n        let collide = false;\r\n        tm.iterateTilesAtRegion(l1._getBoundingBox(), (tile) => {\r\n            if (CollisionsImp.rectangleLine(tile, l1)) {\r\n                collide = true;\r\n                return false;\r\n            }\r\n        });\r\n        return collide;\r\n    },\r\n}\r\n\r\n\r\n// export the collisions implementation\r\nmodule.exports = CollisionsImp;", "/**\r\n * Implement collision lines.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\shapes\\lines.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\nconst CollisionShape = require(\"./shape\");\r\nconst gfx = require('./../../gfx');\r\nconst Line = require(\"../../utils/line\");\r\nconst Rectangle = require(\"../../utils/rectangle\");\r\nconst Circle = require(\"../../utils/circle\");\r\n\r\n\r\n/**\r\n * Collision lines class.\r\n * This shape is made of one line or more.\r\n */\r\nclass LinesShape extends CollisionShape\r\n{\r\n    /**\r\n     * Create the collision shape.\r\n     * @param {Array<Line>|Line} lines Starting line / lines.\r\n     */\r\n    constructor(lines)\r\n    {\r\n        super();\r\n        this._lines = [];\r\n        this.addLines(lines);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get shapeId()\r\n    {\r\n        return \"lines\";\r\n    }\r\n    \r\n    /**\r\n     * Add line or lines to this collision shape.\r\n     * @param {Array<Line>|Line} lines Line / lines to add.\r\n     */\r\n    addLines(lines)\r\n    {\r\n        // convert to array\r\n        if (!Array.isArray(lines)) {\r\n            lines = [lines];\r\n        }\r\n\r\n        // add lines\r\n        for (let i = 0; i < lines.length; ++i)\r\n        {\r\n            this._lines.push(lines[i]);\r\n        }\r\n\r\n        // get all points\r\n        let points = [];\r\n        for (let i = 0; i < this._lines.length; ++i) {\r\n            points.push(this._lines[i].from);\r\n            points.push(this._lines[i].to);\r\n        }\r\n\r\n        // reset bounding box and circle\r\n        this._boundingBox = Rectangle.fromPoints(points);\r\n        this._circle = new Circle(this._boundingBox.getCenter(), Math.max(this._boundingBox.width, this._boundingBox.height));\r\n        this._shapeChanged();\r\n    }\r\n\r\n    /**\r\n     * Set this shape from line or lines array.\r\n     * @param {Array<Line>|Line} lines Line / lines to set.\r\n     */\r\n    setLines(lines)\r\n    {\r\n        this._lines = [];\r\n        this.addLines(lines);\r\n    }\r\n \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    _getRadius()\r\n    {\r\n        return this._circle.radius;\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    getCenter()\r\n    {\r\n        return this._circle.center.clone();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    _getBoundingBox()\r\n    {\r\n        return this._boundingBox;\r\n    }\r\n\r\n    /**\r\n     * Debug draw this shape.\r\n     * @param {Number} opacity Shape opacity factor.\r\n     */\r\n    debugDraw(opacity)\r\n    {\r\n        if (opacity === undefined) opacity = 1;\r\n        let color = this._getDebugColor();\r\n\r\n        color.a *= opacity;\r\n        for (let i = 0; i < this._lines.length; ++i) {\r\n            gfx.drawLine(this._lines[i].from, this._lines[i].to, color, gfx.BlendModes.AlphaBlend);\r\n        }\r\n    }\r\n}\r\n\r\n// export collision lines class\r\nmodule.exports = LinesShape;", "/**\r\n * Implement collision tilemap.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\shapes\\tilemap.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst CollisionShape = require(\"./shape\");\r\nconst Rectangle = require(\"../../utils/rectangle\");\r\nconst Vector2 = require(\"../../utils/vector2\");\r\nconst gfx = require('./../../gfx');\r\nconst RectangleShape = require(\"./rectangle\");\r\n\r\n\r\n/**\r\n * Collision tilemap class.\r\n * A collision tilemap shape is a grid of equal-sized cells that can either block or not (+ have collision flags).\r\n * Its the most efficient (both memory and CPU) way to implement grid based / tilemap collision.\r\n */\r\nclass TilemapShape extends CollisionShape\r\n{\r\n    /**\r\n     * Create the collision tilemap.\r\n     * @param {Vector2} offset Tilemap top-left corner.\r\n     * @param {Vector2} gridSize Number of tiles on X and Y axis.\r\n     * @param {Vector2} tileSize The size of a single tile.\r\n     * @param {Number} borderThickness Set a border collider with this thickness.\r\n     */\r\n    constructor(offset, gridSize, tileSize, borderThickness)\r\n    {\r\n        super();\r\n        borderThickness = borderThickness || 0;\r\n        this._offset = offset.clone();\r\n        this._intBoundingRect = new Rectangle(offset.x, offset.y, gridSize.x * tileSize.x, gridSize.y * tileSize.y);\r\n        this._boundingRect = this._intBoundingRect.resize(borderThickness * 2);\r\n        this._center = this._boundingRect.getCenter();\r\n        this._radius = this._boundingRect.getBoundingCircle().radius;\r\n        this._borderThickness = borderThickness;\r\n        this._gridSize =  gridSize.clone();\r\n        this._tileSize = tileSize.clone();\r\n        this._tiles = {};\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get shapeId()\r\n    {\r\n        return \"tilemap\";\r\n    }\r\n\r\n    /**\r\n     * Get tile key from vector index.\r\n     * Also validate range.\r\n     * @private\r\n     * @param {Vector2} index Index to get key for.\r\n     * @returns {String} tile key.\r\n     */\r\n    _indexToKey(index)\r\n    {\r\n        if (index.x < 0 || index.y < 0 || index.x >= this._gridSize.x || index.y >= this._gridSize.y) {\r\n            throw new Error(`Collision tile with index ${index.x},${index.y} is out of bounds!`);\r\n        }\r\n        return index.x +',' + index.y;\r\n    }\r\n\r\n    /**\r\n     * Set the state of a tile.\r\n     * @param {Vector2} index Tile index.\r\n     * @param {Boolean} haveCollision Does this tile have collision?\r\n     * @param {Number} collisionFlags Optional collision flag to set for this tile.\r\n     */\r\n    setTile(index, haveCollision, collisionFlags)\r\n    {\r\n        let key = this._indexToKey(index);\r\n        if (haveCollision) {\r\n            let rect = this._tiles[key] || new RectangleShape(\r\n                new Rectangle(\r\n                    this._offset.x + index.x * this._tileSize.x, \r\n                    this._offset.y + index.y * this._tileSize.y, \r\n                    this._tileSize.x, \r\n                    this._tileSize.y)\r\n                );\r\n            if (collisionFlags !== undefined) {\r\n                rect.collisionFlags = collisionFlags;\r\n            }\r\n            this._tiles[key] = rect;\r\n        }\r\n        else {\r\n            delete this._tiles[key];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the collision shape of a tile at a given position.\r\n     * @param {Vector2} position Position to get tile at.\r\n     * @returns {RectangleShape} Collision shape at this position, or null if not set.\r\n     */\r\n    getTileAt(position)\r\n    {\r\n        let index = new Vector2(Math.floor(position.x / this._tileSize.x), Math.floor(position.y / this._tileSize.y));\r\n        let key = index.x + ',' + index.y;\r\n        return this._tiles[key] || null;\r\n    }\r\n    \r\n    /**\r\n     * Iterate all tiles in given region, represented by a rectangle.\r\n     * @param {Rectangle} region Rectangle to get tiles for.\r\n     * @param {Function} callback Method to invoke for every tile. Return false to break iteration.\r\n     */\r\n    iterateTilesAtRegion(region, callback)\r\n    {\r\n        let topLeft = region.getTopLeft();\r\n        let bottomRight = region.getBottomRight();\r\n        let startIndex = new Vector2(Math.floor(topLeft.x / this._tileSize.x), Math.floor(topLeft.y / this._tileSize.y));\r\n        let endIndex = new Vector2(Math.floor(bottomRight.x / this._tileSize.x), Math.floor(bottomRight.y / this._tileSize.y));\r\n        for (let i = startIndex.x; i <= endIndex.x; ++i) {\r\n            for (let j = startIndex.y; j <= endIndex.y; ++j) {\r\n                let key = i + ',' + j;\r\n                let tile = this._tiles[key];\r\n                if (tile && (callback(tile) === false)) { \r\n                    return; \r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get all tiles in given region, represented by a rectangle.\r\n     * @param {Rectangle} region Rectangle to get tiles for.\r\n     * @returns {Array<RectangleShape>} Array with rectangle shapes or empty if none found.\r\n     */\r\n    getTilesAtRegion(region)\r\n    {\r\n        let ret = [];\r\n        this.iterateTilesAtRegion(region, (tile) => { ret.push(tile); });\r\n        return ret;\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc\r\n     */ \r\n    _getRadius()\r\n    {\r\n        return this._radius;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    _getBoundingBox()\r\n    {\r\n        return this._boundingRect;\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    getCenter()\r\n    {\r\n        return this._center.clone();\r\n    }\r\n    \r\n    /**\r\n     * Debug draw this shape.\r\n     * @param {Number} opacity Shape opacity factor.\r\n     */\r\n    debugDraw(opacity)\r\n    {\r\n        if (opacity === undefined) opacity = 1;\r\n        let color = this._getDebugColor();\r\n        color.a *= opacity;\r\n\r\n        // draw borders\r\n        if (this._haveBorders) {\r\n            gfx.outlineRect(this._intBoundingRect, color, gfx.BlendModes.AlphaBlend);\r\n            gfx.outlineRect(this._boundingRect, color, gfx.BlendModes.AlphaBlend);\r\n        }\r\n\r\n        // draw tiles\r\n        for (let key in this._tiles) {\r\n            let tile = this._tiles[key];\r\n            tile.setDebugColor(this._forceDebugColor);\r\n            tile.debugDraw(opacity);\r\n        }\r\n    }\r\n}\r\n\r\n// export collision shape class\r\nmodule.exports = TilemapShape;", "/**\r\n * Implement the collision manager.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\collision.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n'use strict';\r\nconst IManager = require('../manager.js');\r\nconst Vector2 = require('../utils/vector2.js');\r\nconst CollisionWorld = require('./collision_world.js');\r\nconst CollisionResolver = require('./resolver');\r\nconst CircleShape = require('./shapes/circle.js');\r\nconst PointShape = require('./shapes/point.js');\r\nconst RectangleShape = require('./shapes/rectangle.js');\r\nconst ResolverImp = require('./resolvers_imp');\r\nconst LinesShape = require('./shapes/lines.js');\r\nconst TilemapShape = require('./shapes/tilemap.js');\r\nconst _logger = require('../logger.js').getLogger('collision');\r\n\r\n\r\n/**\r\n * Collision is the collision manager. \r\n * It provides basic 2d collision detection functionality.\r\n * Note: this is *not* a physics engine, its only for detection and objects picking.\r\n * \r\n * To access the Collision manager you use `Shaku.collision`. \r\n */\r\nclass Collision extends IManager\r\n{\r\n    /**\r\n     * Create the manager.\r\n     */\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        /**\r\n         * The collision resolver we use to detect collision between different shapes. \r\n         * You can use this object directly without creating a collision world, if you just need to test collision between shapes.\r\n         */\r\n        this.resolver = new CollisionResolver();\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc \r\n     * @private\r\n     **/\r\n    setup()\r\n    {        \r\n        return new Promise((resolve, reject) => {    \r\n            _logger.info(\"Setup collision manager..\");\r\n\r\n            this.resolver._init();\r\n            this.resolver.setHandler(\"point\", \"point\", ResolverImp.pointPoint);\r\n            this.resolver.setHandler(\"point\", \"circle\", ResolverImp.pointCircle);\r\n            this.resolver.setHandler(\"point\", \"rect\", ResolverImp.pointRectangle);\r\n            this.resolver.setHandler(\"point\", \"lines\", ResolverImp.pointLine);\r\n            this.resolver.setHandler(\"point\", \"tilemap\", ResolverImp.pointTilemap);\r\n\r\n            this.resolver.setHandler(\"circle\", \"circle\", ResolverImp.circleCircle);\r\n            this.resolver.setHandler(\"circle\", \"rect\", ResolverImp.circleRectangle);\r\n            this.resolver.setHandler(\"circle\", \"lines\", ResolverImp.circleLine);\r\n            this.resolver.setHandler(\"circle\", \"tilemap\", ResolverImp.circleTilemap);\r\n\r\n            this.resolver.setHandler(\"rect\", \"rect\", ResolverImp.rectangleRectangle);\r\n            this.resolver.setHandler(\"rect\", \"lines\", ResolverImp.rectangleLine);\r\n            this.resolver.setHandler(\"rect\", \"tilemap\", ResolverImp.rectangleTilemap);\r\n\r\n            this.resolver.setHandler(\"lines\", \"lines\", ResolverImp.lineLine);\r\n            this.resolver.setHandler(\"lines\", \"tilemap\", ResolverImp.lineTilemap);\r\n\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new collision world object.\r\n     * @param {Number|Vector2} gridCellSize Collision world grid cell size.\r\n     * @returns {CollisionWorld} Newly created collision world.\r\n     */\r\n    createWorld(gridCellSize)\r\n    {\r\n        return new CollisionWorld(this.resolver, gridCellSize);\r\n    }\r\n\r\n    /**\r\n     * Get the collision reactanle shape class.\r\n     */\r\n    get RectangleShape()\r\n    {\r\n        return RectangleShape\r\n    }\r\n\r\n    /**\r\n     * Get the collision point shape class.\r\n     */\r\n    get PointShape()\r\n    {\r\n        return PointShape;\r\n    }\r\n\r\n    /**\r\n     * Get the collision circle shape class.\r\n     */\r\n    get CircleShape()\r\n    {\r\n        return CircleShape;\r\n    }\r\n\r\n    /**\r\n     * Get the collision lines shape class.\r\n     */\r\n    get LinesShape()\r\n    {\r\n        return LinesShape;\r\n    }\r\n\r\n    /**\r\n     * Get the tilemap collision shape class.\r\n     */\r\n    get TilemapShape()\r\n    {\r\n        return TilemapShape;\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc \r\n     * @private\r\n     **/\r\n    startFrame()\r\n    {\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc \r\n     * @private\r\n     **/\r\n    endFrame()\r\n    {\r\n    }\r\n\r\n    /** \r\n     * @inheritdoc \r\n     * @private\r\n     **/\r\n    destroy()\r\n    {\r\n    }    \r\n}\r\n\r\n// export main object\r\nmodule.exports = new Collision();", "/**\r\n * Just an alias to main manager so we can require() this folder as a package.\r\n * \r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\collision\\index.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n * \r\n */\r\n 'use strict';\r\n module.exports = require('./collision');", "/**\r\n * Shaku Main.\r\n *\r\n * |-- copyright and license --|\r\n * @package    Shaku\r\n * @file       shaku\\lib\\shaku.js\r\n * @author     Ronen Ness (ronenness@gmail.com | http://ronenness.com)\r\n * @copyright  (c) 2021 Ronen Ness\r\n * @license    MIT\r\n * |-- end copyright and license --|\r\n *\r\n */\r\n'use strict'\r\nconst isBrowser = typeof window !== 'undefined'\r\nconst IManager = require('./manager')\r\nconst logger = require('./logger')\r\nconst sfx = isBrowser ? require('./sfx') : null\r\nconst gfx = isBrowser ? require('./gfx') : null\r\nconst input = isBrowser ? require('./input') : null\r\nconst assets = require('./assets')\r\nconst collision = require('./collision')\r\nconst utils = require('./utils')\r\nconst GameTime = require('./utils/game_time')\r\nconst _logger = logger.getLogger('shaku')\r\n\r\n// manager state and gametime\r\nlet _usedManagers = null\r\nlet _prevUpdateTime = null\r\n\r\n// to measure fps\r\nlet _currFpsCounter = 0\r\nlet _countSecond = 0\r\nlet _currFps = 0\r\n\r\n// to measure time it takes for frames to finish\r\nlet _startFrameTime = 0\r\nlet _frameTimeMeasuresCount = 0\r\nlet _totalFrameTimes = 0\r\n\r\n// current version\r\nconst version = '1.5.7'\r\n\r\n/**\r\n * Shaku's main object.\r\n * This object wraps the entire lib namespace, and this is what you use to access all managers and manage your main loop.\r\n */\r\nclass Shaku {\r\n  /**\r\n   * Create the Shaku main object.\r\n   */\r\n  constructor () {\r\n    /**\r\n     * Different utilities and framework objects, like vectors, rectangles, colors, etc.\r\n     */\r\n    this.utils = utils\r\n\r\n    /**\r\n     * Sound effects and music manager.\r\n     */\r\n    this.sfx = sfx\r\n\r\n    /**\r\n     * Graphics manager.\r\n     */\r\n    this.gfx = gfx\r\n\r\n    /**\r\n     * Input manager.\r\n     */\r\n    this.input = input\r\n\r\n    /**\r\n     * Assets manager.\r\n     */\r\n    this.assets = assets\r\n\r\n    /**\r\n     * Collision detection manager.\r\n     */\r\n    this.collision = collision\r\n\r\n    /**\r\n     * If true, will pause the updates and drawing calls when window is not focused.\r\n     * Will also not update elapsed time.\r\n     */\r\n    this.pauseWhenNotFocused = false\r\n\r\n    /**\r\n     * Set to true to completely pause Shaku (will skip updates, drawing, and time counting).\r\n     */\r\n    this.paused = false\r\n\r\n    /**\r\n     * Set to true to pause just the game time.\r\n     * This will not pause real-life time. If you need real-life time stop please use the Python package.\r\n     */\r\n    this.pauseTime = false\r\n\r\n    // are managers currently in 'started' mode?\r\n    this._managersStarted = false\r\n\r\n    // were we previously paused?\r\n    this._wasPaused = false\r\n  }\r\n\r\n  /**\r\n   * Method to select managers to use + initialize them.\r\n   * @param {Array<IManager> | null} managers Array with list of managers to use or null to use all.\r\n   * @returns {Promise} promise to resolve when finish initialization.\r\n   */\r\n  async init (managers) {\r\n    return new Promise(async (resolve, reject) => {\r\n      // sanity & log\r\n      if (_usedManagers) {\r\n        throw new Error('Already initialized!')\r\n      }\r\n      _logger.info(`Initialize Shaku v${version}.`)\r\n\r\n      // reset game start time\r\n      GameTime.reset()\r\n\r\n      // setup used managers\r\n      _usedManagers =\r\n        managers ||\r\n        (isBrowser ? [assets, sfx, gfx, input, collision] : [assets, collision])\r\n\r\n      // init all managers\r\n      for (let i = 0; i < _usedManagers.length; ++i) {\r\n        await _usedManagers[i].setup()\r\n      }\r\n\r\n      // set starting time\r\n      _prevUpdateTime = new GameTime()\r\n\r\n      // done!\r\n      resolve()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Destroy all managers\r\n   */\r\n  destroy () {\r\n    // sanity\r\n    if (!_usedManagers) {\r\n      throw new Error('Not initialized!')\r\n    }\r\n\r\n    // destroy all managers\r\n    for (let i = 0; i < _usedManagers.length; ++i) {\r\n      _usedManagers[i].destroy()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get if the Shaku is currently paused.\r\n   */\r\n  get isPaused () {\r\n    return this.paused || (this.pauseWhenNotFocused && !document.hasFocus())\r\n  }\r\n\r\n  /**\r\n   * Start frame (update all managers).\r\n   */\r\n  startFrame () {\r\n    // if paused, skip\r\n    if (this.isPaused) {\r\n      this._wasPaused = true\r\n      return\r\n    }\r\n\r\n    // returning from pause\r\n    if (this._wasPaused) {\r\n      this._wasPaused = false\r\n      GameTime.resetDelta()\r\n    }\r\n\r\n    // update times\r\n    if (this.pauseTime) {\r\n      GameTime.resetDelta()\r\n    } else {\r\n      GameTime.update()\r\n    }\r\n\r\n    // get frame start time\r\n    _startFrameTime = GameTime.rawTimestamp()\r\n\r\n    // create new gameTime object\r\n    this._gameTime = new GameTime()\r\n\r\n    // update animators\r\n    utils.Animator.updateAutos(this._gameTime.delta)\r\n\r\n    // update managers\r\n    for (let i = 0; i < _usedManagers.length; ++i) {\r\n      _usedManagers[i].startFrame()\r\n    }\r\n    this._managersStarted = true\r\n  }\r\n\r\n  /**\r\n   * End frame (update all managers).\r\n   */\r\n  endFrame () {\r\n    // update managers\r\n    if (this._managersStarted) {\r\n      for (let i = 0; i < _usedManagers.length; ++i) {\r\n        _usedManagers[i].endFrame()\r\n      }\r\n      this._managersStarted = false\r\n    }\r\n\r\n    // if paused, skip\r\n    if (this.isPaused) {\r\n      return\r\n    }\r\n\r\n    // store previous gameTime object\r\n    _prevUpdateTime = this._gameTime\r\n\r\n    // count fps and time stats\r\n    if (this._gameTime) {\r\n      this._updateFpsAndTimeStats()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Measure FPS and averege update times.\r\n   * @private\r\n   */\r\n  _updateFpsAndTimeStats () {\r\n    // update fps count and second counter\r\n    _currFpsCounter++\r\n    _countSecond += this._gameTime.delta\r\n\r\n    // a second passed:\r\n    if (_countSecond >= 1) {\r\n      // reset second count and set current fps value\r\n      _countSecond = 0\r\n      _currFps = _currFpsCounter\r\n      _currFpsCounter = 0\r\n\r\n      // trim the frames avg time, so we won't drag peaks for too long\r\n      _totalFrameTimes = this.getAverageFrameTime()\r\n      _frameTimeMeasuresCount = 1\r\n    }\r\n\r\n    // get frame end time and update average frames time\r\n    let _endFrameTime = GameTime.rawTimestamp()\r\n    _frameTimeMeasuresCount++\r\n    _totalFrameTimes += _endFrameTime - _startFrameTime\r\n  }\r\n\r\n  /**\r\n   * Make Shaku run in silent mode, without logs.\r\n   * You can call this before init.\r\n   */\r\n  silent () {\r\n    logger.silent()\r\n  }\r\n\r\n  /**\r\n   * Set logger to throw an error every time a log message with severity higher than warning is written.\r\n   * You can call this before init.\r\n   * @param {Boolean} enable Set to true to throw error on warnings.\r\n   */\r\n  throwErrorOnWarnings (enable) {\r\n    if (enable === undefined) {\r\n      throw Error('Must provide a value!')\r\n    }\r\n    logger.throwErrorOnWarnings(enable)\r\n  }\r\n\r\n  /**\r\n   * Get current frame game time.\r\n   * Only valid between startFrame() and endFrame().\r\n   * @returns {GameTime} Current frame's gametime.\r\n   */\r\n  get gameTime () {\r\n    return this._gameTime\r\n  }\r\n\r\n  /**\r\n   * Get Shaku's version.\r\n   * @returns {String} Shaku's version.\r\n   */\r\n  get version () {\r\n    return version\r\n  }\r\n\r\n  /**\r\n   * Return current FPS count.\r\n   * Note: will return 0 until at least one second have passed.\r\n   * @returns {Number} FPS count.\r\n   */\r\n  getFpsCount () {\r\n    return _currFps\r\n  }\r\n\r\n  /**\r\n   * Get how long on average it takes to complete a game frame.\r\n   * @returns {Number} Average time, in milliseconds, it takes to complete a game frame.\r\n   */\r\n  getAverageFrameTime () {\r\n    if (_frameTimeMeasuresCount === 0) {\r\n      return 0\r\n    }\r\n    return _totalFrameTimes / _frameTimeMeasuresCount\r\n  }\r\n\r\n  /**\r\n   * Request animation frame with fallbacks.\r\n   * @param {Function} callback Method to invoke in next animation frame.\r\n   * @returns {Number} Handle for cancellation.\r\n   */\r\n  requestAnimationFrame (callback) {\r\n    if (window.requestAnimationFrame)\r\n      return window.requestAnimationFrame(callback)\r\n    else if (window.mozRequestAnimationFrame)\r\n      return window.mozRequestAnimationFrame(callback)\r\n    else if (window.webkitRequestAnimationFrame)\r\n      return window.webkitRequestAnimationFrame(callback)\r\n    else if (window.msRequestAnimationFrame)\r\n      return window.msRequestAnimationFrame(callback)\r\n    else return setTimeout(callback, 1000 / 60)\r\n  }\r\n\r\n  /**\r\n   * Cancel animation frame with fallbacks.\r\n   * @param {Number} id Request handle.\r\n   */\r\n  cancelAnimationFrame (id) {\r\n    if (window.cancelAnimationFrame) return window.cancelAnimationFrame(id)\r\n    else if (window.mozCancelAnimationFrame)\r\n      return window.mozCancelAnimationFrame(id)\r\n    else clearTimeout(id)\r\n  }\r\n\r\n  /**\r\n   * Set the logger writer class (will replace the default console output).\r\n   * @param {*} loggerHandler New logger handler (must implement trace, debug, info, warn, error methods).\r\n   */\r\n  setLogger (loggerHandler) {\r\n    logger.setDrivers(loggerHandler)\r\n  }\r\n}\r\n\r\n// create and return the main object.\r\nmodule.exports = new Shaku()\r\n", "import TextureAsset = require(\"shaku/lib/assets/texture_asset\");\r\nimport { BlendModes } from \"shaku/lib/gfx\";\r\nimport Shaku = require(\"shaku/lib/shaku\");\r\n\r\nasync function runGame() {\r\n    // init shaku\r\n    await Shaku.init(null);\r\n\r\n    // add shaku's canvas to document and set resolution to 800x600\r\n    document.body.appendChild(Shaku!.gfx!.canvas);\r\n    Shaku.gfx!.setResolution(800, 600, true);\r\n    Shaku.gfx!.centerCanvas();\r\n    // Shaku.gfx!.maximizeCanvasSize(false, false);\r\n\r\n    // TODO: INIT STUFF AND LOAD ASSETS HERE\r\n    let soundAsset = await Shaku.assets.loadSound('../sounds/example_sound.wav');\r\n    let soundInstance = Shaku.sfx!.createSound(soundAsset);\r\n\r\n    let texture = await Shaku.assets.loadTexture('../imgs/example_image.png', null);\r\n    let sprite = new Shaku.gfx!.Sprite(texture, null);\r\n    sprite.position.set(Shaku.gfx!.canvas.width / 2, Shaku.gfx!.canvas.height / 2);\r\n\r\n    let texture2 = await loadAsciiTexture(`\r\n        .000.\r\n        .111.\r\n        22222\r\n        .333.\r\n        .3.3.\r\n    `, [Shaku.utils.Color.black,\r\n        Shaku.utils.Color.orange,\r\n        Shaku.utils.Color.white,\r\n        Shaku.utils.Color.blue\r\n    ]);\r\n    let sprite2 = new Shaku.gfx!.Sprite(texture2, null);\r\n    sprite2.position.set(Shaku.gfx!.canvas.width / 2, Shaku.gfx!.canvas.height / 2);\r\n    sprite2.size.mulSelf(30);\r\n\r\n\r\n    // do a single main loop step and request the next step\r\n    function step() {\r\n        // start a new frame and clear screen\r\n        Shaku.startFrame();\r\n        Shaku.gfx!.clear(Shaku.utils.Color.cornflowerblue);\r\n\r\n        // TODO: PUT YOUR GAME UPDATES / RENDERING HERE\r\n        Shaku.gfx!.drawSprite(sprite);\r\n        if (Shaku.input!.pressed(\"a\")) {\r\n            soundInstance.play();\r\n        }\r\n\r\n        Shaku.gfx!.drawSprite(sprite2);\r\n\r\n        // end frame and request next step\r\n        Shaku.endFrame();\r\n        Shaku.requestAnimationFrame(step);\r\n    }\r\n\r\n    let hola = Shaku!.gfx!.canvas;\r\n    console.log(hola);\r\n\r\n    // console.log(Shaku)\r\n\r\n    // start main loop\r\n    step();\r\n};\r\n\r\nrunGame();\r\n\r\n\r\nasync function loadAsciiTexture(ascii: string, colors: (string | Shaku.utils.Color)[]): Promise<TextureAsset> {\r\n\r\n    let rows = ascii.trim().split(\"\\n\").map(x => x.trim())\r\n    console.log(rows)\r\n    let height = rows.length\r\n    let width = rows[0].length\r\n\r\n    // create render target\r\n    let renderTarget = await Shaku.assets.createRenderTarget(null, width, height, 4);\r\n    \r\n    // use render target\r\n    Shaku.gfx!.setRenderTarget(renderTarget, false);\r\n    \r\n    for (let j = 0; j < height; j++) {\r\n        for (let i = 0; i < width; i++) {\r\n            let val = rows[j][i];\r\n            if (val === '.' || val === ' ') continue;\r\n            let n = parseInt(val);\r\n            \r\n            let col = colors[n];\r\n            if (typeof col === 'string') {\r\n                col = Shaku.utils.Color.fromHex(col);\r\n            }\r\n            Shaku.gfx!.fillRect(\r\n                new Shaku.utils.Rectangle(i,height - j - 1,1,1),\r\n                col,\r\n                BlendModes.Opaque, 0\r\n            );\r\n        }        \r\n    }    \r\n\r\n    // reset render target\r\n    Shaku.gfx!.setRenderTarget(null, false);\r\n\r\n    return renderTarget;\r\n}\r\n"],
  "mappings": "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QACzE;AAAA,QAAK;AAAA,QAAE;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAE;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QACzE;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QACxE;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QACxE;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QACxE;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAE;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QACxE;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI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",
  "names": ["BlendModes", "Line", "Line", "reject", "TextureAsset", "reject", "z", "TextureAsset", "z", "z", "TextureAsset", "BlendModes", "TextureAsset", "reject", "BlendModes", "topLeft", "topRight", "bottomLeft", "bottomRight", "pi", "uvi", "z", "BlendModes", "TextureAsset", "reject", "resolve", "i", "require_gfx", "reject", "reject", "require_sfx", "reject", "event", "require_input", "reject", "reject", "TextureAsset", "reject", "require_assets", "require_circle", "require_rectangle", "Line", "reject", "require_collision", "Shaku", "reject"]
}
